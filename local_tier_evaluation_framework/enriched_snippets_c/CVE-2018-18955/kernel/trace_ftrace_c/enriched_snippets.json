[
  {
    "function_name": "ftrace_graph_exit_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "7084-7093",
    "snippet": "void ftrace_graph_exit_task(struct task_struct *t)\n{\n\tstruct ftrace_ret_stack\t*ret_stack = t->ret_stack;\n\n\tt->ret_stack = NULL;\n\t/* NULL must become visible to IRQs before we free it: */\n\tbarrier();\n\n\tkfree(ret_stack);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret_stack"
          ],
          "line": 7092
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 7090
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_exit_task(struct task_struct *t)\n{\n\tstruct ftrace_ret_stack\t*ret_stack = t->ret_stack;\n\n\tt->ret_stack = NULL;\n\t/* NULL must become visible to IRQs before we free it: */\n\tbarrier();\n\n\tkfree(ret_stack);\n}"
  },
  {
    "function_name": "ftrace_graph_init_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "7066-7082",
    "snippet": "void ftrace_graph_init_task(struct task_struct *t)\n{\n\t/* Make sure we do not use the parent ret_stack */\n\tt->ret_stack = NULL;\n\tt->curr_ret_stack = -1;\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = kmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t  sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ret_stack)\n\t\t\treturn;\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_init_task",
          "args": [
            "t",
            "ret_stack"
          ],
          "line": 7080
        },
        "resolved": true,
        "details": {
          "function_name": "graph_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7023-7032",
          "snippet": "static void\ngraph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)\n{\n\tatomic_set(&t->tracing_graph_pause, 0);\n\tatomic_set(&t->trace_overrun, 0);\n\tt->ftrace_timestamp = 0;\n\t/* make curr_ret_stack visible before we add the ret_stack */\n\tsmp_wmb();\n\tt->ret_stack = ret_stack;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\ngraph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)\n{\n\tatomic_set(&t->tracing_graph_pause, 0);\n\tatomic_set(&t->trace_overrun, 0);\n\tt->ftrace_timestamp = 0;\n\t/* make curr_ret_stack visible before we add the ret_stack */\n\tsmp_wmb();\n\tt->ret_stack = ret_stack;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "FTRACE_RETFUNC_DEPTH",
            "sizeof(struct ftrace_ret_stack)",
            "GFP_KERNEL"
          ],
          "line": 7075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_init_task(struct task_struct *t)\n{\n\t/* Make sure we do not use the parent ret_stack */\n\tt->ret_stack = NULL;\n\tt->curr_ret_stack = -1;\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = kmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t  sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ret_stack)\n\t\t\treturn;\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}"
  },
  {
    "function_name": "ftrace_graph_init_idle_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "7038-7063",
    "snippet": "void ftrace_graph_init_idle_task(struct task_struct *t, int cpu)\n{\n\tt->curr_ret_stack = -1;\n\t/*\n\t * The idle task has no parent, it either has its own\n\t * stack or no stack at all.\n\t */\n\tif (t->ret_stack)\n\t\tWARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = per_cpu(idle_ret_stack, cpu);\n\t\tif (!ret_stack) {\n\t\t\tret_stack =\n\t\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ret_stack)\n\t\t\t\treturn;\n\t\t\tper_cpu(idle_ret_stack, cpu) = ret_stack;\n\t\t}\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_init_task",
          "args": [
            "t",
            "ret_stack"
          ],
          "line": 7061
        },
        "resolved": true,
        "details": {
          "function_name": "graph_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7023-7032",
          "snippet": "static void\ngraph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)\n{\n\tatomic_set(&t->tracing_graph_pause, 0);\n\tatomic_set(&t->trace_overrun, 0);\n\tt->ftrace_timestamp = 0;\n\t/* make curr_ret_stack visible before we add the ret_stack */\n\tsmp_wmb();\n\tt->ret_stack = ret_stack;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\ngraph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)\n{\n\tatomic_set(&t->tracing_graph_pause, 0);\n\tatomic_set(&t->trace_overrun, 0);\n\tt->ftrace_timestamp = 0;\n\t/* make curr_ret_stack visible before we add the ret_stack */\n\tsmp_wmb();\n\tt->ret_stack = ret_stack;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "idle_ret_stack",
            "cpu"
          ],
          "line": 7059
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "FTRACE_RETFUNC_DEPTH",
            "sizeof(struct ftrace_ret_stack)",
            "GFP_KERNEL"
          ],
          "line": 7054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "t->ret_stack != per_cpu(idle_ret_stack, cpu)"
          ],
          "line": 7046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_init_idle_task(struct task_struct *t, int cpu)\n{\n\tt->curr_ret_stack = -1;\n\t/*\n\t * The idle task has no parent, it either has its own\n\t * stack or no stack at all.\n\t */\n\tif (t->ret_stack)\n\t\tWARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = per_cpu(idle_ret_stack, cpu);\n\t\tif (!ret_stack) {\n\t\t\tret_stack =\n\t\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ret_stack)\n\t\t\t\treturn;\n\t\t\tper_cpu(idle_ret_stack, cpu) = ret_stack;\n\t\t}\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}"
  },
  {
    "function_name": "graph_init_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "7023-7032",
    "snippet": "static void\ngraph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)\n{\n\tatomic_set(&t->tracing_graph_pause, 0);\n\tatomic_set(&t->trace_overrun, 0);\n\tt->ftrace_timestamp = 0;\n\t/* make curr_ret_stack visible before we add the ret_stack */\n\tsmp_wmb();\n\tt->ret_stack = ret_stack;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 7030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&t->trace_overrun",
            "0"
          ],
          "line": 7027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&t->tracing_graph_pause",
            "0"
          ],
          "line": 7026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\ngraph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)\n{\n\tatomic_set(&t->tracing_graph_pause, 0);\n\tatomic_set(&t->trace_overrun, 0);\n\tt->ftrace_timestamp = 0;\n\t/* make curr_ret_stack visible before we add the ret_stack */\n\tsmp_wmb();\n\tt->ret_stack = ret_stack;\n}"
  },
  {
    "function_name": "unregister_ftrace_graph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "7002-7019",
    "snippet": "void unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7018
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "ftrace_graph_probe_sched_switch",
            "NULL"
          ],
          "line": 7015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_pm_notifier",
          "args": [
            "&ftrace_suspend_notifier"
          ],
          "line": 7014
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_pm_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "64-67",
          "snippet": "int unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "&graph_ops",
            "FTRACE_STOP_FUNC_RET"
          ],
          "line": 7013
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2727-2839",
          "snippet": "static int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ftrace_graph_active"
          ],
          "line": 7006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 7004
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "register_ftrace_graph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6962-7000",
    "snippet": "int register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6998
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup",
          "args": [
            "&graph_ops",
            "FTRACE_START_FUNC_RET"
          ],
          "line": 6996
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2685-2725",
          "snippet": "static int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_function_graph_func",
          "args": [],
          "line": 6994
        },
        "resolved": true,
        "details": {
          "function_name": "update_function_graph_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6932-6956",
          "snippet": "static void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_graph_tracing",
          "args": [],
          "line": 6978
        },
        "resolved": true,
        "details": {
          "function_name": "start_graph_tracing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6864-6895",
          "snippet": "static int start_graph_tracing(void)\n{\n\tstruct ftrace_ret_stack **ret_stack_list;\n\tint ret, cpu;\n\n\tret_stack_list = kmalloc_array(FTRACE_RETSTACK_ALLOC_SIZE,\n\t\t\t\t       sizeof(struct ftrace_ret_stack *),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!ret_stack_list)\n\t\treturn -ENOMEM;\n\n\t/* The cpu_boot init_task->ret_stack will never be freed */\n\tfor_each_online_cpu(cpu) {\n\t\tif (!idle_task(cpu)->ret_stack)\n\t\t\tftrace_graph_init_idle_task(idle_task(cpu), cpu);\n\t}\n\n\tdo {\n\t\tret = alloc_retstack_tasklist(ret_stack_list);\n\t} while (ret == -EAGAIN);\n\n\tif (!ret) {\n\t\tret = register_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\t\tif (ret)\n\t\t\tpr_info(\"ftrace_graph: Couldn't activate tracepoint\"\n\t\t\t\t\" probe to kernel_sched_switch\\n\");\n\t}\n\n\tkfree(ret_stack_list);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int start_graph_tracing(void)\n{\n\tstruct ftrace_ret_stack **ret_stack_list;\n\tint ret, cpu;\n\n\tret_stack_list = kmalloc_array(FTRACE_RETSTACK_ALLOC_SIZE,\n\t\t\t\t       sizeof(struct ftrace_ret_stack *),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!ret_stack_list)\n\t\treturn -ENOMEM;\n\n\t/* The cpu_boot init_task->ret_stack will never be freed */\n\tfor_each_online_cpu(cpu) {\n\t\tif (!idle_task(cpu)->ret_stack)\n\t\t\tftrace_graph_init_idle_task(idle_task(cpu), cpu);\n\t}\n\n\tdo {\n\t\tret = alloc_retstack_tasklist(ret_stack_list);\n\t} while (ret == -EAGAIN);\n\n\tif (!ret) {\n\t\tret = register_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\t\tif (ret)\n\t\t\tpr_info(\"ftrace_graph: Couldn't activate tracepoint\"\n\t\t\t\t\" probe to kernel_sched_switch\\n\");\n\t}\n\n\tkfree(ret_stack_list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_pm_notifier",
          "args": [
            "&ftrace_suspend_notifier"
          ],
          "line": 6975
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_pm_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "64-67",
          "snippet": "int unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6967
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nint register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_function_graph_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6932-6956",
    "snippet": "static void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 6950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 6943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}"
  },
  {
    "function_name": "ftrace_graph_entry_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6918-6923",
    "snippet": "static int ftrace_graph_entry_test(struct ftrace_graph_ent *trace)\n{\n\tif (!ftrace_ops_test(&global_ops, trace->func, NULL))\n\t\treturn 0;\n\treturn __ftrace_graph_entry(trace);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_graph_entry",
          "args": [
            "trace"
          ],
          "line": 6922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_test",
          "args": [
            "&global_ops",
            "trace->func",
            "NULL"
          ],
          "line": 6920
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6216-6220",
          "snippet": "static inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nstatic int ftrace_graph_entry_test(struct ftrace_graph_ent *trace)\n{\n\tif (!ftrace_ops_test(&global_ops, trace->func, NULL))\n\t\treturn 0;\n\treturn __ftrace_graph_entry(trace);\n}"
  },
  {
    "function_name": "ftrace_suspend_notifier_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6902-6916",
    "snippet": "static int\nftrace_suspend_notifier_call(struct notifier_block *bl, unsigned long state,\n\t\t\t\t\t\t\tvoid *unused)\n{\n\tswitch (state) {\n\tcase PM_HIBERNATION_PREPARE:\n\t\tpause_graph_tracing();\n\t\tbreak;\n\n\tcase PM_POST_HIBERNATION:\n\t\tunpause_graph_tracing();\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_graph_tracing",
          "args": [],
          "line": 6912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pause_graph_tracing",
          "args": [],
          "line": 6908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_suspend_notifier_call(struct notifier_block *bl, unsigned long state,\n\t\t\t\t\t\t\tvoid *unused)\n{\n\tswitch (state) {\n\tcase PM_HIBERNATION_PREPARE:\n\t\tpause_graph_tracing();\n\t\tbreak;\n\n\tcase PM_POST_HIBERNATION:\n\t\tunpause_graph_tracing();\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "start_graph_tracing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6864-6895",
    "snippet": "static int start_graph_tracing(void)\n{\n\tstruct ftrace_ret_stack **ret_stack_list;\n\tint ret, cpu;\n\n\tret_stack_list = kmalloc_array(FTRACE_RETSTACK_ALLOC_SIZE,\n\t\t\t\t       sizeof(struct ftrace_ret_stack *),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!ret_stack_list)\n\t\treturn -ENOMEM;\n\n\t/* The cpu_boot init_task->ret_stack will never be freed */\n\tfor_each_online_cpu(cpu) {\n\t\tif (!idle_task(cpu)->ret_stack)\n\t\t\tftrace_graph_init_idle_task(idle_task(cpu), cpu);\n\t}\n\n\tdo {\n\t\tret = alloc_retstack_tasklist(ret_stack_list);\n\t} while (ret == -EAGAIN);\n\n\tif (!ret) {\n\t\tret = register_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\t\tif (ret)\n\t\t\tpr_info(\"ftrace_graph: Couldn't activate tracepoint\"\n\t\t\t\t\" probe to kernel_sched_switch\\n\");\n\t}\n\n\tkfree(ret_stack_list);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret_stack_list"
          ],
          "line": 6893
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace_graph: Couldn't activate tracepoint\"\n\t\t\t\t\" probe to kernel_sched_switch\\n\""
          ],
          "line": 6889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "ftrace_graph_probe_sched_switch",
            "NULL"
          ],
          "line": 6887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_retstack_tasklist",
          "args": [
            "ret_stack_list"
          ],
          "line": 6883
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_retstack_tasklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6786-6829",
          "snippet": "static int alloc_retstack_tasklist(struct ftrace_ret_stack **ret_stack_list)\n{\n\tint i;\n\tint ret = 0;\n\tint start = 0, end = FTRACE_RETSTACK_ALLOC_SIZE;\n\tstruct task_struct *g, *t;\n\n\tfor (i = 0; i < FTRACE_RETSTACK_ALLOC_SIZE; i++) {\n\t\tret_stack_list[i] =\n\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!ret_stack_list[i]) {\n\t\t\tstart = 0;\n\t\t\tend = i;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tread_lock(&tasklist_lock);\n\tdo_each_thread(g, t) {\n\t\tif (start == end) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (t->ret_stack == NULL) {\n\t\t\tatomic_set(&t->tracing_graph_pause, 0);\n\t\t\tatomic_set(&t->trace_overrun, 0);\n\t\t\tt->curr_ret_stack = -1;\n\t\t\t/* Make sure the tasks see the -1 first: */\n\t\t\tsmp_wmb();\n\t\t\tt->ret_stack = ret_stack_list[start++];\n\t\t}\n\t} while_each_thread(g, t);\n\nunlock:\n\tread_unlock(&tasklist_lock);\nfree:\n\tfor (i = start; i < end; i++)\n\t\tkfree(ret_stack_list[i]);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int alloc_retstack_tasklist(struct ftrace_ret_stack **ret_stack_list)\n{\n\tint i;\n\tint ret = 0;\n\tint start = 0, end = FTRACE_RETSTACK_ALLOC_SIZE;\n\tstruct task_struct *g, *t;\n\n\tfor (i = 0; i < FTRACE_RETSTACK_ALLOC_SIZE; i++) {\n\t\tret_stack_list[i] =\n\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!ret_stack_list[i]) {\n\t\t\tstart = 0;\n\t\t\tend = i;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tread_lock(&tasklist_lock);\n\tdo_each_thread(g, t) {\n\t\tif (start == end) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (t->ret_stack == NULL) {\n\t\t\tatomic_set(&t->tracing_graph_pause, 0);\n\t\t\tatomic_set(&t->trace_overrun, 0);\n\t\t\tt->curr_ret_stack = -1;\n\t\t\t/* Make sure the tasks see the -1 first: */\n\t\t\tsmp_wmb();\n\t\t\tt->ret_stack = ret_stack_list[start++];\n\t\t}\n\t} while_each_thread(g, t);\n\nunlock:\n\tread_unlock(&tasklist_lock);\nfree:\n\tfor (i = start; i < end; i++)\n\t\tkfree(ret_stack_list[i]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_init_idle_task",
          "args": [
            "idle_task(cpu)",
            "cpu"
          ],
          "line": 6879
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_init_idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7038-7063",
          "snippet": "void ftrace_graph_init_idle_task(struct task_struct *t, int cpu)\n{\n\tt->curr_ret_stack = -1;\n\t/*\n\t * The idle task has no parent, it either has its own\n\t * stack or no stack at all.\n\t */\n\tif (t->ret_stack)\n\t\tWARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = per_cpu(idle_ret_stack, cpu);\n\t\tif (!ret_stack) {\n\t\t\tret_stack =\n\t\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ret_stack)\n\t\t\t\treturn;\n\t\t\tper_cpu(idle_ret_stack, cpu) = ret_stack;\n\t\t}\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_init_idle_task(struct task_struct *t, int cpu)\n{\n\tt->curr_ret_stack = -1;\n\t/*\n\t * The idle task has no parent, it either has its own\n\t * stack or no stack at all.\n\t */\n\tif (t->ret_stack)\n\t\tWARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = per_cpu(idle_ret_stack, cpu);\n\t\tif (!ret_stack) {\n\t\t\tret_stack =\n\t\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ret_stack)\n\t\t\t\treturn;\n\t\t\tper_cpu(idle_ret_stack, cpu) = ret_stack;\n\t\t}\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 6879
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4029-4032",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "FTRACE_RETSTACK_ALLOC_SIZE",
            "sizeof(struct ftrace_ret_stack *)",
            "GFP_KERNEL"
          ],
          "line": 6869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int start_graph_tracing(void)\n{\n\tstruct ftrace_ret_stack **ret_stack_list;\n\tint ret, cpu;\n\n\tret_stack_list = kmalloc_array(FTRACE_RETSTACK_ALLOC_SIZE,\n\t\t\t\t       sizeof(struct ftrace_ret_stack *),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!ret_stack_list)\n\t\treturn -ENOMEM;\n\n\t/* The cpu_boot init_task->ret_stack will never be freed */\n\tfor_each_online_cpu(cpu) {\n\t\tif (!idle_task(cpu)->ret_stack)\n\t\t\tftrace_graph_init_idle_task(idle_task(cpu), cpu);\n\t}\n\n\tdo {\n\t\tret = alloc_retstack_tasklist(ret_stack_list);\n\t} while (ret == -EAGAIN);\n\n\tif (!ret) {\n\t\tret = register_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\t\tif (ret)\n\t\t\tpr_info(\"ftrace_graph: Couldn't activate tracepoint\"\n\t\t\t\t\" probe to kernel_sched_switch\\n\");\n\t}\n\n\tkfree(ret_stack_list);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_probe_sched_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6831-6861",
    "snippet": "static void\nftrace_graph_probe_sched_switch(void *ignore, bool preempt,\n\t\t\tstruct task_struct *prev, struct task_struct *next)\n{\n\tunsigned long long timestamp;\n\tint index;\n\n\t/*\n\t * Does the user want to count the time a function was asleep.\n\t * If so, do not update the time stamps.\n\t */\n\tif (fgraph_sleep_time)\n\t\treturn;\n\n\ttimestamp = trace_clock_local();\n\n\tprev->ftrace_timestamp = timestamp;\n\n\t/* only process tasks that we timestamped */\n\tif (!next->ftrace_timestamp)\n\t\treturn;\n\n\t/*\n\t * Update all the counters in next to make up for the\n\t * time next was sleeping.\n\t */\n\ttimestamp -= next->ftrace_timestamp;\n\n\tfor (index = next->curr_ret_stack; index >= 0; index--)\n\t\tnext->ret_stack[index].calltime += timestamp;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 6845
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_clock.c",
          "lines": "32-46",
          "snippet": "u64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/trace_clock.h>",
            "#include <linux/ktime.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/hardirq.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n\nu64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_graph_probe_sched_switch(void *ignore, bool preempt,\n\t\t\tstruct task_struct *prev, struct task_struct *next)\n{\n\tunsigned long long timestamp;\n\tint index;\n\n\t/*\n\t * Does the user want to count the time a function was asleep.\n\t * If so, do not update the time stamps.\n\t */\n\tif (fgraph_sleep_time)\n\t\treturn;\n\n\ttimestamp = trace_clock_local();\n\n\tprev->ftrace_timestamp = timestamp;\n\n\t/* only process tasks that we timestamped */\n\tif (!next->ftrace_timestamp)\n\t\treturn;\n\n\t/*\n\t * Update all the counters in next to make up for the\n\t * time next was sleeping.\n\t */\n\ttimestamp -= next->ftrace_timestamp;\n\n\tfor (index = next->curr_ret_stack; index >= 0; index--)\n\t\tnext->ret_stack[index].calltime += timestamp;\n}"
  },
  {
    "function_name": "alloc_retstack_tasklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6786-6829",
    "snippet": "static int alloc_retstack_tasklist(struct ftrace_ret_stack **ret_stack_list)\n{\n\tint i;\n\tint ret = 0;\n\tint start = 0, end = FTRACE_RETSTACK_ALLOC_SIZE;\n\tstruct task_struct *g, *t;\n\n\tfor (i = 0; i < FTRACE_RETSTACK_ALLOC_SIZE; i++) {\n\t\tret_stack_list[i] =\n\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!ret_stack_list[i]) {\n\t\t\tstart = 0;\n\t\t\tend = i;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tread_lock(&tasklist_lock);\n\tdo_each_thread(g, t) {\n\t\tif (start == end) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (t->ret_stack == NULL) {\n\t\t\tatomic_set(&t->tracing_graph_pause, 0);\n\t\t\tatomic_set(&t->trace_overrun, 0);\n\t\t\tt->curr_ret_stack = -1;\n\t\t\t/* Make sure the tasks see the -1 first: */\n\t\t\tsmp_wmb();\n\t\t\tt->ret_stack = ret_stack_list[start++];\n\t\t}\n\t} while_each_thread(g, t);\n\nunlock:\n\tread_unlock(&tasklist_lock);\nfree:\n\tfor (i = start; i < end; i++)\n\t\tkfree(ret_stack_list[i]);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret_stack_list[i]"
          ],
          "line": 6827
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 6824
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "g",
            "t"
          ],
          "line": 6821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 6818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&t->trace_overrun",
            "0"
          ],
          "line": 6815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&t->tracing_graph_pause",
            "0"
          ],
          "line": 6814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_thread",
          "args": [
            "g",
            "t"
          ],
          "line": 6807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 6806
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "FTRACE_RETFUNC_DEPTH",
            "sizeof(struct ftrace_ret_stack)",
            "GFP_KERNEL"
          ],
          "line": 6795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int alloc_retstack_tasklist(struct ftrace_ret_stack **ret_stack_list)\n{\n\tint i;\n\tint ret = 0;\n\tint start = 0, end = FTRACE_RETSTACK_ALLOC_SIZE;\n\tstruct task_struct *g, *t;\n\n\tfor (i = 0; i < FTRACE_RETSTACK_ALLOC_SIZE; i++) {\n\t\tret_stack_list[i] =\n\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!ret_stack_list[i]) {\n\t\t\tstart = 0;\n\t\t\tend = i;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tread_lock(&tasklist_lock);\n\tdo_each_thread(g, t) {\n\t\tif (start == end) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (t->ret_stack == NULL) {\n\t\t\tatomic_set(&t->tracing_graph_pause, 0);\n\t\t\tatomic_set(&t->trace_overrun, 0);\n\t\t\tt->curr_ret_stack = -1;\n\t\t\t/* Make sure the tasks see the -1 first: */\n\t\t\tsmp_wmb();\n\t\t\tt->ret_stack = ret_stack_list[start++];\n\t\t}\n\t} while_each_thread(g, t);\n\nunlock:\n\tread_unlock(&tasklist_lock);\nfree:\n\tfor (i = start; i < end; i++)\n\t\tkfree(ret_stack_list[i]);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_entry_stub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6774-6777",
    "snippet": "int ftrace_graph_entry_stub(struct ftrace_graph_ent *trace)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_graph_entry_stub(struct ftrace_graph_ent *trace)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_graph_graph_time_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6769-6772",
    "snippet": "void ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}"
  },
  {
    "function_name": "ftrace_graph_sleep_time_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6764-6767",
    "snippet": "void ftrace_graph_sleep_time_control(bool enable)\n{\n\tfgraph_sleep_time = enable;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_sleep_time_control(bool enable)\n{\n\tfgraph_sleep_time = enable;\n}"
  },
  {
    "function_name": "ftrace_enable_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6709-6747",
    "snippet": "int\nftrace_enable_sysctl(struct ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp,\n\t\t     loff_t *ppos)\n{\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write || (last_ftrace_enabled == !!ftrace_enabled))\n\t\tgoto out;\n\n\tlast_ftrace_enabled = !!ftrace_enabled;\n\n\tif (ftrace_enabled) {\n\n\t\t/* we are starting ftrace again */\n\t\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) != &ftrace_list_end)\n\t\t\tupdate_ftrace_function();\n\n\t\tftrace_startup_sysctl();\n\n\t} else {\n\t\t/* stopping ftrace calls (just send to ftrace_stub) */\n\t\tftrace_trace_function = ftrace_stub;\n\n\t\tftrace_shutdown_sysctl();\n\t}\n\n out:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static int last_ftrace_enabled;",
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6745
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown_sysctl",
          "args": [],
          "line": 6741
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2859-2873",
          "snippet": "static void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup_sysctl",
          "args": [],
          "line": 6735
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2841-2857",
          "snippet": "static void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 6733
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "214-291",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
          ],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 6731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 6721
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_ms_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3224-3228",
          "snippet": "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 6718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6716
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic int last_ftrace_enabled;\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nint\nftrace_enable_sysctl(struct ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp,\n\t\t     loff_t *ppos)\n{\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write || (last_ftrace_enabled == !!ftrace_enabled))\n\t\tgoto out;\n\n\tlast_ftrace_enabled = !!ftrace_enabled;\n\n\tif (ftrace_enabled) {\n\n\t\t/* we are starting ftrace again */\n\t\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) != &ftrace_list_end)\n\t\t\tupdate_ftrace_function();\n\n\t\tftrace_startup_sysctl();\n\n\t} else {\n\t\t/* stopping ftrace calls (just send to ftrace_stub) */\n\t\tftrace_trace_function = ftrace_stub;\n\n\t\tftrace_shutdown_sysctl();\n\t}\n\n out:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_ftrace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6697-6706",
    "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6703
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "ops",
            "0"
          ],
          "line": 6702
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2727-2839",
          "snippet": "static int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6701
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_ftrace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6675-6688",
    "snippet": "int register_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret = -1;\n\n\tftrace_ops_init(ops);\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_startup(ops, 0);\n\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6685
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup",
          "args": [
            "ops",
            "0"
          ],
          "line": 6683
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2685-2725",
          "snippet": "static int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6681
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 6679
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint register_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret = -1;\n\n\tftrace_ops_init(ops);\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_startup(ops, 0);\n\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_is_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6659-6662",
    "snippet": "int ftrace_is_dead(void)\n{\n\treturn ftrace_disabled;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nint ftrace_is_dead(void)\n{\n\treturn ftrace_disabled;\n}"
  },
  {
    "function_name": "ftrace_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6649-6654",
    "snippet": "void ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static int ftrace_disabled",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic int ftrace_disabled;\nftrace_func_t ftrace_trace_function;\n\nvoid ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}"
  },
  {
    "function_name": "ftrace_init_tracefs_toplevel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6632-6640",
    "snippet": "void __init ftrace_init_tracefs_toplevel(struct trace_array *tr,\n\t\t\t\t\t struct dentry *d_tracer)\n{\n\t/* Only the top level directory has the dyn_tracefs and profile */\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\n\tftrace_init_dyn_tracefs(d_tracer);\n\tftrace_profile_tracefs(d_tracer);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_profile_tracefs",
          "args": [
            "d_tracer"
          ],
          "line": 6639
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_tracefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1019-1021",
          "snippet": "static __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_init_dyn_tracefs",
          "args": [
            "d_tracer"
          ],
          "line": 6638
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_dyn_tracefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6194-6194",
          "snippet": "static inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(tr->flags & TRACE_ARRAY_FL_GLOBAL)"
          ],
          "line": 6636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __init ftrace_init_tracefs_toplevel(struct trace_array *tr,\n\t\t\t\t\t struct dentry *d_tracer)\n{\n\t/* Only the top level directory has the dyn_tracefs and profile */\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\n\tftrace_init_dyn_tracefs(d_tracer);\n\tftrace_profile_tracefs(d_tracer);\n}"
  },
  {
    "function_name": "ftrace_init_tracefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6626-6630",
    "snippet": "void ftrace_init_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\ttrace_create_file(\"set_ftrace_pid\", 0644, d_tracer,\n\t\t\t    tr, &ftrace_pid_fops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ftrace_pid_fops = {\n\t.open\t\t= ftrace_pid_open,\n\t.write\t\t= ftrace_pid_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_pid_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"set_ftrace_pid\"",
            "0644",
            "d_tracer",
            "tr",
            "&ftrace_pid_fops"
          ],
          "line": 6628
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic const struct file_operations ftrace_pid_fops = {\n\t.open\t\t= ftrace_pid_open,\n\t.write\t\t= ftrace_pid_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_pid_release,\n};\n\nvoid ftrace_init_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\ttrace_create_file(\"set_ftrace_pid\", 0644, d_tracer,\n\t\t\t    tr, &ftrace_pid_fops);\n}"
  },
  {
    "function_name": "ftrace_pid_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6608-6616",
    "snippet": "static int\nftrace_pid_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 6615
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "219-233",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 6613
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_pid_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "ftrace_pid_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6558-6606",
    "snippet": "static ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->function_pids, pid_list);\n\n\tif (filtered_pids) {\n\t\tsynchronize_sched();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6600
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup_all",
          "args": [
            "0"
          ],
          "line": 6598
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6196-6196",
          "snippet": "static inline void ftrace_startup_all(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_all(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_pid_func",
          "args": [],
          "line": 6597
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_pid_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "398-415",
          "snippet": "static void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "ignore_task_cpu",
            "tr",
            "1"
          ],
          "line": 6595
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "37-45",
          "snippet": "int on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "ftrace_filter_pid_sched_switch_probe",
            "tr"
          ],
          "line": 6587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_free_pid_list",
          "args": [
            "filtered_pids"
          ],
          "line": 6584
        },
        "resolved": true,
        "details": {
          "function_name": "trace_free_pid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "318-322",
          "snippet": "void trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 6583
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->function_pids",
            "pid_list"
          ],
          "line": 6580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_pid_write",
          "args": [
            "filtered_pids",
            "&pid_list",
            "ubuf",
            "cnt"
          ],
          "line": 6576
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pid_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6558-6606",
          "snippet": "static ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->function_pids, pid_list);\n\n\tif (filtered_pids) {\n\t\tsynchronize_sched();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 6573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6571
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->function_pids, pid_list);\n\n\tif (filtered_pids) {\n\t\tsynchronize_sched();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ignore_task_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6542-6556",
    "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ftrace_ignore_pid",
            "trace_ignore_this_task(pid_list, current)"
          ],
          "line": 6554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "current"
          ],
          "line": 6555
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "mutex_is_locked(&ftrace_lock)"
          ],
          "line": 6551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
  },
  {
    "function_name": "ftrace_pid_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6516-6540",
    "snippet": "static int\nftrace_pid_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr);\n\n\tret = seq_open(file, &ftrace_pid_sops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 6532
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ftrace_pid_sops"
          ],
          "line": 6530
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_pid_reset",
          "args": [
            "tr"
          ],
          "line": 6528
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pid_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6450-6459",
          "snippet": "static void ftrace_pid_reset(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ftrace_pid_reset(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 6523
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "274-290",
          "snippet": "int trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic const struct seq_operations ftrace_pid_sops = {\n\t.start = fpid_start,\n\t.next = fpid_next,\n\t.stop = fpid_stop,\n\t.show = fpid_show,\n};\n\nstatic int\nftrace_pid_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_pid_reset(tr);\n\n\tret = seq_open(file, &ftrace_pid_sops);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t} else {\n\t\tm = file->private_data;\n\t\t/* copy tr over to seq ops */\n\t\tm->private = tr;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fpid_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6499-6507",
    "snippet": "static int fpid_show(struct seq_file *m, void *v)\n{\n\tif (v == FTRACE_NO_PIDS) {\n\t\tseq_puts(m, \"no pid\\n\");\n\t\treturn 0;\n\t}\n\n\treturn trace_pid_show(m, v);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_show",
          "args": [
            "m",
            "v"
          ],
          "line": 6506
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "465-471",
          "snippet": "int trace_pid_show(struct seq_file *m, void *v)\n{\n\tunsigned long pid = (unsigned long)v - 1;\n\n\tseq_printf(m, \"%lu\\n\", pid);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_pid_show(struct seq_file *m, void *v)\n{\n\tunsigned long pid = (unsigned long)v - 1;\n\n\tseq_printf(m, \"%lu\\n\", pid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"no pid\\n\""
          ],
          "line": 6502
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic int fpid_show(struct seq_file *m, void *v)\n{\n\tif (v == FTRACE_NO_PIDS) {\n\t\tseq_puts(m, \"no pid\\n\");\n\t\treturn 0;\n\t}\n\n\treturn trace_pid_show(m, v);\n}"
  },
  {
    "function_name": "fpid_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6492-6497",
    "snippet": "static void fpid_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6496
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 6495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 6493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void fpid_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "fpid_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6481-6490",
    "snippet": "static void *fpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (v == FTRACE_NO_PIDS)\n\t\treturn NULL;\n\n\treturn trace_pid_next(pid_list, v, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_next",
          "args": [
            "pid_list",
            "v",
            "pos"
          ],
          "line": 6489
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "414-428",
          "snippet": "void *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tunsigned long pid = (unsigned long)v;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual prevous bit */\n\tpid = find_next_bit(pid_list->pids, pid_list->pid_max, pid);\n\n\t/* Return pid + 1 to allow zero to be represented */\n\tif (pid < pid_list->pid_max)\n\t\treturn (void *)(pid + 1);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tunsigned long pid = (unsigned long)v;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual prevous bit */\n\tpid = find_next_bit(pid_list->pids, pid_list->pid_max, pid);\n\n\t/* Return pid + 1 to allow zero to be represented */\n\tif (pid < pid_list->pid_max)\n\t\treturn (void *)(pid + 1);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 6484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic void *fpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (v == FTRACE_NO_PIDS)\n\t\treturn NULL;\n\n\treturn trace_pid_next(pid_list, v, pos);\n}"
  },
  {
    "function_name": "fpid_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6464-6479",
    "snippet": "static void *fpid_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&ftrace_lock);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (!pid_list)\n\t\treturn !(*pos) ? FTRACE_NO_PIDS : NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_start",
          "args": [
            "pid_list",
            "pos"
          ],
          "line": 6478
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "441-455",
          "snippet": "void *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tloff_t l = 0;\n\n\tpid = find_first_bit(pid_list->pids, pid_list->pid_max);\n\tif (pid >= pid_list->pid_max)\n\t\treturn NULL;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tloff_t l = 0;\n\n\tpid = find_first_bit(pid_list->pids, pid_list->pid_max);\n\tif (pid >= pid_list->pid_max)\n\t\treturn NULL;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 6473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 6471
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6470
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 6465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void *fpid_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&ftrace_lock);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\n\tif (!pid_list)\n\t\treturn !(*pos) ? FTRACE_NO_PIDS : NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
  },
  {
    "function_name": "ftrace_pid_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6450-6459",
    "snippet": "static void ftrace_pid_reset(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6458
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup_all",
          "args": [
            "0"
          ],
          "line": 6456
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6196-6196",
          "snippet": "static inline void ftrace_startup_all(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_all(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_pid_func",
          "args": [],
          "line": 6455
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_pid_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "398-415",
          "snippet": "static void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ftrace_pids",
          "args": [
            "tr"
          ],
          "line": 6453
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ftrace_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6418-6439",
          "snippet": "static void clear_ftrace_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ftrace_ignore_pid = false;\n\n\trcu_assign_pointer(tr->function_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_sched();\n\n\ttrace_free_pid_list(pid_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void clear_ftrace_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ftrace_ignore_pid = false;\n\n\trcu_assign_pointer(tr->function_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_sched();\n\n\ttrace_free_pid_list(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6452
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ftrace_pid_reset(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\tclear_ftrace_pids(tr);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "ftrace_clear_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6441-6448",
    "snippet": "void ftrace_clear_pids(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tclear_ftrace_pids(tr);\n\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6447
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ftrace_pids",
          "args": [
            "tr"
          ],
          "line": 6445
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ftrace_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6418-6439",
          "snippet": "static void clear_ftrace_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ftrace_ignore_pid = false;\n\n\trcu_assign_pointer(tr->function_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_sched();\n\n\ttrace_free_pid_list(pid_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void clear_ftrace_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ftrace_ignore_pid = false;\n\n\trcu_assign_pointer(tr->function_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_sched();\n\n\ttrace_free_pid_list(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6443
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid ftrace_clear_pids(struct trace_array *tr)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tclear_ftrace_pids(tr);\n\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "clear_ftrace_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6418-6439",
    "snippet": "static void clear_ftrace_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ftrace_ignore_pid = false;\n\n\trcu_assign_pointer(tr->function_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_sched();\n\n\ttrace_free_pid_list(pid_list);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_free_pid_list",
          "args": [
            "pid_list"
          ],
          "line": 6438
        },
        "resolved": true,
        "details": {
          "function_name": "trace_free_pid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "318-322",
          "snippet": "void trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 6436
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->function_pids",
            "NULL"
          ],
          "line": 6433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "ftrace_filter_pid_sched_switch_probe",
            "tr"
          ],
          "line": 6428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->function_pids",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 6423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void clear_ftrace_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ftrace_ignore_pid = false;\n\n\trcu_assign_pointer(tr->function_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\tsynchronize_sched();\n\n\ttrace_free_pid_list(pid_list);\n}"
  },
  {
    "function_name": "ftrace_pid_follow_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6403-6416",
    "snippet": "void ftrace_pid_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t  tr);\n\t\tregister_trace_sched_process_exit(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t  tr);\n\t} else {\n\t\tunregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_exit(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_exit",
          "args": [
            "ftrace_pid_follow_sched_process_exit",
            "tr"
          ],
          "line": 6413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_fork",
          "args": [
            "ftrace_pid_follow_sched_process_fork",
            "tr"
          ],
          "line": 6411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_process_exit",
          "args": [
            "ftrace_pid_follow_sched_process_exit",
            "tr"
          ],
          "line": 6408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_process_fork",
          "args": [
            "ftrace_pid_follow_sched_process_fork",
            "tr"
          ],
          "line": 6406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_pid_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t  tr);\n\t\tregister_trace_sched_process_exit(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t  tr);\n\t} else {\n\t\tunregister_trace_sched_process_fork(ftrace_pid_follow_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_exit(ftrace_pid_follow_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}"
  },
  {
    "function_name": "ftrace_pid_follow_sched_process_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6393-6401",
    "snippet": "static void\nftrace_pid_follow_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "NULL",
            "task"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "378-400",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_pid_follow_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}"
  },
  {
    "function_name": "ftrace_pid_follow_sched_process_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6381-6391",
    "snippet": "static void\nftrace_pid_follow_sched_process_fork(void *data,\n\t\t\t\t     struct task_struct *self,\n\t\t\t\t     struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "self",
            "task"
          ],
          "line": 6390
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "378-400",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 6389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_pid_follow_sched_process_fork(void *data,\n\t\t\t\t     struct task_struct *self,\n\t\t\t\t     struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}"
  },
  {
    "function_name": "ftrace_filter_pid_sched_switch_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6368-6379",
    "snippet": "static void\nftrace_filter_pid_sched_switch_probe(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, next));\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ftrace_ignore_pid",
            "trace_ignore_this_task(pid_list, next)"
          ],
          "line": 6377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "next"
          ],
          "line": 6378
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->function_pids"
          ],
          "line": 6375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nftrace_filter_pid_sched_switch_probe(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->function_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, next));\n}"
  },
  {
    "function_name": "ftrace_ops_get_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6355-6366",
    "snippet": "ftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion, needs to be RCU safe,\n\t * or does per cpu logic, then we need to call the assist handler.\n\t */\n\tif (!(ops->flags & FTRACE_OPS_FL_RECURSION_SAFE) ||\n\t    ops->flags & FTRACE_OPS_FL_RCU)\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion, needs to be RCU safe,\n\t * or does per cpu logic, then we need to call the assist handler.\n\t */\n\tif (!(ops->flags & FTRACE_OPS_FL_RECURSION_SAFE) ||\n\t    ops->flags & FTRACE_OPS_FL_RCU)\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}"
  },
  {
    "function_name": "ftrace_ops_assist_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6324-6342",
    "snippet": "static void ftrace_ops_assist_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct ftrace_ops *op, struct pt_regs *regs)\n{\n\tint bit;\n\n\tif ((op->flags & FTRACE_OPS_FL_RCU) && !rcu_is_watching())\n\t\treturn;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\n\top->func(ip, parent_ip, op, regs);\n\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_clear_recursion",
          "args": [
            "bit"
          ],
          "line": 6341
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clear_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "569-581",
          "snippet": "static __always_inline void trace_clear_recursion(int bit)\n{\n\tunsigned int val = current->trace_recursion;\n\n\tif (!bit)\n\t\treturn;\n\n\tbit = 1 << bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->trace_recursion = val;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline void trace_clear_recursion(int bit)\n{\n\tunsigned int val = current->trace_recursion;\n\n\tif (!bit)\n\t\treturn;\n\n\tbit = 1 << bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->trace_recursion = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 6340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->func",
          "args": [
            "ip",
            "parent_ip",
            "op",
            "regs"
          ],
          "line": 6338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 6336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_and_set_recursion",
          "args": [
            "TRACE_LIST_START",
            "TRACE_LIST_MAX"
          ],
          "line": 6332
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_and_set_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "549-567",
          "snippet": "static __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->trace_recursion;\n\tint bit;\n\n\t/* A previous recursion check was made */\n\tif ((val & TRACE_CONTEXT_MASK) > max)\n\t\treturn 0;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\treturn bit;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TRACE_CONTEXT_MASK\tTRACE_LIST_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\n#define TRACE_CONTEXT_MASK\tTRACE_LIST_MAX\n\nstatic __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->trace_recursion;\n\tint bit;\n\n\t/* A previous recursion check was made */\n\tif ((val & TRACE_CONTEXT_MASK) > max)\n\t\treturn 0;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 6329
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_ops_assist_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct ftrace_ops *op, struct pt_regs *regs)\n{\n\tint bit;\n\n\tif ((op->flags & FTRACE_OPS_FL_RCU) && !rcu_is_watching())\n\t\treturn;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\n\top->func(ip, parent_ip, op, regs);\n\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}"
  },
  {
    "function_name": "ftrace_ops_no_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6313-6316",
    "snippet": "static void ftrace_ops_no_ops(unsigned long ip, unsigned long parent_ip)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, NULL);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_ops_list_func",
          "args": [
            "ip",
            "parent_ip",
            "NULL",
            "NULL"
          ],
          "line": 6315
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_ops_list_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6252-6291",
          "snippet": "static inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct pt_regs *regs)\n{\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they must be freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, regs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct pt_regs *regs)\n{\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they must be freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, regs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_ops_no_ops(unsigned long ip, unsigned long parent_ip)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, NULL);\n}"
  },
  {
    "function_name": "ftrace_ops_list_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6307-6311",
    "snippet": "static void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t struct ftrace_ops *op, struct pt_regs *regs)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, regs);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_ops_list_func",
          "args": [
            "ip",
            "parent_ip",
            "NULL",
            "regs"
          ],
          "line": 6310
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_ops_list_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6252-6291",
          "snippet": "static inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct pt_regs *regs)\n{\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they must be freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, regs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct pt_regs *regs)\n{\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they must be freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, regs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstatic void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t struct ftrace_ops *op, struct pt_regs *regs)\n{\n\t__ftrace_ops_list_func(ip, parent_ip, NULL, regs);\n}"
  },
  {
    "function_name": "__ftrace_ops_list_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6252-6291",
    "snippet": "static inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct pt_regs *regs)\n{\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they must be freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, regs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_clear_recursion",
          "args": [
            "bit"
          ],
          "line": 6290
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clear_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "569-581",
          "snippet": "static __always_inline void trace_clear_recursion(int bit)\n{\n\tunsigned int val = current->trace_recursion;\n\n\tif (!bit)\n\t\treturn;\n\n\tbit = 1 << bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->trace_recursion = val;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline void trace_clear_recursion(int bit)\n{\n\tunsigned int val = current->trace_recursion;\n\n\tif (!bit)\n\t\treturn;\n\n\tbit = 1 << bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->trace_recursion = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 6289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 6287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->func",
          "args": [
            "ip",
            "parent_ip",
            "op",
            "regs"
          ],
          "line": 6285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"op=%p %pS\\n\"",
            "op",
            "op"
          ],
          "line": 6282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "!op->func"
          ],
          "line": 6281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_test",
          "args": [
            "op",
            "ip",
            "regs"
          ],
          "line": 6280
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6216-6220",
          "snippet": "static inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 6279
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 6269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 6267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_and_set_recursion",
          "args": [
            "TRACE_LIST_START",
            "TRACE_LIST_MAX"
          ],
          "line": 6259
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_and_set_recursion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "549-567",
          "snippet": "static __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->trace_recursion;\n\tint bit;\n\n\t/* A previous recursion check was made */\n\tif ((val & TRACE_CONTEXT_MASK) > max)\n\t\treturn 0;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\treturn bit;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TRACE_CONTEXT_MASK\tTRACE_LIST_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\n#define TRACE_CONTEXT_MASK\tTRACE_LIST_MAX\n\nstatic __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->trace_recursion;\n\tint bit;\n\n\t/* A previous recursion check was made */\n\tif ((val & TRACE_CONTEXT_MASK) > max)\n\t\treturn 0;\n\n\tbit = trace_get_context_bit() + start;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->trace_recursion = val;\n\tbarrier();\n\n\treturn bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void\n__ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t       struct ftrace_ops *ignored, struct pt_regs *regs)\n{\n\tstruct ftrace_ops *op;\n\tint bit;\n\n\tbit = trace_test_and_set_recursion(TRACE_LIST_START, TRACE_LIST_MAX);\n\tif (bit < 0)\n\t\treturn;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they must be freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * Check the following for each ops before calling their func:\n\t\t *  if RCU flag is set, then rcu_is_watching() must be true\n\t\t *  if PER_CPU is set, then ftrace_function_local_disable()\n\t\t *                          must be false\n\t\t *  Otherwise test if the ip matches the ops filter\n\t\t *\n\t\t * If any of the above fails then the op->func() is not executed.\n\t\t */\n\t\tif ((!(op->flags & FTRACE_OPS_FL_RCU) || rcu_is_watching()) &&\n\t\t    ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (FTRACE_WARN_ON(!op->func)) {\n\t\t\t\tpr_warn(\"op=%p %pS\\n\", op, op);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\top->func(ip, parent_ip, op, regs);\n\t\t}\n\t} while_for_each_ftrace_op(op);\nout:\n\tpreempt_enable_notrace();\n\ttrace_clear_recursion(bit);\n}"
  },
  {
    "function_name": "ftrace_reset_array_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6247-6250",
    "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
  },
  {
    "function_name": "ftrace_init_array_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6235-6245",
    "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ftrace ops had %pS for function\\n\"",
            "tr->ops->func"
          ],
          "line": 6240
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tr->ops->func != ftrace_stub"
          ],
          "line": 6239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
  },
  {
    "function_name": "ftrace_init_global_array_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6228-6233",
    "snippet": "__init void ftrace_init_global_array_ops(struct trace_array *tr)\n{\n\ttr->ops = &global_ops;\n\ttr->ops->private = tr;\n\tftrace_init_trace_array(tr);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_init_trace_array",
          "args": [
            "tr"
          ],
          "line": 6232
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6172-6177",
          "snippet": "void ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\n__init void ftrace_init_global_array_ops(struct trace_array *tr)\n{\n\ttr->ops = &global_ops;\n\ttr->ops->private = tr;\n\tftrace_init_trace_array(tr);\n}"
  },
  {
    "function_name": "ftrace_update_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6222-6224",
    "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
  },
  {
    "function_name": "ftrace_ops_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6216-6220",
    "snippet": "static inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_startup_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6196-6196",
    "snippet": "static inline void ftrace_startup_all(int command) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_all(int command) { }"
  },
  {
    "function_name": "ftrace_startup_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6195-6195",
    "snippet": "static inline void ftrace_startup_enable(int command) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
  },
  {
    "function_name": "ftrace_init_dyn_tracefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6194-6194",
    "snippet": "static inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline int ftrace_init_dyn_tracefs(struct dentry *d_tracer) { return 0; }"
  },
  {
    "function_name": "ftrace_nodyn_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6187-6191",
    "snippet": "static int __init ftrace_nodyn_init(void)\n{\n\tftrace_enabled = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\n\nstatic int __init ftrace_nodyn_init(void)\n{\n\tftrace_enabled = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_init_trace_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6172-6177",
    "snippet": "void ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->mod_notrace"
          ],
          "line": 6176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->mod_trace"
          ],
          "line": 6175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->func_probes"
          ],
          "line": 6174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_init_trace_array(struct trace_array *tr)\n{\n\tINIT_LIST_HEAD(&tr->func_probes);\n\tINIT_LIST_HEAD(&tr->mod_trace);\n\tINIT_LIST_HEAD(&tr->mod_notrace);\n}"
  },
  {
    "function_name": "ftrace_update_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6167-6170",
    "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n\tarch_ftrace_update_trampoline(ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_ftrace_update_trampoline",
          "args": [
            "ops"
          ],
          "line": 6169
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_update_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6163-6165",
          "snippet": "void __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n\tarch_ftrace_update_trampoline(ops);\n}"
  },
  {
    "function_name": "arch_ftrace_update_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6163-6165",
    "snippet": "void __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
  },
  {
    "function_name": "ftrace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6127-6160",
    "snippet": "void __init ftrace_init(void)\n{\n\textern unsigned long __start_mcount_loc[];\n\textern unsigned long __stop_mcount_loc[];\n\tunsigned long count, flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = ftrace_dyn_arch_init();\n\tlocal_irq_restore(flags);\n\tif (ret)\n\t\tgoto failed;\n\n\tcount = __stop_mcount_loc - __start_mcount_loc;\n\tif (!count) {\n\t\tpr_info(\"ftrace: No functions to be traced?\\n\");\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"ftrace: allocating %ld entries in %ld pages\\n\",\n\t\tcount, count / ENTRIES_PER_PAGE + 1);\n\n\tlast_ftrace_enabled = ftrace_enabled = 1;\n\n\tret = ftrace_process_locs(NULL,\n\t\t\t\t  __start_mcount_loc,\n\t\t\t\t  __stop_mcount_loc);\n\n\tset_ftrace_early_filters();\n\n\treturn;\n failed:\n\tftrace_disabled = 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
    ],
    "globals_used": [
      "int ftrace_enabled",
      "static int last_ftrace_enabled;",
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ftrace_early_filters",
          "args": [],
          "line": 6155
        },
        "resolved": true,
        "details": {
          "function_name": "set_ftrace_early_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4946-4958",
          "snippet": "static void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops global_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nstatic void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_process_locs",
          "args": [
            "NULL",
            "__start_mcount_loc",
            "__stop_mcount_loc"
          ],
          "line": 6151
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_locs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5501-5598",
          "snippet": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, NULL);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, NULL);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: allocating %ld entries in %ld pages\\n\"",
            "count",
            "count / ENTRIES_PER_PAGE + 1"
          ],
          "line": 6146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: No functions to be traced?\\n\""
          ],
          "line": 6142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_dyn_arch_init",
          "args": [],
          "line": 6135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 6134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nint ftrace_enabled;\nstatic int last_ftrace_enabled;\nstatic int ftrace_disabled;\n\nvoid __init ftrace_init(void)\n{\n\textern unsigned long __start_mcount_loc[];\n\textern unsigned long __stop_mcount_loc[];\n\tunsigned long count, flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = ftrace_dyn_arch_init();\n\tlocal_irq_restore(flags);\n\tif (ret)\n\t\tgoto failed;\n\n\tcount = __stop_mcount_loc - __start_mcount_loc;\n\tif (!count) {\n\t\tpr_info(\"ftrace: No functions to be traced?\\n\");\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"ftrace: allocating %ld entries in %ld pages\\n\",\n\t\tcount, count / ENTRIES_PER_PAGE + 1);\n\n\tlast_ftrace_enabled = ftrace_enabled = 1;\n\n\tret = ftrace_process_locs(NULL,\n\t\t\t\t  __start_mcount_loc,\n\t\t\t\t  __stop_mcount_loc);\n\n\tset_ftrace_early_filters();\n\n\treturn;\n failed:\n\tftrace_disabled = 1;\n}"
  },
  {
    "function_name": "ftrace_free_init_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6119-6125",
    "snippet": "void __init ftrace_free_init_mem(void)\n{\n\tvoid *start = (void *)(&__init_begin);\n\tvoid *end = (void *)(&__init_end);\n\n\tftrace_free_mem(NULL, start, end);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_free_mem",
          "args": [
            "NULL",
            "start",
            "end"
          ],
          "line": 6124
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_free_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6049-6117",
          "snippet": "void ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\tint order;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\t\tfree_pages((unsigned long)pg->records, order);\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nvoid ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\tint order;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\t\tfree_pages((unsigned long)pg->records, order);\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __init ftrace_free_init_mem(void)\n{\n\tvoid *start = (void *)(&__init_begin);\n\tvoid *end = (void *)(&__init_end);\n\n\tftrace_free_mem(NULL, start, end);\n}"
  },
  {
    "function_name": "ftrace_free_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6049-6117",
    "snippet": "void ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\tint order;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\t\tfree_pages((unsigned long)pg->records, order);\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);",
      "static struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "func"
          ],
          "line": 6115
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_func_from_hashes",
          "args": [
            "func"
          ],
          "line": 6114
        },
        "resolved": true,
        "details": {
          "function_name": "clear_func_from_hashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6017-6032",
          "snippet": "static void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "func",
            "func_next",
            "&clear_hash",
            "list"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6111
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rec",
            "rec + 1",
            "(pg->index - (rec - pg->records)) * sizeof(*rec)"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "last_pg",
            "structftrace_page",
            "next"
          ],
          "line": 6101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)pg->records",
            "order"
          ],
          "line": 6099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count_order",
          "args": [
            "pg->size / ENTRIES_PER_PAGE"
          ],
          "line": 6098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_ftrace_mod_rec",
          "args": [
            "mod_map",
            "rec"
          ],
          "line": 6092
        },
        "resolved": true,
        "details": {
          "function_name": "save_ftrace_mod_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5982-5983",
          "snippet": "static void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }"
        }
      },
      {
        "call_info": {
          "callee": "add_to_clear_hash_list",
          "args": [
            "&clear_hash",
            "rec"
          ],
          "line": 6089
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_clear_hash_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6034-6047",
          "snippet": "static void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tWARN_ONCE(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tWARN_ONCE(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&key",
            "pg->records",
            "pg->index",
            "sizeof(struct dyn_ftrace)",
            "ftrace_cmp_recs"
          ],
          "line": 6082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_mod_map",
          "args": [
            "mod",
            "start",
            "end"
          ],
          "line": 6075
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_mod_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5984-5989",
          "snippet": "static inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 6067
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clear_hash"
          ],
          "line": 6062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nvoid ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tstruct list_head clear_hash;\n\tint order;\n\n\tINIT_LIST_HEAD(&clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\t\tfree_pages((unsigned long)pg->records, order);\n\t\t\tkfree(pg);\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n}"
  },
  {
    "function_name": "add_to_clear_hash_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6034-6047",
    "snippet": "static void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tWARN_ONCE(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&func->list",
            "clear_list"
          ],
          "line": 6046
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"alloc failure, ftrace filter could be stale\\n\""
          ],
          "line": 6041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*func)",
            "GFP_KERNEL"
          ],
          "line": 6039
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void add_to_clear_hash_list(struct list_head *clear_list,\n\t\t\t\t   struct dyn_ftrace *rec)\n{\n\tstruct ftrace_init_func *func;\n\n\tfunc = kmalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tWARN_ONCE(1, \"alloc failure, ftrace filter could be stale\\n\");\n\t\treturn;\n\t}\n\n\tfunc->ip = rec->ip;\n\tlist_add(&func->list, clear_list);\n}"
  },
  {
    "function_name": "clear_func_from_hashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "6017-6032",
    "snippet": "static void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 6031
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_func_from_hash",
          "args": [
            "func",
            "tr->ops->func_hash->notrace_hash"
          ],
          "line": 6028
        },
        "resolved": true,
        "details": {
          "function_name": "clear_func_from_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5998-6015",
          "snippet": "static void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tentry = __ftrace_lookup_ip(hash, func->ip);\n\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tentry = __ftrace_lookup_ip(hash, func->ip);\n\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->ops->func_hash->regex_lock"
          ],
          "line": 6026
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nclear_func_from_hashes(struct ftrace_init_func *func)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->filter_hash);\n\t\tclear_func_from_hash(func, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
  },
  {
    "function_name": "clear_func_from_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5998-6015",
    "snippet": "static void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tentry = __ftrace_lookup_ip(hash, func->ip);\n\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash",
            "func->ip"
          ],
          "line": 6006
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1148-1163",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 6003
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_func_from_hash(struct ftrace_init_func *func, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tentry = __ftrace_lookup_ip(hash, func->ip);\n\n\t/*\n\t * Do not allow this rec to match again.\n\t * Yeah, it may waste some memory, but will be removed\n\t * if/when the hash is modified again.\n\t */\n\tif (entry)\n\t\tentry->ip = 0;\n}"
  },
  {
    "function_name": "allocate_ftrace_mod_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5984-5989",
    "snippet": "static inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "save_ftrace_mod_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5982-5983",
    "snippet": "static void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec) { }"
  },
  {
    "function_name": "ftrace_mod_get_kallsym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5945-5979",
    "snippet": "int ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name,\n\t\t\t   char *module_name, int *exported)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_func *mod_func;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\n\t\tif (symnum >= mod_map->num_funcs) {\n\t\t\tsymnum -= mod_map->num_funcs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\t\tif (symnum > 1) {\n\t\t\t\tsymnum--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*value = mod_func->ip;\n\t\t\t*type = 'T';\n\t\t\tstrlcpy(name, mod_func->name, KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = 1;\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 5977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 5974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 5971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "module_name",
            "mod_map->mod->name",
            "MODULE_NAME_LEN"
          ],
          "line": 5969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "name",
            "mod_func->name",
            "KSYM_NAME_LEN"
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_func",
            "&mod_map->funcs",
            "list"
          ],
          "line": 5960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_map",
            "&ftrace_mod_maps",
            "list"
          ],
          "line": 5953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 5952
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name,\n\t\t\t   char *module_name, int *exported)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_func *mod_func;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\n\t\tif (symnum >= mod_map->num_funcs) {\n\t\t\tsymnum -= mod_map->num_funcs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\t\tif (symnum > 1) {\n\t\t\t\tsymnum--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*value = mod_func->ip;\n\t\t\t*type = 'T';\n\t\t\tstrlcpy(name, mod_func->name, KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = 1;\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
  },
  {
    "function_name": "ftrace_mod_address_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5923-5943",
    "snippet": "const char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu_sched() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 5940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_address_lookup",
          "args": [
            "mod_map",
            "addr",
            "size",
            "off",
            "sym"
          ],
          "line": 5933
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_address_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5893-5921",
          "snippet": "static const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_map",
            "&ftrace_mod_maps",
            "list"
          ],
          "line": 5932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 5931
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nconst char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu_sched() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_func_address_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5893-5921",
    "snippet": "static const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sym",
            "found_func->name",
            "KSYM_NAME_LEN"
          ],
          "line": 5915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "mod_func",
            "&mod_map->funcs",
            "list"
          ],
          "line": 5901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic const char *\nftrace_func_address_lookup(struct ftrace_mod_map *mod_map,\n\t\t\t   unsigned long addr, unsigned long *size,\n\t\t\t   unsigned long *off, char *sym)\n{\n\tstruct ftrace_mod_func *found_func =  NULL;\n\tstruct ftrace_mod_func *mod_func;\n\n\tlist_for_each_entry_rcu(mod_func, &mod_map->funcs, list) {\n\t\tif (addr >= mod_func->ip &&\n\t\t    addr < mod_func->ip + mod_func->size) {\n\t\t\tfound_func = mod_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_func) {\n\t\tif (size)\n\t\t\t*size = found_func->size;\n\t\tif (off)\n\t\t\t*off = addr - found_func->ip;\n\t\tif (sym)\n\t\t\tstrlcpy(sym, found_func->name, KSYM_NAME_LEN);\n\n\t\treturn found_func->name;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "allocate_ftrace_mod_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5871-5891",
    "snippet": "static struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct ftrace_mod_map *mod_map;\n\n\tmod_map = kmalloc(sizeof(*mod_map), GFP_KERNEL);\n\tif (!mod_map)\n\t\treturn NULL;\n\n\tmod_map->mod = mod;\n\tmod_map->start_addr = start;\n\tmod_map->end_addr = end;\n\tmod_map->num_funcs = 0;\n\n\tINIT_LIST_HEAD_RCU(&mod_map->funcs);\n\n\tlist_add_rcu(&mod_map->list, &ftrace_mod_maps);\n\n\treturn mod_map;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&mod_map->list",
            "&ftrace_mod_maps"
          ],
          "line": 5888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD_RCU",
          "args": [
            "&mod_map->funcs"
          ],
          "line": 5886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*mod_map)",
            "GFP_KERNEL"
          ],
          "line": 5877
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_mod_map *\nallocate_ftrace_mod_map(struct module *mod,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct ftrace_mod_map *mod_map;\n\n\tmod_map = kmalloc(sizeof(*mod_map), GFP_KERNEL);\n\tif (!mod_map)\n\t\treturn NULL;\n\n\tmod_map->mod = mod;\n\tmod_map->start_addr = start;\n\tmod_map->end_addr = end;\n\tmod_map->num_funcs = 0;\n\n\tINIT_LIST_HEAD_RCU(&mod_map->funcs);\n\n\tlist_add_rcu(&mod_map->list, &ftrace_mod_maps);\n\n\treturn mod_map;\n}"
  },
  {
    "function_name": "save_ftrace_mod_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5839-5869",
    "snippet": "static void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tstruct ftrace_mod_func *mod_func;\n\tunsigned long symsize;\n\tunsigned long offset;\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\tconst char *ret;\n\n\tret = kallsyms_lookup(rec->ip, &symsize, &offset, &modname, str);\n\tif (!ret)\n\t\treturn;\n\n\tmod_func = kmalloc(sizeof(*mod_func), GFP_KERNEL);\n\tif (!mod_func)\n\t\treturn;\n\n\tmod_func->name = kstrdup(str, GFP_KERNEL);\n\tif (!mod_func->name) {\n\t\tkfree(mod_func);\n\t\treturn;\n\t}\n\n\tmod_func->ip = rec->ip - offset;\n\tmod_func->size = symsize;\n\n\tmod_map->num_funcs++;\n\n\tlist_add_rcu(&mod_func->list, &mod_map->funcs);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&mod_func->list",
            "&mod_map->funcs"
          ],
          "line": 5868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mod_func"
          ],
          "line": 5859
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 5857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*mod_func)",
            "GFP_KERNEL"
          ],
          "line": 5853
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "rec->ip",
            "&symsize",
            "&offset",
            "&modname",
            "str"
          ],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void save_ftrace_mod_rec(struct ftrace_mod_map *mod_map,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tstruct ftrace_mod_func *mod_func;\n\tunsigned long symsize;\n\tunsigned long offset;\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\tconst char *ret;\n\n\tret = kallsyms_lookup(rec->ip, &symsize, &offset, &modname, str);\n\tif (!ret)\n\t\treturn;\n\n\tmod_func = kmalloc(sizeof(*mod_func), GFP_KERNEL);\n\tif (!mod_func)\n\t\treturn;\n\n\tmod_func->name = kstrdup(str, GFP_KERNEL);\n\tif (!mod_func->name) {\n\t\tkfree(mod_func);\n\t\treturn;\n\t}\n\n\tmod_func->ip = rec->ip - offset;\n\tmod_func->size = symsize;\n\n\tmod_map->num_funcs++;\n\n\tlist_add_rcu(&mod_func->list, &mod_map->funcs);\n}"
  },
  {
    "function_name": "ftrace_module_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5830-5837",
    "snippet": "void ftrace_module_init(struct module *mod)\n{\n\tif (ftrace_disabled || !mod->num_ftrace_callsites)\n\t\treturn;\n\n\tftrace_process_locs(mod, mod->ftrace_callsites,\n\t\t\t    mod->ftrace_callsites + mod->num_ftrace_callsites);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_process_locs",
          "args": [
            "mod",
            "mod->ftrace_callsites",
            "mod->ftrace_callsites + mod->num_ftrace_callsites"
          ],
          "line": 5835
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_locs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5501-5598",
          "snippet": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, NULL);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, NULL);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid ftrace_module_init(struct module *mod)\n{\n\tif (ftrace_disabled || !mod->num_ftrace_callsites)\n\t\treturn;\n\n\tftrace_process_locs(mod, mod->ftrace_callsites,\n\t\t\t    mod->ftrace_callsites + mod->num_ftrace_callsites);\n}"
  },
  {
    "function_name": "ftrace_module_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5758-5828",
    "snippet": "void ftrace_module_enable(struct module *mod)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the tracing is enabled, go ahead and enable the record.\n\t *\n\t * The reason not to enable the record immediatelly is the\n\t * inherent check of ftrace_make_nop/ftrace_make_call for\n\t * correct previous instructions.  Making first the NOP\n\t * conversion puts the module to the correct state, thus\n\t * passing the ftrace_make_call check.\n\t *\n\t * We also delay this to after the module code already set the\n\t * text to read-only, as we now need to set it back to read-write\n\t * so that we can modify the text.\n\t */\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_prepare();\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint cnt;\n\t\t/*\n\t\t * do_for_each_ftrace_rec() is a double loop.\n\t\t * module text shares the pg. If a record is\n\t\t * not part of this module, then skip this pg,\n\t\t * which the \"break\" will do.\n\t\t */\n\t\tif (!within_module_core(rec->ip, mod) &&\n\t\t    !within_module_init(rec->ip, mod))\n\t\t\tbreak;\n\n\t\tcnt = 0;\n\n\t\t/*\n\t\t * When adding a module, we need to check if tracers are\n\t\t * currently enabled and if they are, and can trace this record,\n\t\t * we need to enable the module functions as well as update the\n\t\t * reference counts for those function records.\n\t\t */\n\t\tif (ftrace_start_up)\n\t\t\tcnt += referenced_filters(rec);\n\n\t\t/* This clears FTRACE_FL_DISABLED */\n\t\trec->flags = cnt;\n\n\t\tif (ftrace_start_up && cnt) {\n\t\t\tint failed = __ftrace_replace_code(rec, 1);\n\t\t\tif (failed) {\n\t\t\t\tftrace_bug(failed, rec);\n\t\t\t\tgoto out_loop;\n\t\t\t}\n\t\t}\n\n\t} while_for_each_ftrace_rec();\n\n out_loop:\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_post_process();\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tprocess_cached_mods(mod->name);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_cached_mods",
          "args": [
            "mod->name"
          ],
          "line": 5827
        },
        "resolved": true,
        "details": {
          "function_name": "process_cached_mods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3998-4017",
          "snippet": "static void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5825
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_post_process",
          "args": [],
          "line": 5822
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_post_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2543-2546",
          "snippet": "int __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "failed",
            "rec"
          ],
          "line": 5813
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2018-2072",
          "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_replace_code",
          "args": [
            "rec",
            "1"
          ],
          "line": 5811
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_replace_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2382-2416",
          "snippet": "static int\n__ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknow ftrace bug */\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\n__ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknow ftrace bug */\n}"
        }
      },
      {
        "call_info": {
          "callee": "referenced_filters",
          "args": [
            "rec"
          ],
          "line": 5805
        },
        "resolved": true,
        "details": {
          "function_name": "referenced_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5623-5634",
          "snippet": "static int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec))\n\t\t    cnt++;\n\t}\n\n\treturn cnt;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec))\n\t\t    cnt++;\n\t}\n\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 5793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 5784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_prepare",
          "args": [],
          "line": 5782
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2534-2537",
          "snippet": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5763
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid ftrace_module_enable(struct module *mod)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the tracing is enabled, go ahead and enable the record.\n\t *\n\t * The reason not to enable the record immediatelly is the\n\t * inherent check of ftrace_make_nop/ftrace_make_call for\n\t * correct previous instructions.  Making first the NOP\n\t * conversion puts the module to the correct state, thus\n\t * passing the ftrace_make_call check.\n\t *\n\t * We also delay this to after the module code already set the\n\t * text to read-only, as we now need to set it back to read-write\n\t * so that we can modify the text.\n\t */\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_prepare();\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint cnt;\n\t\t/*\n\t\t * do_for_each_ftrace_rec() is a double loop.\n\t\t * module text shares the pg. If a record is\n\t\t * not part of this module, then skip this pg,\n\t\t * which the \"break\" will do.\n\t\t */\n\t\tif (!within_module_core(rec->ip, mod) &&\n\t\t    !within_module_init(rec->ip, mod))\n\t\t\tbreak;\n\n\t\tcnt = 0;\n\n\t\t/*\n\t\t * When adding a module, we need to check if tracers are\n\t\t * currently enabled and if they are, and can trace this record,\n\t\t * we need to enable the module functions as well as update the\n\t\t * reference counts for those function records.\n\t\t */\n\t\tif (ftrace_start_up)\n\t\t\tcnt += referenced_filters(rec);\n\n\t\t/* This clears FTRACE_FL_DISABLED */\n\t\trec->flags = cnt;\n\n\t\tif (ftrace_start_up && cnt) {\n\t\t\tint failed = __ftrace_replace_code(rec, 1);\n\t\t\tif (failed) {\n\t\t\t\tftrace_bug(failed, rec);\n\t\t\t\tgoto out_loop;\n\t\t\t}\n\t\t}\n\n\t} while_for_each_ftrace_rec();\n\n out_loop:\n\tif (ftrace_start_up)\n\t\tftrace_arch_code_modify_post_process();\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tprocess_cached_mods(mod->name);\n}"
  },
  {
    "function_name": "ftrace_release_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5692-5756",
    "snippet": "void ftrace_release_mod(struct module *mod)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_map *n;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *tmp_page = NULL;\n\tstruct ftrace_page *pg;\n\tint order;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {\n\t\tif (mod_map->mod == mod) {\n\t\t\tlist_del_rcu(&mod_map->list);\n\t\t\tcall_rcu_sched(&mod_map->rcu, ftrace_free_mod_map);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Each module has its own ftrace_pages, remove\n\t * them from the list.\n\t */\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module_core(rec->ip, mod) ||\n\t\t    within_module_init(rec->ip, mod)) {\n\t\t\t/*\n\t\t\t * As core pages are first, the first\n\t\t\t * page should never be a module page.\n\t\t\t */\n\t\t\tif (WARN_ON(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t/* Check if we are deleting the last page */\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\tftrace_update_tot_cnt -= pg->index;\n\t\t\t*last_pg = pg->next;\n\n\t\t\tpg->next = tmp_page;\n\t\t\ttmp_page = pg;\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tfor (pg = tmp_page; pg; pg = tmp_page) {\n\n\t\t/* Needs to be called outside of ftrace_lock */\n\t\tclear_mod_from_hashes(pg);\n\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\ttmp_page = pg->next;\n\t\tkfree(pg);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
    ],
    "globals_used": [
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pg"
          ],
          "line": 5754
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)pg->records",
            "order"
          ],
          "line": 5752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count_order",
          "args": [
            "pg->size / ENTRIES_PER_PAGE"
          ],
          "line": 5751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_mod_from_hashes",
          "args": [
            "pg"
          ],
          "line": 5749
        },
        "resolved": true,
        "details": {
          "function_name": "clear_mod_from_hashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5660-5674",
          "snippet": "static void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5744
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_to_ftrace_page",
          "args": [
            "last_pg"
          ],
          "line": 5733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pg == ftrace_pages_start"
          ],
          "line": 5728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 5723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "rec->ip",
            "mod"
          ],
          "line": 5722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&mod_map->rcu",
            "ftrace_free_mod_map"
          ],
          "line": 5710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&mod_map->list"
          ],
          "line": 5709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mod_map",
            "n",
            "&ftrace_mod_maps",
            "list"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5702
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid ftrace_release_mod(struct module *mod)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_map *n;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *tmp_page = NULL;\n\tstruct ftrace_page *pg;\n\tint order;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {\n\t\tif (mod_map->mod == mod) {\n\t\t\tlist_del_rcu(&mod_map->list);\n\t\t\tcall_rcu_sched(&mod_map->rcu, ftrace_free_mod_map);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Each module has its own ftrace_pages, remove\n\t * them from the list.\n\t */\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module_core(rec->ip, mod) ||\n\t\t    within_module_init(rec->ip, mod)) {\n\t\t\t/*\n\t\t\t * As core pages are first, the first\n\t\t\t * page should never be a module page.\n\t\t\t */\n\t\t\tif (WARN_ON(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t/* Check if we are deleting the last page */\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\tftrace_update_tot_cnt -= pg->index;\n\t\t\t*last_pg = pg->next;\n\n\t\t\tpg->next = tmp_page;\n\t\t\ttmp_page = pg;\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tfor (pg = tmp_page; pg; pg = tmp_page) {\n\n\t\t/* Needs to be called outside of ftrace_lock */\n\t\tclear_mod_from_hashes(pg);\n\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\ttmp_page = pg->next;\n\t\tkfree(pg);\n\t}\n}"
  },
  {
    "function_name": "ftrace_free_mod_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5676-5690",
    "snippet": "static void ftrace_free_mod_map(struct rcu_head *rcu)\n{\n\tstruct ftrace_mod_map *mod_map = container_of(rcu, struct ftrace_mod_map, rcu);\n\tstruct ftrace_mod_func *mod_func;\n\tstruct ftrace_mod_func *n;\n\n\t/* All the contents of mod_map are now not visible to readers */\n\tlist_for_each_entry_safe(mod_func, n, &mod_map->funcs, list) {\n\t\tkfree(mod_func->name);\n\t\tlist_del(&mod_func->list);\n\t\tkfree(mod_func);\n\t}\n\n\tkfree(mod_map);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mod_map"
          ],
          "line": 5689
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mod_func->list"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mod_func",
            "n",
            "&mod_map->funcs",
            "list"
          ],
          "line": 5683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structftrace_mod_map",
            "rcu"
          ],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_free_mod_map(struct rcu_head *rcu)\n{\n\tstruct ftrace_mod_map *mod_map = container_of(rcu, struct ftrace_mod_map, rcu);\n\tstruct ftrace_mod_func *mod_func;\n\tstruct ftrace_mod_func *n;\n\n\t/* All the contents of mod_map are now not visible to readers */\n\tlist_for_each_entry_safe(mod_func, n, &mod_map->funcs, list) {\n\t\tkfree(mod_func->name);\n\t\tlist_del(&mod_func->list);\n\t\tkfree(mod_func);\n\t}\n\n\tkfree(mod_map);\n}"
  },
  {
    "function_name": "clear_mod_from_hashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5660-5674",
    "snippet": "static void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 5673
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_mod_from_hash",
          "args": [
            "pg",
            "tr->ops->func_hash->notrace_hash"
          ],
          "line": 5670
        },
        "resolved": true,
        "details": {
          "function_name": "clear_mod_from_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5636-5657",
          "snippet": "static void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tr->ops->func_hash->regex_lock"
          ],
          "line": 5668
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void clear_mod_from_hashes(struct ftrace_page *pg)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->ops || !tr->ops->func_hash)\n\t\t\tcontinue;\n\t\tmutex_lock(&tr->ops->func_hash->regex_lock);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->filter_hash);\n\t\tclear_mod_from_hash(pg, tr->ops->func_hash->notrace_hash);\n\t\tmutex_unlock(&tr->ops->func_hash->regex_lock);\n\t}\n\tmutex_unlock(&trace_types_lock);\n}"
  },
  {
    "function_name": "clear_mod_from_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5636-5657",
    "snippet": "static void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 5648
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1148-1163",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 5643
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nclear_mod_from_hash(struct ftrace_page *pg, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct dyn_ftrace *rec;\n\tint i;\n\n\tif (ftrace_hash_empty(hash))\n\t\treturn;\n\n\tfor (i = 0; i < pg->index; i++) {\n\t\trec = &pg->records[i];\n\t\tentry = __ftrace_lookup_ip(hash, rec->ip);\n\t\t/*\n\t\t * Do not allow this rec to match again.\n\t\t * Yeah, it may waste some memory, but will be removed\n\t\t * if/when the hash is modified again.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->ip = 0;\n\t}\n}"
  },
  {
    "function_name": "referenced_filters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5623-5634",
    "snippet": "static int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec))\n\t\t    cnt++;\n\t}\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops_references_rec",
          "args": [
            "ops",
            "rec"
          ],
          "line": 5629
        },
        "resolved": true,
        "details": {
          "function_name": "ops_references_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2895-2916",
          "snippet": "static inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int referenced_filters(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tint cnt = 0;\n\n\tfor (ops = ftrace_ops_list; ops != &ftrace_list_end; ops = ops->next) {\n\t\tif (ops_references_rec(ops, rec))\n\t\t    cnt++;\n\t}\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "ftrace_process_locs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5501-5598",
    "snippet": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, NULL);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5595
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_code",
          "args": [
            "mod",
            "start_pg"
          ],
          "line": 5590
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2918-2972",
          "snippet": "static int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n#ifndef CC_USING_NOP_MCOUNT\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (!ftrace_code_disable(mod, p))\n\t\t\t\tbreak;\n#endif\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n#ifndef CC_USING_NOP_MCOUNT\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (!ftrace_code_disable(mod, p))\n\t\t\t\tbreak;\n#endif\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pg->next"
          ],
          "line": 5575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pg->next"
          ],
          "line": 5565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_call_adjust",
          "args": [
            "*p++"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_pages->next"
          ],
          "line": 5541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_pages || ftrace_pages_start"
          ],
          "line": 5534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5526
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_allocate_pages",
          "args": [
            "count"
          ],
          "line": 5522
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_allocate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3011-3060",
          "snippet": "static struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn 0;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nstatic struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn 0;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "start",
            "count",
            "sizeof(*start)",
            "ftrace_cmp_ips",
            "NULL"
          ],
          "line": 5519
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, NULL);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t/* We should have used all pages */\n\tWARN_ON(pg->next);\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_cmp_ips",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5489-5499",
    "snippet": "static int ftrace_cmp_ips(const void *a, const void *b)\n{\n\tconst unsigned long *ipa = a;\n\tconst unsigned long *ipb = b;\n\n\tif (*ipa > *ipb)\n\t\treturn 1;\n\tif (*ipa < *ipb)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_cmp_ips(const void *a, const void *b)\n{\n\tconst unsigned long *ipa = a;\n\tconst unsigned long *ipb = b;\n\n\tif (*ipa > *ipb)\n\t\treturn 1;\n\tif (*ipa < *ipb)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_init_dyn_tracefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5466-5487",
    "snippet": "static __init int ftrace_init_dyn_tracefs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"available_filter_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_avail_fops);\n\n\ttrace_create_file(\"enabled_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_enabled_fops);\n\n\tftrace_create_filter_files(&global_ops, d_tracer);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\ttrace_create_file(\"set_graph_function\", 0644, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_fops);\n\ttrace_create_file(\"set_graph_notrace\", 0644, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_notrace_fops);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"set_graph_notrace\"",
            "0644",
            "d_tracer",
            "NULL",
            "&ftrace_graph_notrace_fops"
          ],
          "line": 5481
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_create_filter_files",
          "args": [
            "&global_ops",
            "d_tracer"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_create_filter_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5436-5445",
          "snippet": "void ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nstatic __init int ftrace_init_dyn_tracefs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"available_filter_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_avail_fops);\n\n\ttrace_create_file(\"enabled_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_enabled_fops);\n\n\tftrace_create_filter_files(&global_ops, d_tracer);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\ttrace_create_file(\"set_graph_function\", 0644, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_fops);\n\ttrace_create_file(\"set_graph_notrace\", 0644, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_notrace_fops);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_destroy_filter_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5457-5464",
    "snippet": "void ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5463
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "ops",
            "0"
          ],
          "line": 5461
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2727-2839",
          "snippet": "static int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5459
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= FTRACE_OPS_FL_DELETED;\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "ftrace_create_filter_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5436-5445",
    "snippet": "void ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"set_ftrace_notrace\"",
            "0644",
            "parent",
            "ops",
            "&ftrace_notrace_fops"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}"
  },
  {
    "function_name": "ftrace_graph_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5384-5417",
    "snippet": "static ssize_t\nftrace_graph_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tssize_t read, ret = 0;\n\tstruct ftrace_graph_data *fgd = file->private_data;\n\tstruct trace_parser *parser;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\t/* Read mode uses seq functions */\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tfgd = m->private;\n\t}\n\n\tparser = &fgd->parser;\n\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\n\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t    parser->buffer);\n\t\ttrace_parser_clear(parser);\n\t}\n\n\tif (!ret)\n\t\tret = read;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_clear",
          "args": [
            "parser"
          ],
          "line": 5410
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1068-1072",
          "snippet": "static inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_set_hash",
          "args": [
            "fgd->new_hash",
            "parser->buffer"
          ],
          "line": 5408
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5329-5382",
          "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_cont",
          "args": [
            "parser"
          ],
          "line": 5406
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_cont",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1063-1066",
          "snippet": "static inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "parser"
          ],
          "line": 5405
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1058-1061",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_user",
          "args": [
            "parser",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 5403
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1216-1291",
          "snippet": "int trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_graph_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tssize_t read, ret = 0;\n\tstruct ftrace_graph_data *fgd = file->private_data;\n\tstruct trace_parser *parser;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\t/* Read mode uses seq functions */\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tfgd = m->private;\n\t}\n\n\tparser = &fgd->parser;\n\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\n\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t    parser->buffer);\n\t\ttrace_parser_clear(parser);\n\t}\n\n\tif (!ret)\n\t\tret = read;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_set_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5329-5382",
    "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 5369
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1210-1217",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1196-1208",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 5358
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_record",
          "args": [
            "rec",
            "&func_g",
            "NULL",
            "0"
          ],
          "line": 5357
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3717-3753",
          "snippet": "static int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 5352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 5347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 5345
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_g.search"
          ],
          "line": 5343
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "buffer",
            "strlen(buffer)",
            "&func_g.search",
            "&not"
          ],
          "line": 5340
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "810-846",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_graph_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5267-5327",
    "snippet": "static int\nftrace_graph_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tstruct ftrace_hash *old_hash, *new_hash;\n\tstruct trace_parser *parser;\n\tint ret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tfgd = m->private;\n\t\tseq_release(inode, file);\n\t} else {\n\t\tfgd = file->private_data;\n\t}\n\n\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tparser = &fgd->parser;\n\n\t\tif (trace_parser_loaded((parser))) {\n\t\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t\t    parser->buffer);\n\t\t}\n\n\t\ttrace_parser_put(parser);\n\n\t\tnew_hash = __ftrace_hash_move(fgd->new_hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_lock(&graph_lock);\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION) {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_hash, new_hash);\n\t\t} else {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_notrace_hash, new_hash);\n\t\t}\n\n\t\tmutex_unlock(&graph_lock);\n\n\t\t/* Wait till all users are no longer using the old hash */\n\t\tsynchronize_sched();\n\n\t\tfree_ftrace_hash(old_hash);\n\t}\n\n out:\n\tfree_ftrace_hash(fgd->new_hash);\n\tkfree(fgd);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fgd"
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "fgd->new_hash"
          ],
          "line": 5323
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 5317
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ftrace_graph_notrace_hash",
            "new_hash"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_notrace_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ftrace_graph_hash",
            "new_hash"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 5302
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_hash_move",
          "args": [
            "fgd->new_hash"
          ],
          "line": 5296
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1396-1439",
          "snippet": "static struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_node *tn;\n\tstruct hlist_head *hhd;\n\tstruct ftrace_hash *new_hash;\n\tint size = src->count;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\t/*\n\t * Make the hash size about 1/2 the # found\n\t */\n\tfor (size /= 2; size; size >>= 1)\n\t\tbits++;\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\n\treturn new_hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)",
            "#define FTRACE_HASH_MAX_BITS 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n#define FTRACE_HASH_MAX_BITS 12\n\nstatic struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_node *tn;\n\tstruct hlist_head *hhd;\n\tstruct ftrace_hash *new_hash;\n\tint size = src->count;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\t/*\n\t * Make the hash size about 1/2 the # found\n\t */\n\tfor (size /= 2; size; size >>= 1)\n\t\tbits++;\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\n\treturn new_hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "parser"
          ],
          "line": 5294
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1199-1203",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_set_hash",
          "args": [
            "fgd->new_hash",
            "parser->buffer"
          ],
          "line": 5290
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5329-5382",
          "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "(parser)"
          ],
          "line": 5289
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1058-1061",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 5279
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "219-233",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_graph_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tstruct ftrace_hash *old_hash, *new_hash;\n\tstruct trace_parser *parser;\n\tint ret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tfgd = m->private;\n\t\tseq_release(inode, file);\n\t} else {\n\t\tfgd = file->private_data;\n\t}\n\n\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tparser = &fgd->parser;\n\n\t\tif (trace_parser_loaded((parser))) {\n\t\t\tret = ftrace_graph_set_hash(fgd->new_hash,\n\t\t\t\t\t\t    parser->buffer);\n\t\t}\n\n\t\ttrace_parser_put(parser);\n\n\t\tnew_hash = __ftrace_hash_move(fgd->new_hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_lock(&graph_lock);\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION) {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_hash, new_hash);\n\t\t} else {\n\t\t\told_hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\t\t\trcu_assign_pointer(ftrace_graph_notrace_hash, new_hash);\n\t\t}\n\n\t\tmutex_unlock(&graph_lock);\n\n\t\t/* Wait till all users are no longer using the old hash */\n\t\tsynchronize_sched();\n\n\t\tfree_ftrace_hash(old_hash);\n\t}\n\n out:\n\tfree_ftrace_hash(fgd->new_hash);\n\tkfree(fgd);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_notrace_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5239-5265",
    "snippet": "static int\nftrace_graph_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_NOTRACE;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 5263
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fgd"
          ],
          "line": 5261
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_graph_open",
          "args": [
            "inode",
            "file",
            "fgd"
          ],
          "line": 5259
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_graph_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5158-5209",
          "snippet": "static int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_notrace_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 5252
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fgd)",
            "GFP_KERNEL"
          ],
          "line": 5248
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_NOTRACE;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5211-5237",
    "snippet": "static int\nftrace_graph_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_FUNCTION;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 5235
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fgd"
          ],
          "line": 5233
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_graph_open",
          "args": [
            "inode",
            "file",
            "fgd"
          ],
          "line": 5231
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_graph_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5158-5209",
          "snippet": "static int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fgd)",
            "GFP_KERNEL"
          ],
          "line": 5220
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_graph_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tfgd = kmalloc(sizeof(*fgd), GFP_KERNEL);\n\tif (fgd == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&graph_lock);\n\n\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\tfgd->type = GRAPH_FILTER_FUNCTION;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\tret = __ftrace_graph_open(inode, file, fgd);\n\tif (ret < 0)\n\t\tkfree(fgd);\n\n\tmutex_unlock(&graph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_graph_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5158-5209",
    "snippet": "static int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "&fgd->parser"
          ],
          "line": 5197
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1199-1203",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ftrace_graph_seq_ops"
          ],
          "line": 5183
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "size_bits",
            "fgd->hash"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1350-1386",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "size_bits"
          ],
          "line": 5172
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_get_init",
          "args": [
            "&fgd->parser",
            "FTRACE_BUFF_MAX"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_get_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1184-1194",
          "snippet": "int trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\tstruct ftrace_hash *new_hash = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (trace_parser_get_init(&fgd->parser, FTRACE_BUFF_MAX))\n\t\t\treturn -ENOMEM;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\tnew_hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\tnew_hash = alloc_and_copy_ftrace_hash(size_bits,\n\t\t\t\t\t\t\t      fgd->hash);\n\t\tif (!new_hash) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &ftrace_graph_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\tnew_hash = NULL;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\nout:\n\tif (ret < 0 && file->f_mode & FMODE_WRITE)\n\t\ttrace_parser_put(&fgd->parser);\n\n\tfgd->new_hash = new_hash;\n\n\t/*\n\t * All uses of fgd->hash must be taken with the graph_lock\n\t * held. The graph_lock is going to be released, so force\n\t * fgd->hash to be reinitialized when it is taken again.\n\t */\n\tfgd->hash = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "g_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5129-5149",
    "snippet": "static int g_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_func_entry *entry = v;\n\n\tif (!entry)\n\t\treturn 0;\n\n\tif (entry == FTRACE_GRAPH_EMPTY) {\n\t\tstruct ftrace_graph_data *fgd = m->private;\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%ps\\n\", (void *)entry->ip);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_GRAPH_EMPTY\t((void *)1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%ps\\n\"",
            "(void *)entry->ip"
          ],
          "line": 5146
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#### no functions disabled ####\\n\""
          ],
          "line": 5142
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_GRAPH_EMPTY\t((void *)1)\n\nstatic int g_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_func_entry *entry = v;\n\n\tif (!entry)\n\t\treturn 0;\n\n\tif (entry == FTRACE_GRAPH_EMPTY) {\n\t\tstruct ftrace_graph_data *fgd = m->private;\n\n\t\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%ps\\n\", (void *)entry->ip);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "g_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5124-5127",
    "snippet": "static void g_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&graph_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&graph_lock"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void g_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&graph_lock);\n}"
  },
  {
    "function_name": "g_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5102-5122",
    "snippet": "static void *g_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tmutex_lock(&graph_lock);\n\n\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\telse\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\n\t/* Nothing, tell g_show to print all functions are enabled */\n\tif (ftrace_hash_empty(fgd->hash) && !*pos)\n\t\treturn FTRACE_GRAPH_EMPTY;\n\n\tfgd->idx = 0;\n\tfgd->entry = NULL;\n\treturn __g_next(m, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_GRAPH_EMPTY\t((void *)1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__g_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 5121
        },
        "resolved": true,
        "details": {
          "function_name": "__g_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5064-5093",
          "snippet": "static void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "fgd->hash"
          ],
          "line": 5116
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_notrace_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_graph_hash",
            "lockdep_is_held(&graph_lock)"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&graph_lock"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&graph_lock"
          ],
          "line": 5106
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_GRAPH_EMPTY\t((void *)1)\n\nstatic void *g_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tmutex_lock(&graph_lock);\n\n\tif (fgd->type == GRAPH_FILTER_FUNCTION)\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\telse\n\t\tfgd->hash = rcu_dereference_protected(ftrace_graph_notrace_hash,\n\t\t\t\t\tlockdep_is_held(&graph_lock));\n\n\t/* Nothing, tell g_show to print all functions are enabled */\n\tif (ftrace_hash_empty(fgd->hash) && !*pos)\n\t\treturn FTRACE_GRAPH_EMPTY;\n\n\tfgd->idx = 0;\n\tfgd->entry = NULL;\n\treturn __g_next(m, pos);\n}"
  },
  {
    "function_name": "g_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5095-5100",
    "snippet": "static void *\ng_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__g_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 5099
        },
        "resolved": true,
        "details": {
          "function_name": "__g_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5064-5093",
          "snippet": "static void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\ng_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}"
  },
  {
    "function_name": "__g_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "5064-5093",
    "snippet": "static void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "head",
            "hlist"
          ],
          "line": 5086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_continue",
          "args": [
            "entry",
            "hlist"
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\tstruct ftrace_func_entry *entry = fgd->entry;\n\tstruct hlist_head *head;\n\tint i, idx = fgd->idx;\n\n\tif (*pos >= fgd->hash->count)\n\t\treturn NULL;\n\n\tif (entry) {\n\t\thlist_for_each_entry_continue(entry, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\treturn entry;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tfor (i = idx; i < 1 << fgd->hash->size_bits; i++) {\n\t\thead = &fgd->hash->buckets[i];\n\t\thlist_for_each_entry(entry, head, hlist) {\n\t\t\tfgd->entry = entry;\n\t\t\tfgd->idx = i;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_regex_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4960-5008",
    "snippet": "int ftrace_regex_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash **orig_hash;\n\tstruct trace_parser *parser;\n\tint filter_hash;\n\tint ret;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer = m->private;\n\t\tseq_release(inode, file);\n\t} else\n\t\titer = file->private_data;\n\n\tparser = &iter->parser;\n\tif (trace_parser_loaded(parser)) {\n\t\tftrace_match_records(iter->hash, parser->buffer, parser->idx);\n\t}\n\n\ttrace_parser_put(parser);\n\n\tmutex_lock(&iter->ops->func_hash->regex_lock);\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tfilter_hash = !!(iter->flags & FTRACE_ITER_FILTER);\n\n\t\tif (filter_hash) {\n\t\t\torig_hash = &iter->ops->func_hash->filter_hash;\n\t\t\tif (iter->tr && !list_empty(&iter->tr->mod_trace))\n\t\t\t\titer->hash->flags |= FTRACE_HASH_FL_MOD;\n\t\t} else\n\t\t\torig_hash = &iter->ops->func_hash->notrace_hash;\n\n\t\tmutex_lock(&ftrace_lock);\n\t\tret = ftrace_hash_move_and_update_ops(iter->ops, orig_hash,\n\t\t\t\t\t\t      iter->hash, filter_hash);\n\t\tmutex_unlock(&ftrace_lock);\n\t} else {\n\t\t/* For read only, the hash is the ops hash */\n\t\titer->hash = NULL;\n\t}\n\n\tmutex_unlock(&iter->ops->func_hash->regex_lock);\n\tfree_ftrace_hash(iter->hash);\n\tkfree(iter);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "iter->hash"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&iter->ops->func_hash->regex_lock"
          ],
          "line": 5003
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "iter->ops",
            "orig_hash",
            "iter->hash",
            "filter_hash"
          ],
          "line": 4995
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3842-3860",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4994
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&iter->tr->mod_trace"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "parser"
          ],
          "line": 4980
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1199-1203",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "iter->hash",
            "parser->buffer",
            "parser->idx"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3805-3809",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "parser"
          ],
          "line": 4976
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1058-1061",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 4971
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "219-233",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_regex_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash **orig_hash;\n\tstruct trace_parser *parser;\n\tint filter_hash;\n\tint ret;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer = m->private;\n\t\tseq_release(inode, file);\n\t} else\n\t\titer = file->private_data;\n\n\tparser = &iter->parser;\n\tif (trace_parser_loaded(parser)) {\n\t\tftrace_match_records(iter->hash, parser->buffer, parser->idx);\n\t}\n\n\ttrace_parser_put(parser);\n\n\tmutex_lock(&iter->ops->func_hash->regex_lock);\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tfilter_hash = !!(iter->flags & FTRACE_ITER_FILTER);\n\n\t\tif (filter_hash) {\n\t\t\torig_hash = &iter->ops->func_hash->filter_hash;\n\t\t\tif (iter->tr && !list_empty(&iter->tr->mod_trace))\n\t\t\t\titer->hash->flags |= FTRACE_HASH_FL_MOD;\n\t\t} else\n\t\t\torig_hash = &iter->ops->func_hash->notrace_hash;\n\n\t\tmutex_lock(&ftrace_lock);\n\t\tret = ftrace_hash_move_and_update_ops(iter->ops, orig_hash,\n\t\t\t\t\t\t      iter->hash, filter_hash);\n\t\tmutex_unlock(&ftrace_lock);\n\t} else {\n\t\t/* For read only, the hash is the ops hash */\n\t\titer->hash = NULL;\n\t}\n\n\tmutex_unlock(&iter->ops->func_hash->regex_lock);\n\tfree_ftrace_hash(iter->hash);\n\tkfree(iter);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_ftrace_early_filters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4946-4958",
    "snippet": "static void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ftrace_early_graph",
          "args": [
            "ftrace_graph_notrace_buf",
            "0"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "set_ftrace_early_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4907-4930",
          "snippet": "static void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (WARN_ON(!hash))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (WARN_ON(!hash))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_early_filter",
          "args": [
            "&global_ops",
            "ftrace_notrace_buf",
            "0"
          ],
          "line": 4951
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_early_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4933-4944",
          "snippet": "void __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nstatic void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}"
  },
  {
    "function_name": "ftrace_set_early_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4933-4944",
    "snippet": "void __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "ops",
            "func",
            "strlen(func)",
            "0",
            "enable"
          ],
          "line": 4942
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4779-4784",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func"
          ],
          "line": 4942
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 4941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}"
  },
  {
    "function_name": "set_ftrace_early_graph",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4907-4930",
    "snippet": "static void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (WARN_ON(!hash))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\"",
            "func"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_set_hash",
          "args": [
            "hash",
            "func"
          ],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "5329-5382",
          "snippet": "static int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nftrace_graph_set_hash(struct ftrace_hash *hash, char *buffer)\n{\n\tstruct ftrace_glob func_g;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tstruct ftrace_func_entry *entry;\n\tint fail = 1;\n\tint not;\n\n\t/* decode regex */\n\tfunc_g.type = filter_parse_regex(buffer, strlen(buffer),\n\t\t\t\t\t &func_g.search, &not);\n\n\tfunc_g.len = strlen(func_g.search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, NULL, 0)) {\n\t\t\tentry = ftrace_lookup_ip(hash, rec->ip);\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\n\t\t\t\tif (entry)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (add_hash_entry(hash, rec->ip) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (entry) {\n\t\t\t\t\tfree_hash_entry(hash, entry);\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 4918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!hash"
          ],
          "line": 4914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS"
          ],
          "line": 4913
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tstruct ftrace_hash *hash;\n\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\tif (WARN_ON(!hash))\n\t\treturn;\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\t/* we allow only one expression at a time */\n\t\tret = ftrace_graph_set_hash(hash, func);\n\t\tif (ret)\n\t\t\tprintk(KERN_DEBUG \"ftrace: function %s not \"\n\t\t\t\t\t  \"traceable\\n\", func);\n\t}\n\n\tif (enable)\n\t\tftrace_graph_hash = hash;\n\telse\n\t\tftrace_graph_notrace_hash = hash;\n}"
  },
  {
    "function_name": "set_graph_max_depth_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4898-4904",
    "snippet": "static int __init set_graph_max_depth_function(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tfgraph_max_depth = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 4902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int __init set_graph_max_depth_function(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tfgraph_max_depth = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_graph_notrace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4891-4895",
    "snippet": "static int __init set_graph_notrace_function(char *str)\n{\n\tstrlcpy(ftrace_graph_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_graph_notrace_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 4893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_graph_notrace_function(char *str)\n{\n\tstrlcpy(ftrace_graph_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_graph_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4884-4888",
    "snippet": "static int __init set_graph_function(char *str)\n{\n\tstrlcpy(ftrace_graph_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_graph_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_graph_function(char *str)\n{\n\tstrlcpy(ftrace_graph_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_ftrace_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4871-4876",
    "snippet": "static int __init set_ftrace_filter(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_filter_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_filter_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_ftrace_filter(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_filter_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_ftrace_notrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4863-4868",
    "snippet": "static int __init set_ftrace_notrace(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ftrace_notrace_buf",
            "str",
            "FTRACE_FILTER_SIZE"
          ],
          "line": 4866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_FILTER_SIZE\t\tCOMMAND_LINE_SIZE\n\nstatic int __init set_ftrace_notrace(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_notrace_buf, str, FTRACE_FILTER_SIZE);\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_set_global_notrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4847-4850",
    "snippet": "void ftrace_set_global_notrace(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "&global_ops",
            "buf",
            "len",
            "reset",
            "0"
          ],
          "line": 4849
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4779-4784",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nvoid ftrace_set_global_notrace(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 0);\n}"
  },
  {
    "function_name": "ftrace_set_global_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4831-4834",
    "snippet": "void ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops global_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "&global_ops",
            "buf",
            "len",
            "reset",
            "1"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4779-4784",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops global_ops;\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}"
  },
  {
    "function_name": "ftrace_set_notrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4815-4820",
    "snippet": "int ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "ops",
            "buf",
            "len",
            "reset",
            "0"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4779-4784",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 4818
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}"
  },
  {
    "function_name": "ftrace_set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4796-4801",
    "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_regex",
          "args": [
            "ops",
            "buf",
            "len",
            "reset",
            "1"
          ],
          "line": 4800
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4779-4784",
          "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
  },
  {
    "function_name": "ftrace_set_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4779-4784",
    "snippet": "static int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_hash",
          "args": [
            "ops",
            "buf",
            "len",
            "0",
            "0",
            "reset",
            "enable"
          ],
          "line": 4783
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4688-4735",
          "snippet": "static int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}"
  },
  {
    "function_name": "ftrace_ops_set_global_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4769-4776",
    "snippet": "void ftrace_ops_set_global_filter(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_INITIALIZED)\n\t\treturn;\n\n\tftrace_ops_init(ops);\n\tops->func_hash = &global_ops.local_hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 4774
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_ops_set_global_filter(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_INITIALIZED)\n\t\treturn;\n\n\tftrace_ops_init(ops);\n\tops->func_hash = &global_ops.local_hash;\n}"
  },
  {
    "function_name": "ftrace_set_filter_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4754-4759",
    "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_addr",
          "args": [
            "ops",
            "ip",
            "remove",
            "reset",
            "1"
          ],
          "line": 4758
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4737-4742",
          "snippet": "static int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 4757
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
  },
  {
    "function_name": "ftrace_set_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4737-4742",
    "snippet": "static int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_hash",
          "args": [
            "ops",
            "0",
            "0",
            "ip",
            "remove",
            "reset",
            "enable"
          ],
          "line": 4741
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4688-4735",
          "snippet": "static int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);\n}"
  },
  {
    "function_name": "ftrace_set_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4688-4735",
    "snippet": "static int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 4733
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "ops",
            "orig_hash",
            "hash",
            "enable"
          ],
          "line": 4727
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3842-3860",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_addr",
          "args": [
            "hash",
            "ip",
            "remove"
          ],
          "line": 4721
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4669-4686",
          "snippet": "static int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "hash",
            "buf",
            "len"
          ],
          "line": 4716
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3805-3809",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "*orig_hash"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1350-1386",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS"
          ],
          "line": 4707
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -EINVAL;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash, hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_match_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4669-4686",
    "snippet": "static int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "hash",
            "ip"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1196-1208",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 4681
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1210-1217",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "ip"
          ],
          "line": 4678
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_location",
          "args": [
            "ip"
          ],
          "line": 4674
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1604-1607",
          "snippet": "unsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}"
  },
  {
    "function_name": "ftrace_notrace_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4662-4667",
    "snippet": "ssize_t\nftrace_notrace_write(struct file *file, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_write",
          "args": [
            "file",
            "ubuf",
            "cnt",
            "ppos",
            "0"
          ],
          "line": 4666
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4616-4653",
          "snippet": "static ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nssize_t\nftrace_notrace_write(struct file *file, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 0);\n}"
  },
  {
    "function_name": "ftrace_filter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4655-4660",
    "snippet": "ssize_t\nftrace_filter_write(struct file *file, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_write",
          "args": [
            "file",
            "ubuf",
            "cnt",
            "ppos",
            "1"
          ],
          "line": 4659
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4616-4653",
          "snippet": "static ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nssize_t\nftrace_filter_write(struct file *file, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 1);\n}"
  },
  {
    "function_name": "ftrace_regex_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4616-4653",
    "snippet": "static ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_clear",
          "args": [
            "parser"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1068-1072",
          "snippet": "static inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_parser_clear(struct trace_parser *parser)\n{\n\tparser->cont = false;\n\tparser->idx = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_process_regex",
          "args": [
            "iter",
            "parser->buffer",
            "parser->idx",
            "enable"
          ],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_process_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4579-4614",
          "snippet": "static int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_cont",
          "args": [
            "parser"
          ],
          "line": 4642
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_cont",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1063-1066",
          "snippet": "static inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_cont(struct trace_parser *parser)\n{\n\treturn parser->cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "parser"
          ],
          "line": 4641
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1058-1061",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_user",
          "args": [
            "parser",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 4639
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1216-1291",
          "snippet": "int trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\t/* iter->hash is a local copy, so we don't need regex_lock */\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_process_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4579-4614",
    "snippet": "static int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4611
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->func",
          "args": [
            "tr",
            "hash",
            "func",
            "command",
            "next",
            "enable"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->name",
            "command"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&ftrace_commands",
            "list"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&next",
            "\":\""
          ],
          "line": 4601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "hash",
            "func",
            "len"
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3805-3809",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&next",
            "\":\""
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_process_regex(struct ftrace_iterator *iter,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tstruct ftrace_hash *hash = iter->hash;\n\tstruct trace_array *tr = iter->ops->private;\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -EINVAL;\n\n\tfunc = strsep(&next, \":\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/* command found */\n\n\tcommand = strsep(&next, \":\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(tr, hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_ftrace_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4560-4577",
    "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 4567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&ftrace_commands",
            "list"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4565
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_ftrace_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4537-4554",
    "snippet": "__init int register_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &ftrace_commands);\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cmd->list",
            "&ftrace_commands"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&ftrace_commands",
            "list"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_cmd_mutex"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int register_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &ftrace_commands);\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "clear_ftrace_function_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4522-4528",
    "snippet": "void clear_ftrace_function_probes(struct trace_array *tr)\n{\n\tstruct ftrace_func_probe *probe, *n;\n\n\tlist_for_each_entry_safe(probe, n, &tr->func_probes, list)\n\t\tunregister_ftrace_function_probe_func(NULL, tr, probe->probe_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function_probe_func",
          "args": [
            "NULL",
            "tr",
            "probe->probe_ops"
          ],
          "line": 4527
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4393-4520",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "probe",
            "n",
            "&tr->func_probes",
            "list"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid clear_ftrace_function_probes(struct trace_array *tr)\n{\n\tstruct ftrace_func_probe *probe, *n;\n\n\tlist_for_each_entry_safe(probe, n, &tr->func_probes, list)\n\t\tunregister_ftrace_function_probe_func(NULL, tr, probe->probe_ops);\n}"
  },
  {
    "function_name": "unregister_ftrace_function_probe_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4393-4520",
    "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_probe",
          "args": [
            "probe"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "release_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4225-4248",
          "snippet": "static void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 4511
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 4505
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "tr",
            "entry->ip",
            "probe->data"
          ],
          "line": 4504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&entry->hlist"
          ],
          "line": 4502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&hhd",
            "hlist"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_run_modify_code",
          "args": [
            "&probe->ops",
            "FTRACE_UPDATE_CALLS",
            "&old_hash_ops"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2646-2656",
          "snippet": "static void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "&probe->ops",
            "orig_hash",
            "hash",
            "1"
          ],
          "line": 4492
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3842-3860",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_shutdown",
          "args": [
            "&probe->ops",
            "0"
          ],
          "line": 4490
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2727-2839",
          "snippet": "static int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "probe->ref < count"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&entry->hlist",
            "&hhd"
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1219-1225",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match",
          "args": [
            "str",
            "&func_g"
          ],
          "line": 4468
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3659-3692",
          "snippet": "static int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "entry->ip",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 4463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&hhd"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "old_hash"
          ],
          "line": 4455
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1350-1386",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_probe_locked",
          "args": [
            "probe"
          ],
          "line": 4438
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_probe_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4250-4257",
          "snippet": "static void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "probe",
            "&tr->func_probes",
            "list"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "not"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_g.search"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "glob",
            "strlen(glob)",
            "&func_g.search",
            "&not"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "810-846",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "glob",
            "\"*\""
          ],
          "line": 4411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "register_ftrace_function_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4259-4391",
    "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "tr",
            "entry->ip",
            "probe->data"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "old_hash",
            "entry->ip"
          ],
          "line": 4385
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_probe",
          "args": [
            "probe"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "release_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4225-4248",
          "snippet": "static void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe->ops.func_hash->regex_lock"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_startup",
          "args": [
            "&probe->ops",
            "0"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2685-2725",
          "snippet": "static int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "&probe->ops",
            "orig_hash",
            "hash",
            "1"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3842-3860",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4346
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "tr",
            "0",
            "probe->data"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_ops->init",
          "args": [
            "probe_ops",
            "tr",
            "entry->ip",
            "data",
            "&probe->data"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_match_records",
          "args": [
            "hash",
            "glob",
            "strlen(glob)"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3805-3809",
          "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "glob"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "old_hash"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1350-1386",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_probe_locked",
          "args": [
            "probe"
          ],
          "line": 4301
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_probe_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4250-4257",
          "snippet": "static void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&probe->list",
            "&tr->func_probes"
          ],
          "line": 4298
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "&probe->ops"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*probe)",
            "GFP_KERNEL"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "probe",
            "&tr->func_probes",
            "list"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "glob[0] == '!'"
          ],
          "line": 4278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tr"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "acquire_probe_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4250-4257",
    "snippet": "static void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void acquire_probe_locked(struct ftrace_func_probe *probe)\n{\n\t/*\n\t * Add one ref to keep it from being freed when releasing the\n\t * ftrace_lock mutex.\n\t */\n\tprobe->ref++;\n}"
  },
  {
    "function_name": "release_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4225-4248",
    "snippet": "static void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "probe"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&probe->list"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->free",
          "args": [
            "probe_ops",
            "probe->tr",
            "0",
            "probe->data"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "probe->ref <= 0"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 4229
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void release_probe(struct ftrace_func_probe *probe)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref <= 0);\n\n\t/* Subtract the ref that was used to protect this instance */\n\tprobe->ref--;\n\n\tif (!probe->ref) {\n\t\tprobe_ops = probe->probe_ops;\n\t\t/*\n\t\t * Sending zero as ip tells probe_ops to free\n\t\t * the probe->data itself\n\t\t */\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, probe->tr, 0, probe->data);\n\t\tlist_del(&probe->list);\n\t\tkfree(probe);\n\t}\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "free_ftrace_func_mapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4204-4223",
    "snippet": "void free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size = 1 << mapper->hash.size_bits;\n\tint i;\n\n\tif (free_func && mapper->hash.count) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "&mapper->hash"
          ],
          "line": 4222
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_func",
          "args": [
            "map"
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "free_func_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "598-605",
          "snippet": "static void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->refs);\n\tkfree(state->stack);\n\tkfree(state);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->refs);\n\tkfree(state->stack);\n\tkfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "hhd",
            "hlist"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size = 1 << mapper->hash.size_bits;\n\tint i;\n\n\tif (free_func && mapper->hash.count) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}"
  },
  {
    "function_name": "ftrace_func_mapper_remove_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4176-4194",
    "snippet": "void *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "&mapper->hash",
            "entry"
          ],
          "line": 4190
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1219-1225",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "&mapper->hash",
            "ip"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}"
  },
  {
    "function_name": "ftrace_func_mapper_add_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4144-4164",
    "snippet": "int ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "&mapper->hash",
            "&map->entry"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1184-1194",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*map)",
            "GFP_KERNEL"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "&mapper->hash",
            "ip"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_func_mapper_find_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4122-4134",
    "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "&mapper->hash",
            "ip"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
  },
  {
    "function_name": "allocate_ftrace_func_mapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4098-4109",
    "snippet": "struct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstruct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}"
  },
  {
    "function_name": "function_trace_probe_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4065-4082",
    "snippet": "static void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t      struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = container_of(op, struct ftrace_func_probe, ops);\n\tprobe_ops = probe->probe_ops;\n\n\t/*\n\t * Disable preemption for these calls to prevent a RCU grace\n\t * period. This syncs the hash iteration and freeing of items\n\t * on the hash. rcu_read_lock is too dangerous here.\n\t */\n\tpreempt_disable_notrace();\n\tprobe_ops->func(ip, parent_ip, probe->tr, probe_ops, probe->data);\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_ops->func",
          "args": [
            "ip",
            "parent_ip",
            "probe->tr",
            "probe_ops",
            "probe->data"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op",
            "structftrace_func_probe",
            "ops"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t      struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = container_of(op, struct ftrace_func_probe, ops);\n\tprobe_ops = probe->probe_ops;\n\n\t/*\n\t * Disable preemption for these calls to prevent a RCU grace\n\t * period. This syncs the hash iteration and freeing of items\n\t * on the hash. rcu_read_lock is too dangerous here.\n\t */\n\tpreempt_disable_notrace();\n\tprobe_ops->func(ip, parent_ip, probe->tr, probe_ops, probe->data);\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "ftrace_mod_cmd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4059-4062",
    "snippet": "static int __init ftrace_mod_cmd_init(void)\n{\n\treturn register_ftrace_command(&ftrace_mod_cmd);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_command",
          "args": [
            "&ftrace_mod_cmd"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4560-4577",
          "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int __init ftrace_mod_cmd_init(void)\n{\n\treturn register_ftrace_command(&ftrace_mod_cmd);\n}"
  },
  {
    "function_name": "ftrace_mod_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "4025-4052",
    "snippet": "static int\nftrace_mod_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t    char *func_orig, char *cmd, char *module, int enable)\n{\n\tchar *func;\n\tint ret;\n\n\t/* match_records() modifies func, and we need the original */\n\tfunc = kstrdup(func_orig, GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * cmd == 'mod' because we only registered this func\n\t * for the 'mod' ftrace_func_command.\n\t * But if you register one func with multiple commands,\n\t * you can tell which command was used by the cmd\n\t * parameter.\n\t */\n\tret = match_records(hash, func, strlen(func), module);\n\tkfree(func);\n\n\tif (!ret)\n\t\treturn cache_mod(tr, func_orig, module, enable);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_mod",
          "args": [
            "tr",
            "func_orig",
            "module",
            "enable"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "cache_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3879-3921",
          "snippet": "static int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "func"
          ],
          "line": 4045
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_records",
          "args": [
            "hash",
            "func",
            "strlen(func)",
            "module"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3755-3803",
          "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "func_orig",
            "GFP_KERNEL"
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_mod_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t    char *func_orig, char *cmd, char *module, int enable)\n{\n\tchar *func;\n\tint ret;\n\n\t/* match_records() modifies func, and we need the original */\n\tfunc = kstrdup(func_orig, GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * cmd == 'mod' because we only registered this func\n\t * for the 'mod' ftrace_func_command.\n\t * But if you register one func with multiple commands,\n\t * you can tell which command was used by the cmd\n\t * parameter.\n\t */\n\tret = match_records(hash, func, strlen(func), module);\n\tkfree(func);\n\n\tif (!ret)\n\t\treturn cache_mod(tr, func_orig, module, enable);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}"
  },
  {
    "function_name": "process_cached_mods",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3998-4017",
    "snippet": "static void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mod"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_mod_list",
          "args": [
            "&tr->mod_notrace",
            "tr->ops",
            "mod",
            "false"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "process_mod_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3928-3996",
          "snippet": "static void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\tint ret;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_del(&ftrace_mod->list);\n\t\tlist_add(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\tint ret;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_del(&ftrace_mod->list);\n\t\tlist_add(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tr->mod_notrace"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 4007
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "mod_name",
            "GFP_KERNEL"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_cached_mods(const char *mod_name)\n{\n\tstruct trace_array *tr;\n\tchar *mod;\n\n\tmod = kstrdup(mod_name, GFP_KERNEL);\n\tif (!mod)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!list_empty(&tr->mod_trace))\n\t\t\tprocess_mod_list(&tr->mod_trace, tr->ops, mod, true);\n\t\tif (!list_empty(&tr->mod_notrace))\n\t\t\tprocess_mod_list(&tr->mod_notrace, tr->ops, mod, false);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\tkfree(mod);\n}"
  },
  {
    "function_name": "process_mod_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3928-3996",
    "snippet": "static void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\tint ret;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_del(&ftrace_mod->list);\n\t\tlist_add(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move_and_update_ops",
          "args": [
            "ops",
            "orig_hash",
            "new_hash",
            "enable"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3842-3860",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "ftrace_mod"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1246-1252",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_records",
          "args": [
            "new_hash",
            "func",
            "strlen(func)",
            "mod"
          ],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3755-3803",
          "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func"
          ],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ftrace_mod",
            "n",
            "&process_mods",
            "list"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ftrace_mod->func"
          ],
          "line": 3968
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ftrace_mod->list",
            "&process_mods"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ftrace_mod->list"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"*\"",
            "GFP_KERNEL"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "ftrace_mod->func",
            "GFP_KERNEL"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ftrace_mod->module",
            "mod"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ftrace_mod",
            "n",
            "head",
            "list"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "FTRACE_HASH_DEFAULT_BITS",
            "*orig_hash"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1350-1386",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "process_mods"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void process_mod_list(struct list_head *head, struct ftrace_ops *ops,\n\t\t\t     char *mod, bool enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct ftrace_hash **orig_hash, *new_hash;\n\tLIST_HEAD(process_mods);\n\tchar *func;\n\tint ret;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tnew_hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS,\n\t\t\t\t\t      *orig_hash);\n\tif (!new_hash)\n\t\tgoto out; /* warn? */\n\n\tmutex_lock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\n\t\tif (strcmp(ftrace_mod->module, mod) != 0)\n\t\t\tcontinue;\n\n\t\tif (ftrace_mod->func)\n\t\t\tfunc = kstrdup(ftrace_mod->func, GFP_KERNEL);\n\t\telse\n\t\t\tfunc = kstrdup(\"*\", GFP_KERNEL);\n\n\t\tif (!func) /* warn? */\n\t\t\tcontinue;\n\n\t\tlist_del(&ftrace_mod->list);\n\t\tlist_add(&ftrace_mod->list, &process_mods);\n\n\t\t/* Use the newly allocated func, as it may be \"*\" */\n\t\tkfree(ftrace_mod->func);\n\t\tftrace_mod->func = func;\n\t}\n\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(ftrace_mod, n, &process_mods, list) {\n\n\t\tfunc = ftrace_mod->func;\n\n\t\t/* Grabs ftrace_lock, which is why we have this extra step */\n\t\tmatch_records(new_hash, func, strlen(func), mod);\n\t\tfree_ftrace_mod(ftrace_mod);\n\t}\n\n\tif (enable && list_empty(head))\n\t\tnew_hash->flags &= ~FTRACE_HASH_FL_MOD;\n\n\tmutex_lock(&ftrace_lock);\n\n\tret = ftrace_hash_move_and_update_ops(ops, orig_hash,\n\t\t\t\t\t      new_hash, enable);\n\tmutex_unlock(&ftrace_lock);\n\n out:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(new_hash);\n}"
  },
  {
    "function_name": "cache_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3879-3921",
    "snippet": "static int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_add_mod",
          "args": [
            "tr",
            "func",
            "module",
            "enable"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1322-1348",
          "snippet": "static int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_exists",
          "args": [
            "module"
          ],
          "line": 3912
        },
        "resolved": true,
        "details": {
          "function_name": "module_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3862-3877",
          "snippet": "static bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tconst char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tconst char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "ftrace_mod"
          ],
          "line": 3903
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1246-1252",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ftrace_mod->func",
            "func"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "func",
            "\"*\""
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ftrace_mod->module",
            "module"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ftrace_mod",
            "n",
            "head",
            "list"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3886
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int cache_mod(struct trace_array *tr,\n\t\t     const char *func, char *module, int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod, *n;\n\tstruct list_head *head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* We do not cache inverse filters */\n\tif (func[0] == '!') {\n\t\tfunc++;\n\t\tret = -EINVAL;\n\n\t\t/* Look to remove this hash */\n\t\tlist_for_each_entry_safe(ftrace_mod, n, head, list) {\n\t\t\tif (strcmp(ftrace_mod->module, module) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* no func matches all */\n\t\t\tif (strcmp(func, \"*\") == 0 ||\n\t\t\t    (ftrace_mod->func &&\n\t\t\t     strcmp(ftrace_mod->func, func) == 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tfree_ftrace_mod(ftrace_mod);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\t/* We only care about modules that have not been loaded yet */\n\tif (module_exists(module))\n\t\tgoto out;\n\n\t/* Save this string off, and execute it when the module is loaded */\n\tret = ftrace_add_mod(tr, func, module, enable);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "module_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3862-3877",
    "snippet": "static bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tconst char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_kallsyms_lookup_name",
          "args": [
            "modname"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4090-4111",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "modname",
            "sizeof(modname)",
            "\"%s:%s\"",
            "module",
            "this_mod"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool module_exists(const char *module)\n{\n\t/* All modules have the symbol __this_module */\n\tconst char this_mod[] = \"__this_module\";\n\tchar modname[MAX_PARAM_PREFIX_LEN + sizeof(this_mod) + 2];\n\tunsigned long val;\n\tint n;\n\n\tn = snprintf(modname, sizeof(modname), \"%s:%s\", module, this_mod);\n\n\tif (n > sizeof(modname) - 1)\n\t\treturn false;\n\n\tval = module_kallsyms_lookup_name(modname);\n\treturn val != 0;\n}"
  },
  {
    "function_name": "ftrace_hash_move_and_update_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3842-3860",
    "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash_rcu",
          "args": [
            "old_hash"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_update_code",
          "args": [
            "ops",
            "&old_hash_ops"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3811-3840",
          "snippet": "static void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_move",
          "args": [
            "ops",
            "enable",
            "orig_hash",
            "hash"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_move_and_update_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3842-3860",
          "snippet": "static int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_move_and_update_ops(struct ftrace_ops *ops,\n\t\t\t\t\t   struct ftrace_hash **orig_hash,\n\t\t\t\t\t   struct ftrace_hash *hash,\n\t\t\t\t\t   int enable)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tint ret;\n\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_ops_update_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3811-3840",
    "snippet": "static void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_run_modify_code",
          "args": [
            "op",
            "FTRACE_UPDATE_CALLS",
            "old_hash"
          ],
          "line": 3835
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2646-2656",
          "snippet": "static void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & FTRACE_OPS_FL_ENABLED) {\n\t\tftrace_run_modify_code(ops, FTRACE_UPDATE_CALLS, old_hash);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is the shared global_ops filter, then we need to\n\t * check if there is another ops that shares it, is enabled.\n\t * If so, we still need to run the modify code.\n\t */\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & FTRACE_OPS_FL_ENABLED) {\n\t\t\tftrace_run_modify_code(op, FTRACE_UPDATE_CALLS, old_hash);\n\t\t\t/* Only need to do this once */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}"
  },
  {
    "function_name": "ftrace_match_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3805-3809",
    "snippet": "static int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_records",
          "args": [
            "hash",
            "buff",
            "len",
            "NULL"
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "match_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3755-3803",
          "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled",
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, NULL);\n}"
  },
  {
    "function_name": "match_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3755-3803",
    "snippet": "static int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_record",
          "args": [
            "hash",
            "rec",
            "clear_filter"
          ],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "enter_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3694-3715",
          "snippet": "static int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_match_record",
          "args": [
            "rec",
            "&func_g",
            "mod_match",
            "exclude_mod"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3717-3753",
          "snippet": "static int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mod_g.search"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "mod",
            "strlen(mod)",
            "&mod_g.search",
            "&exclude_mod"
          ],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "810-846",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *func, int len, char *mod)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_glob func_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob mod_g = { .type = MATCH_FULL };\n\tstruct ftrace_glob *mod_match = (mod) ? &mod_g : NULL;\n\tint exclude_mod = 0;\n\tint found = 0;\n\tint ret;\n\tint clear_filter = 0;\n\n\tif (func) {\n\t\tfunc_g.type = filter_parse_regex(func, len, &func_g.search,\n\t\t\t\t\t\t &clear_filter);\n\t\tfunc_g.len = strlen(func_g.search);\n\t}\n\n\tif (mod) {\n\t\tmod_g.type = filter_parse_regex(mod, strlen(mod),\n\t\t\t\t&mod_g.search, &exclude_mod);\n\t\tmod_g.len = strlen(mod_g.search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (ftrace_match_record(rec, &func_g, mod_match, exclude_mod)) {\n\t\t\tret = enter_record(hash, rec, clear_filter);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}"
  },
  {
    "function_name": "ftrace_match_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3717-3753",
    "snippet": "static int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_match",
          "args": [
            "str",
            "func_g"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3659-3692",
          "snippet": "static int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "rec->ip",
            "NULL",
            "NULL",
            "&modname",
            "str"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, struct ftrace_glob *func_g,\n\t\tstruct ftrace_glob *mod_g, int exclude_mod)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, &modname, str);\n\n\tif (mod_g) {\n\t\tint mod_matches = (modname) ? ftrace_match(modname, mod_g) : 0;\n\n\t\t/* blank module name to match all modules */\n\t\tif (!mod_g->len) {\n\t\t\t/* blank module globbing: modname xor exclude_mod */\n\t\t\tif (!exclude_mod != !modname)\n\t\t\t\tgoto func_match;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * exclude_mod is set to trace everything but the given\n\t\t * module. If it is set and the module matches, then\n\t\t * return 0. If it is not set, and the module doesn't match\n\t\t * also return 0. Otherwise, check the function to see if\n\t\t * that matches.\n\t\t */\n\t\tif (!mod_matches == !exclude_mod)\n\t\t\treturn 0;\nfunc_match:\n\t\t/* blank search means to match all funcs in the mod */\n\t\tif (!func_g->len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, func_g);\n}"
  },
  {
    "function_name": "enter_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3694-3715",
    "snippet": "static int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1196-1208",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1210-1217",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "hash",
            "rec->ip"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int clear_filter)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (clear_filter) {\n\t\t/* Do nothing if it doesn't exist */\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t/* Do nothing if it exists */\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3659-3692",
    "snippet": "static int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob_match",
          "args": [
            "g->search",
            "str"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str + slen - g->len",
            "g->search",
            "g->len"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "g->search"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "g->search",
            "g->len"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "g->search"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_ftrace_match_adjust",
          "args": [
            "str",
            "g->search"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_match_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3654-3657",
          "snippet": "char * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nchar * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_match(char *str, struct ftrace_glob *g)\n{\n\tint matched = 0;\n\tint slen;\n\n\tstr = arch_ftrace_match_adjust(str, g->search);\n\n\tswitch (g->type) {\n\tcase MATCH_FULL:\n\t\tif (strcmp(str, g->search) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tif (strncmp(str, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tif (strstr(str, g->search))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tslen = strlen(str);\n\t\tif (slen >= g->len &&\n\t\t    memcmp(str + slen - g->len, g->search, g->len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tif (glob_match(g->search, str))\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}"
  },
  {
    "function_name": "arch_ftrace_match_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3654-3657",
    "snippet": "char * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nchar * __weak arch_ftrace_match_adjust(char *str, const char *search)\n{\n\treturn str;\n}"
  },
  {
    "function_name": "ftrace_notrace_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3633-3640",
    "snippet": "static int\nftrace_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops, FTRACE_ITER_NOTRACE,\n\t\t\t\t inode, file);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_open",
          "args": [
            "ops",
            "FTRACE_ITER_NOTRACE",
            "inode",
            "file"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3542-3621",
          "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops, FTRACE_ITER_NOTRACE,\n\t\t\t\t inode, file);\n}"
  },
  {
    "function_name": "ftrace_filter_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3623-3631",
    "snippet": "static int\nftrace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops,\n\t\t\tFTRACE_ITER_FILTER | FTRACE_ITER_DO_PROBES,\n\t\t\tinode, file);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_open",
          "args": [
            "ops",
            "FTRACE_ITER_FILTER | FTRACE_ITER_DO_PROBES",
            "inode",
            "file"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3542-3621",
          "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops,\n\t\t\tFTRACE_ITER_FILTER | FTRACE_ITER_DO_PROBES,\n\t\t\tinode, file);\n}"
  },
  {
    "function_name": "ftrace_regex_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3542-3621",
    "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
      "#define FTRACE_HASH_DEFAULT_BITS 10"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "&iter->parser"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1199-1203",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "iter->hash"
          ],
          "line": 3610
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&show_ftrace_seq_ops"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_copy_ftrace_hash",
          "args": [
            "size_bits",
            "hash"
          ],
          "line": 3589
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_copy_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1350-1386",
          "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ftrace_mod_list",
          "args": [
            "mod_head"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ftrace_mod_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1254-1266",
          "snippet": "static void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "size_bits"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ops->func_hash->regex_lock"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_get_init",
          "args": [
            "&iter->parser",
            "FTRACE_BUFF_MAX"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_get_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1184-1194",
          "snippet": "int trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*iter)",
            "GFP_KERNEL"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX)) {\n\t\tkfree(iter);\n\t\treturn -ENOMEM;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_enabled_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3510-3524",
    "snippet": "static int\nftrace_enabled_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->flags = FTRACE_ITER_ENABLED;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&show_ftrace_seq_ops",
            "sizeof(*iter)"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_enabled_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->flags = FTRACE_ITER_ENABLED;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_avail_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3492-3508",
    "snippet": "static int\nftrace_avail_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&show_ftrace_seq_ops",
            "sizeof(*iter)"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_avail_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->pg = ftrace_pages_start;\n\titer->ops = &global_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3431-3483",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\tif (iter->flags & FTRACE_ITER_NOTRACE)\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\trec = iter->func;\n\n\tif (!rec)\n\t\treturn 0;\n\n\tseq_printf(m, \"%ps\", (void *)rec->ip);\n\tif (iter->flags & FTRACE_ITER_ENABLED) {\n\t\tstruct ftrace_ops *ops;\n\n\t\tseq_printf(m, \" (%ld)%s%s\",\n\t\t\t   ftrace_rec_count(rec),\n\t\t\t   rec->flags & FTRACE_FL_REGS ? \" R\" : \"  \",\n\t\t\t   rec->flags & FTRACE_FL_IPMODIFY ? \" I\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tseq_printf(m, \"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t   (void *)ops->trampoline,\n\t\t\t\t\t\t   (void *)ops->func);\n\t\t\t\t\tadd_trampoline_func(m, ops, rec);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tseq_puts(m, \"\\ttramp: ERROR!\");\n\t\t} else {\n\t\t\tadd_trampoline_func(m, NULL, rec);\n\t\t}\n\t}\t\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_trampoline_func",
          "args": [
            "m",
            "NULL",
            "rec"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "add_trampoline_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3421-3429",
          "snippet": "static void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\ttramp: ERROR!\""
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_next",
          "args": [
            "rec",
            "ops"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2215-2231",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} \n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} \n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\ttramp: %pS (%pS)\"",
            "(void *)ops->trampoline",
            "(void *)ops->func"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_any",
          "args": [
            "rec"
          ],
          "line": 3464
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2197-2213",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_mod_show",
          "args": [
            "m",
            "iter"
          ],
          "line": 3440
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3258-3279",
          "snippet": "static int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_probe_show",
          "args": [
            "m",
            "iter"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3181-3203",
          "snippet": "static int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_show(m, iter);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\tif (iter->flags & FTRACE_ITER_NOTRACE)\n\t\t\tseq_puts(m, \"#### no functions disabled ####\\n\");\n\t\telse\n\t\t\tseq_puts(m, \"#### all functions enabled ####\\n\");\n\t\treturn 0;\n\t}\n\n\trec = iter->func;\n\n\tif (!rec)\n\t\treturn 0;\n\n\tseq_printf(m, \"%ps\", (void *)rec->ip);\n\tif (iter->flags & FTRACE_ITER_ENABLED) {\n\t\tstruct ftrace_ops *ops;\n\n\t\tseq_printf(m, \" (%ld)%s%s\",\n\t\t\t   ftrace_rec_count(rec),\n\t\t\t   rec->flags & FTRACE_FL_REGS ? \" R\" : \"  \",\n\t\t\t   rec->flags & FTRACE_FL_IPMODIFY ? \" I\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tseq_printf(m, \"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t   (void *)ops->trampoline,\n\t\t\t\t\t\t   (void *)ops->func);\n\t\t\t\t\tadd_trampoline_func(m, ops, rec);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tseq_puts(m, \"\\ttramp: ERROR!\");\n\t\t} else {\n\t\t\tadd_trampoline_func(m, NULL, rec);\n\t\t}\n\t}\t\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_trampoline_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3421-3429",
    "snippet": "static void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" ->%pS\"",
            "ptr"
          ],
          "line": 3428
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ftrace_trampoline_func",
          "args": [
            "ops",
            "rec"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_trampoline_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3415-3419",
          "snippet": "void * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->%pS\", ptr);\n}"
  },
  {
    "function_name": "arch_ftrace_trampoline_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3415-3419",
    "snippet": "void * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3410-3413",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3355-3408",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\t/*\n\t * If an lseek was done, then reset and start from beginning.\n\t */\n\tif (*pos < iter->pos)\n\t\treset_iter_read(iter);\n\n\t/*\n\t * For set_ftrace_filter reading, if we have the filter\n\t * off, we can short cut and just print out that all\n\t * functions are enabled.\n\t */\n\tif ((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t    ftrace_hash_empty(iter->hash)) {\n\t\titer->func_pos = 1; /* Account for the message */\n\t\tif (*pos > 0)\n\t\t\treturn t_mod_start(m, pos);\n\t\titer->flags |= FTRACE_ITER_PRINTALL;\n\t\t/* reset in case of seek/pread */\n\t\titer->flags &= ~FTRACE_ITER_PROBE;\n\t\treturn iter;\n\t}\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_start(m, pos);\n\n\t/*\n\t * Unfortunately, we need to restart at ftrace_pages_start\n\t * every time we let go of the ftrace_mutex. This is because\n\t * those pointers can change without the lock.\n\t */\n\titer->pg = ftrace_pages_start;\n\titer->idx = 0;\n\tfor (l = 0; l <= *pos; ) {\n\t\tp = t_func_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tif (!p)\n\t\treturn t_mod_start(m, pos);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_mod_start",
          "args": [
            "m",
            "pos"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3227-3256",
          "snippet": "static void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_func_next",
          "args": [
            "m",
            "&l"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "t_func_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3281-3316",
          "snippet": "static void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "iter->hash"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter_read",
          "args": [
            "iter"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3348-3353",
          "snippet": "static void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\t/*\n\t * If an lseek was done, then reset and start from beginning.\n\t */\n\tif (*pos < iter->pos)\n\t\treset_iter_read(iter);\n\n\t/*\n\t * For set_ftrace_filter reading, if we have the filter\n\t * off, we can short cut and just print out that all\n\t * functions are enabled.\n\t */\n\tif ((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t    ftrace_hash_empty(iter->hash)) {\n\t\titer->func_pos = 1; /* Account for the message */\n\t\tif (*pos > 0)\n\t\t\treturn t_mod_start(m, pos);\n\t\titer->flags |= FTRACE_ITER_PRINTALL;\n\t\t/* reset in case of seek/pread */\n\t\titer->flags &= ~FTRACE_ITER_PROBE;\n\t\treturn iter;\n\t}\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_start(m, pos);\n\n\t/*\n\t * Unfortunately, we need to restart at ftrace_pages_start\n\t * every time we let go of the ftrace_mutex. This is because\n\t * those pointers can change without the lock.\n\t */\n\titer->pg = ftrace_pages_start;\n\titer->idx = 0;\n\tfor (l = 0; l <= *pos; ) {\n\t\tp = t_func_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tif (!p)\n\t\treturn t_mod_start(m, pos);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "reset_iter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3348-3353",
    "snippet": "static void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void reset_iter_read(struct ftrace_iterator *iter)\n{\n\titer->pos = 0;\n\titer->func_pos = 0;\n\titer->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_PROBE | FTRACE_ITER_MOD);\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3318-3346",
    "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tloff_t l = *pos; /* t_probe_start() must use original pos */\n\tvoid *ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\t/* next must increment pos, and t_probe_start does not */\n\t\t(*pos)++;\n\t\treturn t_mod_start(m, &l);\n\t}\n\n\tret = t_func_next(m, pos);\n\n\tif (!ret)\n\t\treturn t_mod_start(m, &l);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_mod_start",
          "args": [
            "m",
            "&l"
          ],
          "line": 3343
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3227-3256",
          "snippet": "static void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_func_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "t_func_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3281-3316",
          "snippet": "static void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_mod_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3205-3225",
          "snippet": "static void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_probe_next",
          "args": [
            "m",
            "pos"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3082-3150",
          "snippet": "static void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tloff_t l = *pos; /* t_probe_start() must use original pos */\n\tvoid *ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn NULL;\n\n\tif (iter->flags & FTRACE_ITER_PROBE)\n\t\treturn t_probe_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_MOD)\n\t\treturn t_mod_next(m, pos);\n\n\tif (iter->flags & FTRACE_ITER_PRINTALL) {\n\t\t/* next must increment pos, and t_probe_start does not */\n\t\t(*pos)++;\n\t\treturn t_mod_start(m, &l);\n\t}\n\n\tret = t_func_next(m, pos);\n\n\tif (!ret)\n\t\treturn t_mod_start(m, &l);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "t_func_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3281-3316",
    "snippet": "static void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "iter->hash",
            "rec->ip"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_func_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec = NULL;\n\n\t(*pos)++;\n\n retry:\n\tif (iter->idx >= iter->pg->index) {\n\t\tif (iter->pg->next) {\n\t\t\titer->pg = iter->pg->next;\n\t\t\titer->idx = 0;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\trec = &iter->pg->records[iter->idx++];\n\t\tif (((iter->flags & (FTRACE_ITER_FILTER | FTRACE_ITER_NOTRACE)) &&\n\t\t     !ftrace_lookup_ip(iter->hash, rec->ip)) ||\n\n\t\t    ((iter->flags & FTRACE_ITER_ENABLED) &&\n\t\t     !(rec->flags & FTRACE_FL_ENABLED))) {\n\n\t\t\trec = NULL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!rec)\n\t\treturn NULL;\n\n\titer->pos = iter->func_pos = *pos;\n\titer->func = rec;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_mod_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3258-3279",
    "snippet": "static int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":mod:%s\\n\"",
            "ftrace_mod->module"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'*'"
          ],
          "line": 3274
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "iter->mod_list",
            "structftrace_mod_load",
            "list"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!iter->mod_list"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_mod_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (WARN_ON_ONCE(!iter->mod_list) ||\n\t\t\t iter->mod_list == &tr->mod_trace ||\n\t\t\t iter->mod_list == &tr->mod_notrace)\n\t\treturn -EIO;\n\n\tftrace_mod = list_entry(iter->mod_list, struct ftrace_mod_load, list);\n\n\tif (ftrace_mod->func)\n\t\tseq_printf(m, \"%s\", ftrace_mod->func);\n\telse\n\t\tseq_putc(m, '*');\n\n\tseq_printf(m, \":mod:%s\\n\", ftrace_mod->module);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_mod_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3227-3256",
    "snippet": "static void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_probe_start",
          "args": [
            "m",
            "pos"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3152-3179",
          "snippet": "static void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_mod_next",
          "args": [
            "m",
            "&l"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "t_mod_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3205-3225",
          "snippet": "static void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_mod_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (iter->func_pos > *pos)\n\t\treturn NULL;\n\n\titer->mod_pos = iter->func_pos;\n\n\t/* probes are only available if tr is set */\n\tif (!iter->tr)\n\t\treturn NULL;\n\n\tfor (l = 0; l <= (*pos - iter->func_pos); ) {\n\t\tp = t_mod_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn t_probe_start(m, pos);\n\t}\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_MOD;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_mod_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3205-3225",
    "snippet": "static void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nt_mod_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\titer->mod_list = iter->mod_list->next;\n\n\tif (iter->mod_list == &tr->mod_trace ||\n\t    iter->mod_list == &tr->mod_notrace) {\n\t\titer->flags &= ~FTRACE_ITER_MOD;\n\t\treturn NULL;\n\t}\n\n\titer->mod_pos = *pos;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_probe_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3181-3203",
    "snippet": "static int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%ps:%ps\\n\"",
            "(void *)probe_entry->ip",
            "(void *)probe_ops->func"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_ops->print",
          "args": [
            "m",
            "probe_entry->ip",
            "probe_ops",
            "probe->data"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!probe || !probe_entry"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\nt_probe_show(struct seq_file *m, struct ftrace_iterator *iter)\n{\n\tstruct ftrace_func_entry *probe_entry;\n\tstruct ftrace_probe_ops *probe_ops;\n\tstruct ftrace_func_probe *probe;\n\n\tprobe = iter->probe;\n\tprobe_entry = iter->probe_entry;\n\n\tif (WARN_ON_ONCE(!probe || !probe_entry))\n\t\treturn -EIO;\n\n\tprobe_ops = probe->probe_ops;\n\n\tif (probe_ops->print)\n\t\treturn probe_ops->print(m, probe_entry->ip, probe_ops, probe->data);\n\n\tseq_printf(m, \"%ps:%ps\\n\", (void *)probe_entry->ip,\n\t\t   (void *)probe_ops->func);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "t_probe_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3152-3179",
    "snippet": "static void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_probe_next",
          "args": [
            "m",
            "&l"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "t_probe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "3082-3150",
          "snippet": "static void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *t_probe_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tvoid *p = NULL;\n\tloff_t l;\n\n\tif (!(iter->flags & FTRACE_ITER_DO_PROBES))\n\t\treturn NULL;\n\n\tif (iter->mod_pos > *pos)\n\t\treturn NULL;\n\n\titer->probe = NULL;\n\titer->probe_entry = NULL;\n\titer->pidx = 0;\n\tfor (l = 0; l <= (*pos - iter->mod_pos); ) {\n\t\tp = t_probe_next(m, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\n\t/* Only set this if we have an item */\n\titer->flags |= FTRACE_ITER_PROBE;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "t_probe_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3082-3150",
    "snippet": "static void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "hnd",
            "structftrace_func_entry",
            "hlist"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!hnd"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "hhd"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structftrace_func_probe",
            "list"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structftrace_func_probe",
            "list"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "func_probes"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void *\nt_probe_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->ops->private;\n\tstruct list_head *func_probes;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *next;\n\tstruct hlist_node *hnd = NULL;\n\tstruct hlist_head *hhd;\n\tint size;\n\n\t(*pos)++;\n\titer->pos = *pos;\n\n\tif (!tr)\n\t\treturn NULL;\n\n\tfunc_probes = &tr->func_probes;\n\tif (list_empty(func_probes))\n\t\treturn NULL;\n\n\tif (!iter->probe) {\n\t\tnext = func_probes->next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t}\n\n\tif (iter->probe_entry)\n\t\thnd = &iter->probe_entry->hlist;\n\n\thash = iter->probe->ops.func_hash->filter_hash;\n\tsize = 1 << hash->size_bits;\n\n retry:\n\tif (iter->pidx >= size) {\n\t\tif (iter->probe->list.next == func_probes)\n\t\t\treturn NULL;\n\t\tnext = iter->probe->list.next;\n\t\titer->probe = list_entry(next, struct ftrace_func_probe, list);\n\t\thash = iter->probe->ops.func_hash->filter_hash;\n\t\tsize = 1 << hash->size_bits;\n\t\titer->pidx = 0;\n\t}\n\n\thhd = &hash->buckets[iter->pidx];\n\n\tif (hlist_empty(hhd)) {\n\t\titer->pidx++;\n\t\thnd = NULL;\n\t\tgoto retry;\n\t}\n\n\tif (!hnd)\n\t\thnd = hhd->first;\n\telse {\n\t\thnd = hnd->next;\n\t\tif (!hnd) {\n\t\t\titer->pidx++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!hnd))\n\t\treturn NULL;\n\n\titer->probe_entry = hlist_entry(hnd, struct ftrace_func_entry, hlist);\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ftrace_allocate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "3011-3060",
    "snippet": "static struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn 0;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace: FAILED to allocate memory for functions\\n\""
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pg"
          ],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)pg->records",
            "order"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count_order",
          "args": [
            "pg->size / ENTRIES_PER_PAGE"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pg)",
            "GFP_KERNEL"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_allocate_records",
          "args": [
            "pg",
            "num_to_init"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_allocate_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2974-3009",
          "snippet": "static int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\torder = get_count_order(DIV_ROUND_UP(count, ENTRIES_PER_PAGE));\n\n\t/*\n\t * We want to fill as much as possible. No more than a page\n\t * may be empty.\n\t */\n\twhile ((PAGE_SIZE << order) / ENTRY_SIZE >= count + ENTRIES_PER_PAGE)\n\t\torder--;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->size = cnt;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)",
            "#define ENTRY_SIZE sizeof(struct dyn_ftrace)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n#define ENTRY_SIZE sizeof(struct dyn_ftrace)\n\nstatic int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\torder = get_count_order(DIV_ROUND_UP(count, ENTRIES_PER_PAGE));\n\n\t/*\n\t * We want to fill as much as possible. No more than a page\n\t * may be empty.\n\t */\n\twhile ((PAGE_SIZE << order) / ENTRY_SIZE >= count + ENTRIES_PER_PAGE)\n\t\torder--;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->size = cnt;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pg)",
            "GFP_KERNEL"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n\nstatic struct ftrace_page *\nftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn 0;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\tpg = start_pg;\n\twhile (pg) {\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_allocate_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2974-3009",
    "snippet": "static int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\torder = get_count_order(DIV_ROUND_UP(count, ENTRIES_PER_PAGE));\n\n\t/*\n\t * We want to fill as much as possible. No more than a page\n\t * may be empty.\n\t */\n\twhile ((PAGE_SIZE << order) / ENTRY_SIZE >= count + ENTRIES_PER_PAGE)\n\t\torder--;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->size = cnt;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)",
      "#define ENTRY_SIZE sizeof(struct dyn_ftrace)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL | __GFP_ZERO",
            "order"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count_order",
          "args": [
            "DIV_ROUND_UP(count, ENTRIES_PER_PAGE)"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "count",
            "ENTRIES_PER_PAGE"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!count"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ENTRIES_PER_PAGE (PAGE_SIZE / ENTRY_SIZE)\n#define ENTRY_SIZE sizeof(struct dyn_ftrace)\n\nstatic int ftrace_allocate_records(struct ftrace_page *pg, int count)\n{\n\tint order;\n\tint cnt;\n\n\tif (WARN_ON(!count))\n\t\treturn -EINVAL;\n\n\torder = get_count_order(DIV_ROUND_UP(count, ENTRIES_PER_PAGE));\n\n\t/*\n\t * We want to fill as much as possible. No more than a page\n\t * may be empty.\n\t */\n\twhile ((PAGE_SIZE << order) / ENTRY_SIZE >= count + ENTRIES_PER_PAGE)\n\t\torder--;\n\n again:\n\tpg->records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\n\n\tif (!pg->records) {\n\t\t/* if we can't allocate this size, try something smaller */\n\t\tif (!order)\n\t\t\treturn -ENOMEM;\n\t\torder >>= 1;\n\t\tgoto again;\n\t}\n\n\tcnt = (PAGE_SIZE << order) / ENTRY_SIZE;\n\tpg->size = cnt;\n\n\tif (cnt > count)\n\t\tcnt = count;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "ftrace_update_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2918-2972",
    "snippet": "static int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n#ifndef CC_USING_NOP_MCOUNT\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (!ftrace_code_disable(mod, p))\n\t\t\t\tbreak;\n#endif\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "582-585",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.trace_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.trace_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_code_disable",
          "args": [
            "mod",
            "p"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_code_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2513-2528",
          "snippet": "static int\nftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int ftrace_update_code(struct module *mod, struct ftrace_page *new_pgs)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *p;\n\tu64 start, stop;\n\tunsigned long update_cnt = 0;\n\tunsigned long rec_flags = 0;\n\tint i;\n\n\tstart = ftrace_now(raw_smp_processor_id());\n\n\t/*\n\t * When a module is loaded, this function is called to convert\n\t * the calls to mcount in its text to nops, and also to create\n\t * an entry in the ftrace data. Now, if ftrace is activated\n\t * after this call, but before the module sets its text to\n\t * read-only, the modification of enabling ftrace can fail if\n\t * the read-only is done while ftrace is converting the calls.\n\t * To prevent this, the module's records are set as disabled\n\t * and will be enabled after the call to set the module's text\n\t * to read-only.\n\t */\n\tif (mod)\n\t\trec_flags |= FTRACE_FL_DISABLED;\n\n\tfor (pg = new_pgs; pg; pg = pg->next) {\n\n\t\tfor (i = 0; i < pg->index; i++) {\n\n\t\t\t/* If something went wrong, bail without enabling anything */\n\t\t\tif (unlikely(ftrace_disabled))\n\t\t\t\treturn -1;\n\n\t\t\tp = &pg->records[i];\n\t\t\tp->flags = rec_flags;\n\n#ifndef CC_USING_NOP_MCOUNT\n\t\t\t/*\n\t\t\t * Do the initial record conversion from mcount jump\n\t\t\t * to the NOP instructions.\n\t\t\t */\n\t\t\tif (!ftrace_code_disable(mod, p))\n\t\t\t\tbreak;\n#endif\n\n\t\t\tupdate_cnt++;\n\t\t}\n\t}\n\n\tstop = ftrace_now(raw_smp_processor_id());\n\tftrace_update_time = stop - start;\n\tftrace_update_tot_cnt += update_cnt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ops_references_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2895-2916",
    "snippet": "static inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "ops->func_hash->notrace_hash",
            "rec->ip"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "ops->func_hash->filter_hash",
            "rec->ip"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1148-1163",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "ops->func_hash->filter_hash"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops_traces_mod",
          "args": [
            "ops"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "ops_traces_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2878-2886",
          "snippet": "static inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline bool\nops_references_rec(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\t/* If ops isn't enabled, ignore it */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/* If ops traces all then it includes this function */\n\tif (ops_traces_mod(ops))\n\t\treturn true;\n\n\t/* The function must be in the filter */\n\tif (!ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t    !__ftrace_lookup_ip(ops->func_hash->filter_hash, rec->ip))\n\t\treturn false;\n\n\t/* If in notrace hash, we ignore it too */\n\tif (ftrace_lookup_ip(ops->func_hash->notrace_hash, rec->ip))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "ops_traces_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2878-2886",
    "snippet": "static inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "ops->func_hash->notrace_hash"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int ops_traces_mod(struct ftrace_ops *ops)\n{\n\t/*\n\t * Filter_hash being empty will default to trace module.\n\t * But notrace hash requires a test of individual module functions.\n\t */\n\treturn ftrace_hash_empty(ops->func_hash->filter_hash) &&\n\t\tftrace_hash_empty(ops->func_hash->notrace_hash);\n}"
  },
  {
    "function_name": "ftrace_shutdown_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2859-2873",
    "snippet": "static void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2625-2644",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_shutdown_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* ftrace_start_up is true if ftrace is running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_DISABLE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_STOP_FUNC_RET;\n\t\tftrace_run_update_code(command);\n\t}\n}"
  },
  {
    "function_name": "ftrace_startup_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2841-2857",
    "snippet": "static void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_startup_enable",
          "args": [
            "command"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6195-6195",
          "snippet": "static inline void ftrace_startup_enable(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic void ftrace_startup_sysctl(void)\n{\n\tint command;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\t/* Force update next time */\n\tsaved_ftrace_func = NULL;\n\t/* ftrace_start_up is true if we want ftrace running */\n\tif (ftrace_start_up) {\n\t\tcommand = FTRACE_UPDATE_CALLS;\n\t\tif (ftrace_graph_active)\n\t\t\tcommand |= FTRACE_START_FUNC_RET;\n\t\tftrace_startup_enable(command);\n\t}\n}"
  },
  {
    "function_name": "ftrace_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2727-2839",
    "snippet": "static int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_ftrace_trampoline_free",
          "args": [
            "ops"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_trampoline_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2661-2663",
          "snippet": "void __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "ftrace_sync"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3151-3175",
          "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  %pS flags:%lx\\n\"",
            "(void *)rec->ip",
            "rec->flags"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "rec->flags & ~FTRACE_FL_DISABLED"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2625-2644",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_rec_disable",
          "args": [
            "ops",
            "1"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_disable_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1840-1844",
          "snippet": "static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_ipmodify_disable",
          "args": [
            "ops"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_ipmodify_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1944-1952",
          "snippet": "static void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ftrace_start_up < 0"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "378-396",
          "snippet": "static int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_shutdown(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __unregister_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up--;\n\t/*\n\t * Just warn in case of unbalance, no need to kill ftrace, it's not\n\t * critical but the ftrace_call callers may be never nopped again after\n\t * further ftrace uses.\n\t */\n\tWARN_ON_ONCE(ftrace_start_up < 0);\n\n\t/* Disabling ipmodify never fails */\n\tftrace_hash_ipmodify_disable(ops);\n\n\tif (ftrace_hash_rec_disable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled) {\n\t\t/*\n\t\t * If these are dynamic or per_cpu ops, they still\n\t\t * need their data freed. Since, function tracing is\n\t\t * not currently active, we can just free them\n\t\t * without synchronizing all CPUs.\n\t\t */\n\t\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC)\n\t\t\tgoto free_ops;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the ops uses a trampoline, then it needs to be\n\t * tested first on update.\n\t */\n\tops->flags |= FTRACE_OPS_FL_REMOVING;\n\tremoved_ops = ops;\n\n\t/* The trampoline logic checks the old hashes */\n\tops->old_hash.filter_hash = ops->func_hash->filter_hash;\n\tops->old_hash.notrace_hash = ops->func_hash->notrace_hash;\n\n\tftrace_run_update_code(command);\n\n\t/*\n\t * If there's no more ops registered with ftrace, run a\n\t * sanity check to make sure all rec flags are cleared.\n\t */\n\tif (rcu_dereference_protected(ftrace_ops_list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tstruct ftrace_page *pg;\n\t\tstruct dyn_ftrace *rec;\n\n\t\tdo_for_each_ftrace_rec(pg, rec) {\n\t\t\tif (FTRACE_WARN_ON_ONCE(rec->flags & ~FTRACE_FL_DISABLED))\n\t\t\t\tpr_warn(\"  %pS flags:%lx\\n\",\n\t\t\t\t\t(void *)rec->ip, rec->flags);\n\t\t} while_for_each_ftrace_rec();\n\t}\n\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\n\tremoved_ops = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_REMOVING;\n\n\t/*\n\t * Dynamic ops may be freed, we must make sure that all\n\t * callers are done before leaving this function.\n\t * The same goes for freeing the per_cpu data of the per_cpu\n\t * ops.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_DYNAMIC) {\n\t\t/*\n\t\t * We need to do a hard force of sched synchronization.\n\t\t * This is because we use preempt_disable() to do RCU, but\n\t\t * the function tracers can be called where RCU is not watching\n\t\t * (like before user_exit()). We can not rely on the RCU\n\t\t * infrastructure to do the synchronization, thus we must do it\n\t\t * ourselves.\n\t\t */\n\t\tschedule_on_each_cpu(ftrace_sync);\n\n\t\t/*\n\t\t * When the kernel is preeptive, tasks can be preempted\n\t\t * while on a ftrace trampoline. Just scheduling a task on\n\t\t * a CPU is not good enough to flush them. Calling\n\t\t * synchornize_rcu_tasks() will wait for those tasks to\n\t\t * execute and either schedule voluntarily or enter user space.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\t\tsynchronize_rcu_tasks();\n\n free_ops:\n\t\tarch_ftrace_trampoline_free(ops);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_startup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2685-2725",
    "snippet": "static int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static int ftrace_disabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_startup_enable",
          "args": [
            "command"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6195-6195",
          "snippet": "static inline void ftrace_startup_enable(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_rec_enable",
          "args": [
            "ops",
            "1"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_enable_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1846-1850",
          "snippet": "static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "378-396",
          "snippet": "static int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_ipmodify_enable",
          "args": [
            "ops"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_ipmodify_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1933-1941",
          "snippet": "static int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "__register_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "337-376",
          "snippet": "static int __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\n\tif (!core_kernel_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\n\tif (!core_kernel_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tret = __register_ftrace_function(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tftrace_start_up++;\n\n\t/*\n\t * Note that ftrace probes uses this to start up\n\t * and modify functions it will probe. But we still\n\t * set the ADDING flag for modification, as probes\n\t * do not have trampolines. If they add them in the\n\t * future, then the probes will need to distinguish\n\t * between adding and updating probes.\n\t */\n\tops->flags |= FTRACE_OPS_FL_ENABLED | FTRACE_OPS_FL_ADDING;\n\n\tret = ftrace_hash_ipmodify_enable(ops);\n\tif (ret < 0) {\n\t\t/* Rollback registration process */\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->flags &= ~FTRACE_OPS_FL_ENABLED;\n\t\treturn ret;\n\t}\n\n\tif (ftrace_hash_rec_enable(ops, 1))\n\t\tcommand |= FTRACE_UPDATE_CALLS;\n\n\tftrace_startup_enable(command);\n\n\tops->flags &= ~FTRACE_OPS_FL_ADDING;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_startup_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2678-2683",
    "snippet": "static void ftrace_startup_all(int command)\n{\n\tupdate_all_ops = true;\n\tftrace_startup_enable(command);\n\tupdate_all_ops = false;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_startup_enable",
          "args": [
            "command"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_startup_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6195-6195",
          "snippet": "static inline void ftrace_startup_enable(int command) { }",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void ftrace_startup_enable(int command) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_startup_all(int command)\n{\n\tupdate_all_ops = true;\n\tftrace_startup_enable(command);\n\tupdate_all_ops = false;\n}"
  },
  {
    "function_name": "ftrace_startup_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2665-2676",
    "snippet": "static void ftrace_startup_enable(int command)\n{\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled)\n\t\treturn;\n\n\tftrace_run_update_code(command);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2625-2644",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_startup_enable(int command)\n{\n\tif (saved_ftrace_func != ftrace_trace_function) {\n\t\tsaved_ftrace_func = ftrace_trace_function;\n\t\tcommand |= FTRACE_UPDATE_TRACE_FUNC;\n\t}\n\n\tif (!command || !ftrace_enabled)\n\t\treturn;\n\n\tftrace_run_update_code(command);\n}"
  },
  {
    "function_name": "arch_ftrace_trampoline_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2661-2663",
    "snippet": "void __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __weak arch_ftrace_trampoline_free(struct ftrace_ops *ops)\n{\n}"
  },
  {
    "function_name": "ftrace_run_modify_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2646-2656",
    "snippet": "static void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_update_code",
          "args": [
            "command"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2625-2644",
          "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_run_modify_code(struct ftrace_ops *ops, int command,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tops->flags |= FTRACE_OPS_FL_MODIFYING;\n\tops->old_hash.filter_hash = old_hash->filter_hash;\n\tops->old_hash.notrace_hash = old_hash->notrace_hash;\n\tftrace_run_update_code(command);\n\tops->old_hash.filter_hash = NULL;\n\tops->old_hash.notrace_hash = NULL;\n\tops->flags &= ~FTRACE_OPS_FL_MODIFYING;\n}"
  },
  {
    "function_name": "ftrace_run_update_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2625-2644",
    "snippet": "static void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_post_process",
          "args": [],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_post_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2543-2546",
          "snippet": "int __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ftrace_update_code",
          "args": [
            "command"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "arch_ftrace_update_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2620-2623",
          "snippet": "void __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ret"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_arch_code_modify_prepare",
          "args": [],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_arch_code_modify_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2534-2537",
          "snippet": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_run_update_code(int command)\n{\n\tint ret;\n\n\tret = ftrace_arch_code_modify_prepare();\n\tFTRACE_WARN_ON(ret);\n\tif (ret)\n\t\treturn;\n\n\t/*\n\t * By default we use stop_machine() to modify the code.\n\t * But archs can do what ever they want as long as it\n\t * is safe. The stop_machine() is the safest, but also\n\t * produces the most overhead.\n\t */\n\tarch_ftrace_update_code(command);\n\n\tret = ftrace_arch_code_modify_post_process();\n\tFTRACE_WARN_ON(ret);\n}"
  },
  {
    "function_name": "arch_ftrace_update_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2620-2623",
    "snippet": "void __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_run_stop_machine",
          "args": [
            "command"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_run_stop_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2608-2611",
          "snippet": "void ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid __weak arch_ftrace_update_code(int command)\n{\n\tftrace_run_stop_machine(command);\n}"
  },
  {
    "function_name": "ftrace_run_stop_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2608-2611",
    "snippet": "void ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_machine",
          "args": [
            "__ftrace_modify_code",
            "&command",
            "NULL"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_from_inactive_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "653-682",
          "snippet": "int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(stop_cpus_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nint stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_run_stop_machine(int command)\n{\n\tstop_machine(__ftrace_modify_code, &command, NULL);\n}"
  },
  {
    "function_name": "__ftrace_modify_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2592-2599",
    "snippet": "static int __ftrace_modify_code(void *data)\n{\n\tint *command = data;\n\n\tftrace_modify_all_code(*command);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_all_code",
          "args": [
            "*command"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_all_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2548-2590",
          "snippet": "void ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint err = 0;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(1);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(0);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
          ],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint err = 0;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(1);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(0);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int __ftrace_modify_code(void *data)\n{\n\tint *command = data;\n\n\tftrace_modify_all_code(*command);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_modify_all_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2548-2590",
    "snippet": "void ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint err = 0;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(1);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(0);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
    ],
    "globals_used": [
      "struct ftrace_ops *function_trace_op",
      "static struct ftrace_ops *set_function_trace_op;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "ftrace_func_t ftrace_trace_function",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "err"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_disable_ftrace_graph_caller",
          "args": [],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_enable_ftrace_graph_caller",
          "args": [],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "err"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_ftrace_func",
          "args": [
            "ftrace_trace_function"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "ftrace_sync_ipi",
            "NULL",
            "1"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "489-496",
          "snippet": "int smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_replace_code",
          "args": [
            "0"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_replace_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2418-2439",
          "snippet": "void __weak ftrace_replace_code(int enable)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_rec();\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid __weak ftrace_replace_code(int enable)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_rec();\n}"
        }
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "err"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_ftrace_func",
          "args": [
            "ftrace_ops_list_func"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_modify_all_code(int command)\n{\n\tint update = command & FTRACE_UPDATE_TRACE_FUNC;\n\tint err = 0;\n\n\t/*\n\t * If the ftrace_caller calls a ftrace_ops func directly,\n\t * we need to make sure that it only traces functions it\n\t * expects to trace. When doing the switch of functions,\n\t * we need to update to the ftrace_ops_list_func first\n\t * before the transition between old and new calls are set,\n\t * as the ftrace_ops_list_func will check the ops hashes\n\t * to make sure the ops are having the right functions\n\t * traced.\n\t */\n\tif (update) {\n\t\terr = ftrace_update_ftrace_func(ftrace_ops_list_func);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_UPDATE_CALLS)\n\t\tftrace_replace_code(1);\n\telse if (command & FTRACE_DISABLE_CALLS)\n\t\tftrace_replace_code(0);\n\n\tif (update && ftrace_trace_function != ftrace_ops_list_func) {\n\t\tfunction_trace_op = set_function_trace_op;\n\t\tsmp_wmb();\n\t\t/* If irqs are disabled, we are in stop machine */\n\t\tif (!irqs_disabled())\n\t\t\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t\terr = ftrace_update_ftrace_func(ftrace_trace_function);\n\t\tif (FTRACE_WARN_ON(err))\n\t\t\treturn;\n\t}\n\n\tif (command & FTRACE_START_FUNC_RET)\n\t\terr = ftrace_enable_ftrace_graph_caller();\n\telse if (command & FTRACE_STOP_FUNC_RET)\n\t\terr = ftrace_disable_ftrace_graph_caller();\n\tFTRACE_WARN_ON(err);\n}"
  },
  {
    "function_name": "ftrace_arch_code_modify_post_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2543-2546",
    "snippet": "int __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_post_process(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_arch_code_modify_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2534-2537",
    "snippet": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_code_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2513-2528",
    "snippet": "static int\nftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "ret",
            "rec"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2018-2072",
          "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_make_nop",
          "args": [
            "mod",
            "rec",
            "MCOUNT_ADDR"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nstatic int\nftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)\n{\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn 0;\n\n\tret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);\n\tif (ret) {\n\t\tftrace_bug_type = FTRACE_BUG_INIT;\n\t\tftrace_bug(ret, rec);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_rec_iter_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2508-2511",
    "snippet": "struct dyn_ftrace *ftrace_rec_iter_record(struct ftrace_rec_iter *iter)\n{\n\treturn &iter->pg->records[iter->index];\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct dyn_ftrace *ftrace_rec_iter_record(struct ftrace_rec_iter *iter)\n{\n\treturn &iter->pg->records[iter->index];\n}"
  },
  {
    "function_name": "ftrace_rec_iter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2483-2500",
    "snippet": "struct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ftrace_rec_iter_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2455-2475",
    "snippet": "struct ftrace_rec_iter *ftrace_rec_iter_start(void)\n{\n\t/*\n\t * We only use a single iterator.\n\t * Protected by the ftrace_lock mutex.\n\t */\n\tstatic struct ftrace_rec_iter ftrace_rec_iter;\n\tstruct ftrace_rec_iter *iter = &ftrace_rec_iter;\n\n\titer->pg = ftrace_pages_start;\n\titer->index = 0;\n\n\t/* Could have empty pages */\n\twhile (iter->pg && !iter->pg->index)\n\t\titer->pg = iter->pg->next;\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstruct ftrace_rec_iter *ftrace_rec_iter_start(void)\n{\n\t/*\n\t * We only use a single iterator.\n\t * Protected by the ftrace_lock mutex.\n\t */\n\tstatic struct ftrace_rec_iter ftrace_rec_iter;\n\tstruct ftrace_rec_iter *iter = &ftrace_rec_iter;\n\n\titer->pg = ftrace_pages_start;\n\titer->index = 0;\n\n\t/* Could have empty pages */\n\twhile (iter->pg && !iter->pg->index)\n\t\titer->pg = iter->pg->next;\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}"
  },
  {
    "function_name": "ftrace_replace_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2418-2439",
    "snippet": "void __weak ftrace_replace_code(int enable)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_rec();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_bug",
          "args": [
            "failed",
            "rec"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2018-2072",
          "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_replace_code",
          "args": [
            "rec",
            "enable"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_replace_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2382-2416",
          "snippet": "static int\n__ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknow ftrace bug */\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\n__ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknow ftrace bug */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_disabled"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_disabled;\n\nvoid __weak ftrace_replace_code(int enable)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tint failed;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tfailed = __ftrace_replace_code(rec, enable);\n\t\tif (failed) {\n\t\t\tftrace_bug(failed, rec);\n\t\t\t/* Stop processing */\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_rec();\n}"
  },
  {
    "function_name": "__ftrace_replace_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2382-2416",
    "snippet": "static int\n__ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknow ftrace bug */\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_call",
          "args": [
            "rec",
            "ftrace_old_addr",
            "ftrace_addr"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_make_nop",
          "args": [
            "NULL",
            "rec",
            "ftrace_old_addr"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_make_call",
          "args": [
            "rec",
            "ftrace_addr"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_record",
          "args": [
            "rec",
            "enable"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2178-2181",
          "snippet": "int ftrace_update_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_update_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_addr_curr",
          "args": [
            "rec"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_addr_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2360-2380",
          "snippet": "unsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_addr_new",
          "args": [
            "rec"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_addr_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2328-2348",
          "snippet": "unsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int\n__ftrace_replace_code(struct dyn_ftrace *rec, int enable)\n{\n\tunsigned long ftrace_old_addr;\n\tunsigned long ftrace_addr;\n\tint ret;\n\n\tftrace_addr = ftrace_get_addr_new(rec);\n\n\t/* This needs to be done before we call ftrace_update_record */\n\tftrace_old_addr = ftrace_get_addr_curr(rec);\n\n\tret = ftrace_update_record(rec, enable);\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tswitch (ret) {\n\tcase FTRACE_UPDATE_IGNORE:\n\t\treturn 0;\n\n\tcase FTRACE_UPDATE_MAKE_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\treturn ftrace_make_call(rec, ftrace_addr);\n\n\tcase FTRACE_UPDATE_MAKE_NOP:\n\t\tftrace_bug_type = FTRACE_BUG_NOP;\n\t\treturn ftrace_make_nop(NULL, rec, ftrace_old_addr);\n\n\tcase FTRACE_UPDATE_MODIFY_CALL:\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn ftrace_modify_call(rec, ftrace_old_addr, ftrace_addr);\n\t}\n\n\treturn -1; /* unknow ftrace bug */\n}"
  },
  {
    "function_name": "ftrace_get_addr_curr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2360-2380",
    "snippet": "unsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Bad trampoline accounting at: %p (%pS)\\n\"",
            "(void *)rec->ip",
            "(void *)rec->ip"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "!ops"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_curr",
          "args": [
            "rec"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2233-2301",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
  },
  {
    "function_name": "ftrace_get_addr_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2328-2348",
    "snippet": "unsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\"",
            "(void *)rec->ip",
            "(void *)rec->ip",
            "rec->flags"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "!ops || !ops->trampoline"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_new",
          "args": [
            "rec"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2303-2316",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP) {\n\t\tops = ftrace_find_tramp_ops_new(rec);\n\t\tif (FTRACE_WARN_ON(!ops || !ops->trampoline)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS) (%lx)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip, rec->flags);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2303-2316",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1479-1492",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_new(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_curr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2233-2301",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1479-1492",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\t/*\n\t * Need to check removed ops first.\n\t * If they are being removed, and this rec has a tramp,\n\t * and this rec is in the ops list, then it would be the\n\t * one with the tramp.\n\t */\n\tif (removed_ops) {\n\t\tif (hash_contains_ip(ip, &removed_ops->old_hash))\n\t\t\treturn removed_ops;\n\t}\n\n\t/*\n\t * Need to find the current trampoline for a rec.\n\t * Now, a trampoline is only attached to a rec if there\n\t * was a single 'ops' attached to it. But this can be called\n\t * when we are adding another op to the rec or removing the\n\t * current one. Thus, if the op is being added, we can\n\t * ignore it because it hasn't attached itself to the rec\n\t * yet.\n\t *\n\t * If an ops is being modified (hooking to different functions)\n\t * then we don't care about the new functions that are being\n\t * added, just the old ones (that are probably being removed).\n\t *\n\t * If we are adding an ops to a function that already is using\n\t * a trampoline, it needs to be removed (trampolines are only\n\t * for single ops connected), then an ops that is not being\n\t * modified also needs to be checked.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the ops is being added, it hasn't gotten to\n\t\t * the point to be removed from this tree yet.\n\t\t */\n\t\tif (op->flags & FTRACE_OPS_FL_ADDING)\n\t\t\tcontinue;\n\n\n\t\t/*\n\t\t * If the ops is being modified and is in the old\n\t\t * hash, then it is probably being removed from this\n\t\t * function.\n\t\t */\n\t\tif ((op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, &op->old_hash))\n\t\t\treturn op;\n\t\t/*\n\t\t * If the ops is not being added or modified, and it's\n\t\t * in its normal filter hash, then this must be the one\n\t\t * we want!\n\t\t */\n\t\tif (!(op->flags & FTRACE_OPS_FL_MODIFYING) &&\n\t\t    hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2215-2231",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} \n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1479-1492",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} \n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_find_tramp_ops_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2197-2213",
    "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops __rcu *ftrace_ops_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "op->func_hash"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1479-1492",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_test_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2192-2195",
    "snippet": "int ftrace_test_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_check_record",
          "args": [
            "rec",
            "enable",
            "0"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_check_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2074-2168",
          "snippet": "static int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) != \n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) != \n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) != \n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) != \n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_test_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 0);\n}"
  },
  {
    "function_name": "ftrace_update_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2178-2181",
    "snippet": "int ftrace_update_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_check_record",
          "args": [
            "rec",
            "enable",
            "1"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_check_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2074-2168",
          "snippet": "static int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) != \n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) != \n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) != \n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) != \n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_update_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 1);\n}"
  },
  {
    "function_name": "ftrace_check_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2074-2168",
    "snippet": "static int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) != \n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) != \n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_check_record(struct dyn_ftrace *rec, int enable, int update)\n{\n\tunsigned long flag = 0UL;\n\n\tftrace_bug_type = FTRACE_BUG_UNKNOWN;\n\n\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\t/*\n\t * If we are updating calls:\n\t *\n\t *   If the record has a ref count, then we need to enable it\n\t *   because someone is using it.\n\t *\n\t *   Otherwise we make sure its disabled.\n\t *\n\t * If we are disabling calls, then disable all records that\n\t * are enabled.\n\t */\n\tif (enable && ftrace_rec_count(rec))\n\t\tflag = FTRACE_FL_ENABLED;\n\n\t/*\n\t * If enabling and the REGS flag does not match the REGS_EN, or\n\t * the TRAMP flag doesn't match the TRAMP_EN, then do not ignore\n\t * this record. Set flags to fail the compare against ENABLED.\n\t */\n\tif (flag) {\n\t\tif (!(rec->flags & FTRACE_FL_REGS) != \n\t\t    !(rec->flags & FTRACE_FL_REGS_EN))\n\t\t\tflag |= FTRACE_FL_REGS;\n\n\t\tif (!(rec->flags & FTRACE_FL_TRAMP) != \n\t\t    !(rec->flags & FTRACE_FL_TRAMP_EN))\n\t\t\tflag |= FTRACE_FL_TRAMP;\n\t}\n\n\t/* If the state of this record hasn't changed, then do nothing */\n\tif ((rec->flags & FTRACE_FL_ENABLED) == flag)\n\t\treturn FTRACE_UPDATE_IGNORE;\n\n\tif (flag) {\n\t\t/* Save off if rec is being enabled (for return value) */\n\t\tflag ^= rec->flags & FTRACE_FL_ENABLED;\n\n\t\tif (update) {\n\t\t\trec->flags |= FTRACE_FL_ENABLED;\n\t\t\tif (flag & FTRACE_FL_REGS) {\n\t\t\t\tif (rec->flags & FTRACE_FL_REGS)\n\t\t\t\t\trec->flags |= FTRACE_FL_REGS_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS_EN;\n\t\t\t}\n\t\t\tif (flag & FTRACE_FL_TRAMP) {\n\t\t\t\tif (rec->flags & FTRACE_FL_TRAMP)\n\t\t\t\t\trec->flags |= FTRACE_FL_TRAMP_EN;\n\t\t\t\telse\n\t\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP_EN;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If this record is being updated from a nop, then\n\t\t *   return UPDATE_MAKE_CALL.\n\t\t * Otherwise,\n\t\t *   return UPDATE_MODIFY_CALL to tell the caller to convert\n\t\t *   from the save regs, to a non-save regs function or\n\t\t *   vice versa, or from a trampoline call.\n\t\t */\n\t\tif (flag & FTRACE_FL_ENABLED) {\n\t\t\tftrace_bug_type = FTRACE_BUG_CALL;\n\t\t\treturn FTRACE_UPDATE_MAKE_CALL;\n\t\t}\n\n\t\tftrace_bug_type = FTRACE_BUG_UPDATE;\n\t\treturn FTRACE_UPDATE_MODIFY_CALL;\n\t}\n\n\tif (update) {\n\t\t/* If there's no more users, clear all flags */\n\t\tif (!ftrace_rec_count(rec))\n\t\t\trec->flags = 0;\n\t\telse\n\t\t\t/*\n\t\t\t * Just disable the record, but keep the ops TRAMP\n\t\t\t * and REGS states. The _EN flags must be disabled though.\n\t\t\t */\n\t\t\trec->flags &= ~(FTRACE_FL_ENABLED | FTRACE_FL_TRAMP_EN |\n\t\t\t\t\tFTRACE_FL_REGS_EN);\n\t}\n\n\tftrace_bug_type = FTRACE_BUG_NOP;\n\treturn FTRACE_UPDATE_MAKE_NOP;\n}"
  },
  {
    "function_name": "ftrace_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "2018-2072",
    "snippet": "void ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n expected tramp: %lx\\n\"",
            "ip"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_get_addr_curr",
          "args": [
            "rec"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_get_addr_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2360-2380",
          "snippet": "unsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nunsigned long ftrace_get_addr_curr(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\n\t/* Trampolines take precedence over regs */\n\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\tops = ftrace_find_tramp_ops_curr(rec);\n\t\tif (FTRACE_WARN_ON(!ops)) {\n\t\t\tpr_warn(\"Bad trampoline accounting at: %p (%pS)\\n\",\n\t\t\t\t(void *)rec->ip, (void *)rec->ip);\n\t\t\t/* Ftrace is shutting down, return anything */\n\t\t\treturn (unsigned long)FTRACE_ADDR;\n\t\t}\n\t\treturn ops->trampoline;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS_EN)\n\t\treturn (unsigned long)FTRACE_REGS_ADDR;\n\telse\n\t\treturn (unsigned long)FTRACE_ADDR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\ttramp: ERROR!\""
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_next",
          "args": [
            "rec",
            "ops"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2215-2231",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} \n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_next(struct dyn_ftrace *rec,\n\t\t\t   struct ftrace_ops *op)\n{\n\tunsigned long ip = rec->ip;\n\n\twhile_for_each_ftrace_op(op) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} \n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\ttramp: %pS (%pS)\"",
            "(void *)ops->trampoline",
            "(void *)ops->func"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_tramp_ops_any",
          "args": [
            "rec"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_tramp_ops_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2197-2213",
          "snippet": "static struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ftrace_ops __rcu *ftrace_ops_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *op;\n\tunsigned long ip = rec->ip;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\n\t\tif (!op->trampoline)\n\t\t\tcontinue;\n\n\t\tif (hash_contains_ip(ip, op->func_hash))\n\t\t\treturn op;\n\t} while_for_each_ftrace_op(op);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" (%ld)%s\"",
            "ftrace_rec_count(rec)",
            "rec->flags & FTRACE_FL_REGS ? \" R\" : \"  \""
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace record flags: %lx\\n\"",
            "rec->flags"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bug_type",
          "args": [],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "print_bug_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1986-2004",
          "snippet": "static void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "ip"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace faulted on unknown error \""
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "ip"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace faulted on writing \""
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_ins",
          "args": [
            "\" expected: \"",
            "ftrace_expected"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "print_ip_ins",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1968-1976",
          "snippet": "static void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tint i;\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", p[i]);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tint i;\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", p[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "ip"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace failed to modify \""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "ip"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ftrace faulted on modifying \""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->ip : 0;\n\n\tswitch (failed) {\n\tcase -EFAULT:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on modifying \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace failed to modify \");\n\t\tprint_ip_sym(ip);\n\t\tprint_ip_ins(\" actual:   \", (unsigned char *)ip);\n\t\tpr_cont(\"\\n\");\n\t\tif (ftrace_expected) {\n\t\t\tprint_ip_ins(\" expected: \", ftrace_expected);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase -EPERM:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on writing \");\n\t\tprint_ip_sym(ip);\n\t\tbreak;\n\tdefault:\n\t\tFTRACE_WARN_ON_ONCE(1);\n\t\tpr_info(\"ftrace faulted on unknown error \");\n\t\tprint_ip_sym(ip);\n\t}\n\tprint_bug_type();\n\tif (rec) {\n\t\tstruct ftrace_ops *ops = NULL;\n\n\t\tpr_info(\"ftrace record flags: %lx\\n\", rec->flags);\n\t\tpr_cont(\" (%ld)%s\", ftrace_rec_count(rec),\n\t\t\trec->flags & FTRACE_FL_REGS ? \" R\" : \"  \");\n\t\tif (rec->flags & FTRACE_FL_TRAMP_EN) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops) {\n\t\t\t\tdo {\n\t\t\t\t\tpr_cont(\"\\ttramp: %pS (%pS)\",\n\t\t\t\t\t\t(void *)ops->trampoline,\n\t\t\t\t\t\t(void *)ops->func);\n\t\t\t\t\tops = ftrace_find_tramp_ops_next(rec, ops);\n\t\t\t\t} while (ops);\n\t\t\t} else\n\t\t\t\tpr_cont(\"\\ttramp: ERROR!\");\n\n\t\t}\n\t\tip = ftrace_get_addr_curr(rec);\n\t\tpr_cont(\"\\n expected tramp: %lx\\n\", ip);\n\t}\n}"
  },
  {
    "function_name": "print_bug_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1986-2004",
    "snippet": "static void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Updating ftrace call site to call a different ftrace function\\n\""
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting ftrace call site to call ftrace function\\n\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting ftrace call site to NOP\\n\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Initializing ftrace call sites\\n\""
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_bug_type(void)\n{\n\tswitch (ftrace_bug_type) {\n\tcase FTRACE_BUG_UNKNOWN:\n\t\tbreak;\n\tcase FTRACE_BUG_INIT:\n\t\tpr_info(\"Initializing ftrace call sites\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_NOP:\n\t\tpr_info(\"Setting ftrace call site to NOP\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_CALL:\n\t\tpr_info(\"Setting ftrace call site to call ftrace function\\n\");\n\t\tbreak;\n\tcase FTRACE_BUG_UPDATE:\n\t\tpr_info(\"Updating ftrace call site to call a different ftrace function\\n\");\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "print_ip_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1968-1976",
    "snippet": "static void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tint i;\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", p[i]);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s%02x\"",
            "i ? \":\" : \"\"",
            "p[i]"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "229-241",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s\"",
            "fmt"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void print_ip_ins(const char *fmt, const unsigned char *p)\n{\n\tint i;\n\n\tprintk(KERN_CONT \"%s\", fmt);\n\n\tfor (i = 0; i < MCOUNT_INSN_SIZE; i++)\n\t\tprintk(KERN_CONT \"%s%02x\", i ? \":\" : \"\", p[i]);\n}"
  },
  {
    "function_name": "ftrace_hash_ipmodify_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1954-1966",
    "snippet": "static int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_update_ipmodify",
          "args": [
            "ops",
            "old_hash",
            "new_hash"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_update_ipmodify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1861-1931",
          "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "new_hash"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}"
  },
  {
    "function_name": "ftrace_hash_ipmodify_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1944-1952",
    "snippet": "static void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_update_ipmodify",
          "args": [
            "ops",
            "hash",
            "EMPTY_HASH"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_update_ipmodify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1861-1931",
          "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_ipmodify_disable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\t__ftrace_hash_update_ipmodify(ops, hash, EMPTY_HASH);\n}"
  },
  {
    "function_name": "ftrace_hash_ipmodify_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1933-1941",
    "snippet": "static int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_update_ipmodify",
          "args": [
            "ops",
            "EMPTY_HASH",
            "hash"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_update_ipmodify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1861-1931",
          "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_enable(struct ftrace_ops *ops)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(hash))\n\t\thash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, EMPTY_HASH, hash);\n}"
  },
  {
    "function_name": "__ftrace_hash_update_ipmodify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1861-1931",
    "snippet": "static int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "new_hash",
            "rec->ip"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __ftrace_hash_update_ipmodify(struct ftrace_ops *ops,\n\t\t\t\t\t struct ftrace_hash *old_hash,\n\t\t\t\t\t struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec, *end = NULL;\n\tint in_old, in_new;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn 0;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_IPMODIFY))\n\t\treturn 0;\n\n\t/*\n\t * Since the IPMODIFY is a very address sensitive action, we do not\n\t * allow ftrace_ops to set all functions to new hash.\n\t */\n\tif (!new_hash || !old_hash)\n\t\treturn -EINVAL;\n\n\t/* Update rec->flags */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* We need to update only differences of filter_hash */\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new) {\n\t\t\t/* New entries must ensure no others are using it */\n\t\t\tif (rec->flags & FTRACE_FL_IPMODIFY)\n\t\t\t\tgoto rollback;\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t\t} else /* Removed entry */\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\n\treturn 0;\n\nrollback:\n\tend = rec;\n\n\t/* Roll back what we did above */\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (rec == end)\n\t\t\tgoto err_out;\n\n\t\tin_old = !!ftrace_lookup_ip(old_hash, rec->ip);\n\t\tin_new = !!ftrace_lookup_ip(new_hash, rec->ip);\n\t\tif (in_old == in_new)\n\t\t\tcontinue;\n\n\t\tif (in_new)\n\t\t\trec->flags &= ~FTRACE_FL_IPMODIFY;\n\t\telse\n\t\t\trec->flags |= FTRACE_FL_IPMODIFY;\n\t} while_for_each_ftrace_rec();\n\nerr_out:\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "ftrace_hash_rec_enable_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1846-1850",
    "snippet": "static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_rec_update_modify",
          "args": [
            "ops",
            "filter_hash",
            "1"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_update_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1817-1838",
          "snippet": "static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_disable_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1840-1844",
    "snippet": "static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_rec_update_modify",
          "args": [
            "ops",
            "filter_hash",
            "0"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_update_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1817-1838",
          "snippet": "static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_update_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1817-1838",
    "snippet": "static void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static struct ftrace_ops global_ops;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_hash_rec_update",
          "args": [
            "op",
            "filter_hash",
            "inc"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_rec_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1649-1803",
          "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_update_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash, int inc)\n{\n\tstruct ftrace_ops *op;\n\n\t__ftrace_hash_rec_update(ops, filter_hash, inc);\n\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\t/*\n\t * If the ops shares the global_ops hash, then we need to update\n\t * all ops that are enabled and use this hash.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/* Already done */\n\t\tif (op == ops)\n\t\t\tcontinue;\n\t\tif (op->func_hash == &global_ops.local_hash)\n\t\t\t__ftrace_hash_rec_update(op, filter_hash, inc);\n\t} while_for_each_ftrace_op(op);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1811-1815",
    "snippet": "static bool ftrace_hash_rec_enable(struct ftrace_ops *ops,\n\t\t\t\t   int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 1);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_rec_update",
          "args": [
            "ops",
            "filter_hash",
            "1"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_rec_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1649-1803",
          "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_hash_rec_enable(struct ftrace_ops *ops,\n\t\t\t\t   int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 1);\n}"
  },
  {
    "function_name": "ftrace_hash_rec_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1805-1809",
    "snippet": "static bool ftrace_hash_rec_disable(struct ftrace_ops *ops,\n\t\t\t\t    int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_hash_rec_update",
          "args": [
            "ops",
            "filter_hash",
            "0"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_rec_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1649-1803",
          "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_hash_rec_disable(struct ftrace_ops *ops,\n\t\t\t\t    int filter_hash)\n{\n\treturn __ftrace_hash_rec_update(ops, filter_hash, 0);\n}"
  },
  {
    "function_name": "__ftrace_hash_rec_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1649-1803",
    "snippet": "static bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_ftrace_rec",
          "args": [],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_test_record",
          "args": [
            "rec",
            "1"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_test_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "2192-2195",
          "snippet": "int ftrace_test_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_test_record(struct dyn_ftrace *rec, int enable)\n{\n\treturn ftrace_check_record(rec, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_rec_ops_needs_regs",
          "args": [
            "rec"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "test_rec_ops_needs_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1630-1647",
          "snippet": "static bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ftrace_rec_count(rec) == 0"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "ftrace_rec_count(rec) == FTRACE_REF_MAX"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_rec_count",
          "args": [
            "rec"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "other_hash"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_lookup_ip",
          "args": [
            "other_hash",
            "rec->ip"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1175-1182",
          "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_rec",
          "args": [
            "pg",
            "rec"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool __ftrace_hash_rec_update(struct ftrace_ops *ops,\n\t\t\t\t     int filter_hash,\n\t\t\t\t     bool inc)\n{\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_hash *other_hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tbool update = false;\n\tint count = 0;\n\tint all = false;\n\n\t/* Only update if the ops has been registered */\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn false;\n\n\t/*\n\t * In the filter_hash case:\n\t *   If the count is zero, we update all records.\n\t *   Otherwise we just update the items in the hash.\n\t *\n\t * In the notrace_hash case:\n\t *   We enable the update in the hash.\n\t *   As disabling notrace means enabling the tracing,\n\t *   and enabling notrace means disabling, the inc variable\n\t *   gets inversed.\n\t */\n\tif (filter_hash) {\n\t\thash = ops->func_hash->filter_hash;\n\t\tother_hash = ops->func_hash->notrace_hash;\n\t\tif (ftrace_hash_empty(hash))\n\t\t\tall = true;\n\t} else {\n\t\tinc = !inc;\n\t\thash = ops->func_hash->notrace_hash;\n\t\tother_hash = ops->func_hash->filter_hash;\n\t\t/*\n\t\t * If the notrace hash has no items,\n\t\t * then there's nothing to do.\n\t\t */\n\t\tif (ftrace_hash_empty(hash))\n\t\t\treturn false;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tint in_other_hash = 0;\n\t\tint in_hash = 0;\n\t\tint match = 0;\n\n\t\tif (rec->flags & FTRACE_FL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (all) {\n\t\t\t/*\n\t\t\t * Only the filter_hash affects all records.\n\t\t\t * Update if the record is not in the notrace hash.\n\t\t\t */\n\t\t\tif (!other_hash || !ftrace_lookup_ip(other_hash, rec->ip))\n\t\t\t\tmatch = 1;\n\t\t} else {\n\t\t\tin_hash = !!ftrace_lookup_ip(hash, rec->ip);\n\t\t\tin_other_hash = !!ftrace_lookup_ip(other_hash, rec->ip);\n\n\t\t\t/*\n\t\t\t * If filter_hash is set, we want to match all functions\n\t\t\t * that are in the hash but not in the other hash.\n\t\t\t *\n\t\t\t * If filter_hash is not set, then we are decrementing.\n\t\t\t * That means we match anything that is in the hash\n\t\t\t * and also in the other_hash. That is, we need to turn\n\t\t\t * off functions in the other hash because they are disabled\n\t\t\t * by this hash.\n\t\t\t */\n\t\t\tif (filter_hash && in_hash && !in_other_hash)\n\t\t\t\tmatch = 1;\n\t\t\telse if (!filter_hash && in_hash &&\n\t\t\t\t (in_other_hash || ftrace_hash_empty(other_hash)))\n\t\t\t\tmatch = 1;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (inc) {\n\t\t\trec->flags++;\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == FTRACE_REF_MAX))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If there's only a single callback registered to a\n\t\t\t * function, and the ops has a trampoline registered\n\t\t\t * for it, then we can call it directly.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) == 1 && ops->trampoline)\n\t\t\t\trec->flags |= FTRACE_FL_TRAMP;\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * If we are adding another function callback\n\t\t\t\t * to this function, and the previous had a\n\t\t\t\t * custom trampoline in use, then we need to go\n\t\t\t\t * back to the default trampoline.\n\t\t\t\t */\n\t\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * If any ops wants regs saved for this function\n\t\t\t * then all ops will get saved regs.\n\t\t\t */\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS)\n\t\t\t\trec->flags |= FTRACE_FL_REGS;\n\t\t} else {\n\t\t\tif (FTRACE_WARN_ON(ftrace_rec_count(rec) == 0))\n\t\t\t\treturn false;\n\t\t\trec->flags--;\n\n\t\t\t/*\n\t\t\t * If the rec had REGS enabled and the ops that is\n\t\t\t * being removed had REGS set, then see if there is\n\t\t\t * still any ops for this record that wants regs.\n\t\t\t * If not, we can stop recording them.\n\t\t\t */\n\t\t\tif (ftrace_rec_count(rec) > 0 &&\n\t\t\t    rec->flags & FTRACE_FL_REGS &&\n\t\t\t    ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tif (!test_rec_ops_needs_regs(rec))\n\t\t\t\t\trec->flags &= ~FTRACE_FL_REGS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the rec had TRAMP enabled, then it needs to\n\t\t\t * be cleared. As TRAMP can only be enabled iff\n\t\t\t * there is only a single ops attached to it.\n\t\t\t * In otherwords, always disable it on decrementing.\n\t\t\t * In the future, we may set it if rec count is\n\t\t\t * decremented to one, and the ops that is left\n\t\t\t * has a trampoline.\n\t\t\t */\n\t\t\trec->flags &= ~FTRACE_FL_TRAMP;\n\n\t\t\t/*\n\t\t\t * flags will be cleared in ftrace_check_record()\n\t\t\t * if rec count is zero.\n\t\t\t */\n\t\t}\n\t\tcount++;\n\n\t\t/* Must match FTRACE_UPDATE_CALLS in ftrace_modify_all_code() */\n\t\tupdate |= ftrace_test_record(rec, 1) != FTRACE_UPDATE_IGNORE;\n\n\t\t/* Shortcut, if we handled all records, we are done. */\n\t\tif (!all && count == hash->count)\n\t\t\treturn update;\n\t} while_for_each_ftrace_rec();\n\n\treturn update;\n}"
  },
  {
    "function_name": "test_rec_ops_needs_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1630-1647",
    "snippet": "static bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_test",
          "args": [
            "ops",
            "rec->ip",
            "rec"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6216-6220",
          "snippet": "static inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool test_rec_ops_needs_regs(struct dyn_ftrace *rec)\n{\n\tstruct ftrace_ops *ops;\n\tbool keep_regs = false;\n\n\tfor (ops = ftrace_ops_list;\n\t     ops != &ftrace_list_end; ops = ops->next) {\n\t\t/* pass rec in as regs to have non-NULL val */\n\t\tif (ftrace_ops_test(ops, rec->ip, rec)) {\n\t\t\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {\n\t\t\t\tkeep_regs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn  keep_regs;\n}"
  },
  {
    "function_name": "ftrace_text_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1619-1627",
    "snippet": "int ftrace_text_reserved(const void *start, const void *end)\n{\n\tunsigned long ret;\n\n\tret = ftrace_location_range((unsigned long)start,\n\t\t\t\t    (unsigned long)end);\n\n\treturn (int)!!ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "(unsigned long)start",
            "(unsigned long)end"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1572-1593",
          "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_text_reserved(const void *start, const void *end)\n{\n\tunsigned long ret;\n\n\tret = ftrace_location_range((unsigned long)start,\n\t\t\t\t    (unsigned long)end);\n\n\treturn (int)!!ret;\n}"
  },
  {
    "function_name": "ftrace_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1604-1607",
    "snippet": "unsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "ip",
            "ip"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1572-1593",
          "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location(unsigned long ip)\n{\n\treturn ftrace_location_range(ip, ip);\n}"
  },
  {
    "function_name": "ftrace_location_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1572-1593",
    "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&key",
            "pg->records",
            "pg->index",
            "sizeof(struct dyn_ftrace)",
            "ftrace_cmp_recs"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_cmp_recs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1548-1558",
    "snippet": "static int ftrace_cmp_recs(const void *a, const void *b)\n{\n\tconst struct dyn_ftrace *key = a;\n\tconst struct dyn_ftrace *rec = b;\n\n\tif (key->flags < rec->ip)\n\t\treturn -1;\n\tif (key->ip >= rec->ip + MCOUNT_INSN_SIZE)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_cmp_recs(const void *a, const void *b)\n{\n\tconst struct dyn_ftrace *key = a;\n\tconst struct dyn_ftrace *rec = b;\n\n\tif (key->flags < rec->ip)\n\t\treturn -1;\n\tif (key->ip >= rec->ip + MCOUNT_INSN_SIZE)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_ops_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1506-1531",
    "snippet": "static int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_contains_ip",
          "args": [
            "ip",
            "&hash"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "hash_contains_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1479-1492",
          "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "hash.notrace_hash",
            "ops->func_hash->notrace_hash"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "hash.filter_hash",
            "ops->func_hash->filter_hash"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_ops_test(struct ftrace_ops *ops, unsigned long ip, void *regs)\n{\n\tstruct ftrace_ops_hash hash;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * There's a small race when adding ops that the ftrace handler\n\t * that wants regs, may be called without them. We can not\n\t * allow that handler to be called if regs is NULL.\n\t */\n\tif (regs == NULL && (ops->flags & FTRACE_OPS_FL_SAVE_REGS))\n\t\treturn 0;\n#endif\n\n\trcu_assign_pointer(hash.filter_hash, ops->func_hash->filter_hash);\n\trcu_assign_pointer(hash.notrace_hash, ops->func_hash->notrace_hash);\n\n\tif (hash_contains_ip(ip, &hash))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hash_contains_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1479-1492",
    "snippet": "static bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash->notrace_hash",
            "ip"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1148-1163",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash->notrace_hash"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t/*\n\t * The function record is a match if it exists in the filter\n\t * hash and not in the notrace hash. Note, an emty hash is\n\t * considered a match for the filter hash, but an empty\n\t * notrace hash is considered not in the notrace hash.\n\t */\n\treturn (ftrace_hash_empty(hash->filter_hash) ||\n\t\t__ftrace_lookup_ip(hash->filter_hash, ip)) &&\n\t\t(ftrace_hash_empty(hash->notrace_hash) ||\n\t\t !__ftrace_lookup_ip(hash->notrace_hash, ip));\n}"
  },
  {
    "function_name": "ftrace_hash_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1441-1477",
    "snippet": "static int\nftrace_hash_move(struct ftrace_ops *ops, int enable,\n\t\t struct ftrace_hash **dst, struct ftrace_hash *src)\n{\n\tstruct ftrace_hash *new_hash;\n\tint ret;\n\n\t/* Reject setting notrace hash on IPMODIFY ftrace_ops */\n\tif (ops->flags & FTRACE_OPS_FL_IPMODIFY && !enable)\n\t\treturn -EINVAL;\n\n\tnew_hash = __ftrace_hash_move(src);\n\tif (!new_hash)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this can be applied if it is IPMODIFY ftrace_ops */\n\tif (enable) {\n\t\t/* IPMODIFY should be updated only when filter_hash updating */\n\t\tret = ftrace_hash_ipmodify_update(ops, new_hash);\n\t\tif (ret < 0) {\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current set, update the hash and add\n\t * them back.\n\t */\n\tftrace_hash_rec_disable_modify(ops, enable);\n\n\trcu_assign_pointer(*dst, new_hash);\n\n\tftrace_hash_rec_enable_modify(ops, enable);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_hash_rec_enable_modify",
          "args": [
            "ops",
            "enable"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_enable_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1846-1850",
          "snippet": "static void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_enable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t  int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*dst",
            "new_hash"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_rec_disable_modify",
          "args": [
            "ops",
            "enable"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_rec_disable_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1840-1844",
          "snippet": "static void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_hash_rec_disable_modify(struct ftrace_ops *ops,\n\t\t\t\t\t   int filter_hash)\n{\n\tftrace_hash_rec_update_modify(ops, filter_hash, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_ipmodify_update",
          "args": [
            "ops",
            "new_hash"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_ipmodify_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1954-1966",
          "snippet": "static int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int ftrace_hash_ipmodify_update(struct ftrace_ops *ops,\n\t\t\t\t       struct ftrace_hash *new_hash)\n{\n\tstruct ftrace_hash *old_hash = ops->func_hash->filter_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\told_hash = NULL;\n\n\tif (ftrace_hash_empty(new_hash))\n\t\tnew_hash = NULL;\n\n\treturn __ftrace_hash_update_ipmodify(ops, old_hash, new_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_hash_move",
          "args": [
            "src"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_hash_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1396-1439",
          "snippet": "static struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_node *tn;\n\tstruct hlist_head *hhd;\n\tstruct ftrace_hash *new_hash;\n\tint size = src->count;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\t/*\n\t * Make the hash size about 1/2 the # found\n\t */\n\tfor (size /= 2; size; size >>= 1)\n\t\tbits++;\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\n\treturn new_hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)",
            "#define FTRACE_HASH_MAX_BITS 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n#define FTRACE_HASH_MAX_BITS 12\n\nstatic struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_node *tn;\n\tstruct hlist_head *hhd;\n\tstruct ftrace_hash *new_hash;\n\tint size = src->count;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\t/*\n\t * Make the hash size about 1/2 the # found\n\t */\n\tfor (size /= 2; size; size >>= 1)\n\t\tbits++;\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\n\treturn new_hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int\nftrace_hash_move(struct ftrace_ops *ops, int enable,\n\t\t struct ftrace_hash **dst, struct ftrace_hash *src)\n{\n\tstruct ftrace_hash *new_hash;\n\tint ret;\n\n\t/* Reject setting notrace hash on IPMODIFY ftrace_ops */\n\tif (ops->flags & FTRACE_OPS_FL_IPMODIFY && !enable)\n\t\treturn -EINVAL;\n\n\tnew_hash = __ftrace_hash_move(src);\n\tif (!new_hash)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this can be applied if it is IPMODIFY ftrace_ops */\n\tif (enable) {\n\t\t/* IPMODIFY should be updated only when filter_hash updating */\n\t\tret = ftrace_hash_ipmodify_update(ops, new_hash);\n\t\tif (ret < 0) {\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current set, update the hash and add\n\t * them back.\n\t */\n\tftrace_hash_rec_disable_modify(ops, enable);\n\n\trcu_assign_pointer(*dst, new_hash);\n\n\tftrace_hash_rec_enable_modify(ops, enable);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_hash_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1396-1439",
    "snippet": "static struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_node *tn;\n\tstruct hlist_head *hhd;\n\tstruct ftrace_hash *new_hash;\n\tint size = src->count;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\t/*\n\t * Make the hash size about 1/2 the # found\n\t */\n\tfor (size /= 2; size; size >>= 1)\n\t\tbits++;\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\n\treturn new_hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)",
      "#define FTRACE_HASH_MAX_BITS 12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "new_hash",
            "entry"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1184-1194",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hash_entry",
          "args": [
            "src",
            "entry"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1219-1225",
          "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tn",
            "hhd",
            "hlist"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "bits"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "src"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n#define FTRACE_HASH_MAX_BITS 12\n\nstatic struct ftrace_hash *\n__ftrace_hash_move(struct ftrace_hash *src)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_node *tn;\n\tstruct hlist_head *hhd;\n\tstruct ftrace_hash *new_hash;\n\tint size = src->count;\n\tint bits = 0;\n\tint i;\n\n\t/*\n\t * If the new source is empty, just return the empty_hash.\n\t */\n\tif (ftrace_hash_empty(src))\n\t\treturn EMPTY_HASH;\n\n\t/*\n\t * Make the hash size about 1/2 the # found\n\t */\n\tfor (size /= 2; size; size >>= 1)\n\t\tbits++;\n\n\t/* Don't allocate too much */\n\tif (bits > FTRACE_HASH_MAX_BITS)\n\t\tbits = FTRACE_HASH_MAX_BITS;\n\n\tnew_hash = alloc_ftrace_hash(bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tnew_hash->flags = src->flags;\n\n\tsize = 1 << src->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &src->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist) {\n\t\t\tremove_hash_entry(src, entry);\n\t\t\t__add_hash_entry(new_hash, entry);\n\t\t}\n\t}\n\n\treturn new_hash;\n}"
  },
  {
    "function_name": "alloc_and_copy_ftrace_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1350-1386",
    "snippet": "static struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "new_hash"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "new_hash->count != hash->count"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_hash_entry",
          "args": [
            "new_hash",
            "entry->ip"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1196-1208",
          "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&hash->buckets[i]",
            "hlist"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ftrace_hash",
          "args": [
            "size_bits"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ftrace_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1299-1319",
          "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *\nalloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\tif (hash)\n\t\tnew_hash->flags = hash->flags;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_add_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1322-1348",
    "snippet": "static int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "ftrace_mod"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1246-1252",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ftrace_mod->list",
            "mod_head"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "module",
            "GFP_KERNEL"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "func",
            "GFP_KERNEL"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ftrace_mod)",
            "GFP_KERNEL"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_add_mod(struct trace_array *tr,\n\t\t\t  const char *func, const char *module,\n\t\t\t  int enable)\n{\n\tstruct ftrace_mod_load *ftrace_mod;\n\tstruct list_head *mod_head = enable ? &tr->mod_trace : &tr->mod_notrace;\n\n\tftrace_mod = kzalloc(sizeof(*ftrace_mod), GFP_KERNEL);\n\tif (!ftrace_mod)\n\t\treturn -ENOMEM;\n\n\tftrace_mod->func = kstrdup(func, GFP_KERNEL);\n\tftrace_mod->module = kstrdup(module, GFP_KERNEL);\n\tftrace_mod->enable = enable;\n\n\tif (!ftrace_mod->func || !ftrace_mod->module)\n\t\tgoto out_free;\n\n\tlist_add(&ftrace_mod->list, mod_head);\n\n\treturn 0;\n\n out_free:\n\tfree_ftrace_mod(ftrace_mod);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "alloc_ftrace_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1299-1319",
    "snippet": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hash"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(*hash->buckets)",
            "GFP_KERNEL"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hash)",
            "GFP_KERNEL"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}"
  },
  {
    "function_name": "ftrace_free_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1292-1297",
    "snippet": "void ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "ops->func_hash->notrace_hash"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_init",
          "args": [
            "ops"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "150-159",
          "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}"
  },
  {
    "function_name": "free_ftrace_hash_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1285-1290",
    "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&hash->rcu",
            "__free_ftrace_hash_rcu"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
  },
  {
    "function_name": "__free_ftrace_hash_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1277-1283",
    "snippet": "static void __free_ftrace_hash_rcu(struct rcu_head *rcu)\n{\n\tstruct ftrace_hash *hash;\n\n\thash = container_of(rcu, struct ftrace_hash, rcu);\n\tfree_ftrace_hash(hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ftrace_hash",
          "args": [
            "hash"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_hash_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1285-1290",
          "snippet": "static void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash_rcu(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tcall_rcu_sched(&hash->rcu, __free_ftrace_hash_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structftrace_hash",
            "rcu"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __free_ftrace_hash_rcu(struct rcu_head *rcu)\n{\n\tstruct ftrace_hash *hash;\n\n\thash = container_of(rcu, struct ftrace_hash, rcu);\n\tfree_ftrace_hash(hash);\n}"
  },
  {
    "function_name": "free_ftrace_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1268-1275",
    "snippet": "static void free_ftrace_hash(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tftrace_hash_clear(hash);\n\tkfree(hash->buckets);\n\tkfree(hash);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hash"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_clear",
          "args": [
            "hash"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1227-1244",
          "snippet": "static void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define EMPTY_HASH\t((struct ftrace_hash *)&empty_hash)\n\nstatic void free_ftrace_hash(struct ftrace_hash *hash)\n{\n\tif (!hash || hash == EMPTY_HASH)\n\t\treturn;\n\tftrace_hash_clear(hash);\n\tkfree(hash->buckets);\n\tkfree(hash);\n}"
  },
  {
    "function_name": "clear_ftrace_mod_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1254-1266",
    "snippet": "static void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ftrace_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_mod",
          "args": [
            "p"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1246-1252",
          "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "head",
            "list"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_lock"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void clear_ftrace_mod_list(struct list_head *head)\n{\n\tstruct ftrace_mod_load *p, *n;\n\n\t/* stack tracer isn't supported yet */\n\tif (!head)\n\t\treturn;\n\n\tmutex_lock(&ftrace_lock);\n\tlist_for_each_entry_safe(p, n, head, list)\n\t\tfree_ftrace_mod(p);\n\tmutex_unlock(&ftrace_lock);\n}"
  },
  {
    "function_name": "free_ftrace_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1246-1252",
    "snippet": "static void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ftrace_mod"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ftrace_mod->list"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void free_ftrace_mod(struct ftrace_mod_load *ftrace_mod)\n{\n\tlist_del(&ftrace_mod->list);\n\tkfree(ftrace_mod->module);\n\tkfree(ftrace_mod->func);\n\tkfree(ftrace_mod);\n}"
  },
  {
    "function_name": "ftrace_hash_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1227-1244",
    "snippet": "static void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FTRACE_WARN_ON",
          "args": [
            "hash->count"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "free_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1210-1217",
          "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "entry",
            "tn",
            "hhd",
            "hlist"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_hash_clear(struct ftrace_hash *hash)\n{\n\tstruct hlist_head *hhd;\n\tstruct hlist_node *tn;\n\tstruct ftrace_func_entry *entry;\n\tint size = 1 << hash->size_bits;\n\tint i;\n\n\tif (!hash->count)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\thhd = &hash->buckets[i];\n\t\thlist_for_each_entry_safe(entry, tn, hhd, hlist)\n\t\t\tfree_hash_entry(hash, entry);\n\t}\n\tFTRACE_WARN_ON(hash->count);\n}"
  },
  {
    "function_name": "remove_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1219-1225",
    "snippet": "static void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&entry->hlist"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nremove_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\thash->count--;\n}"
  },
  {
    "function_name": "free_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1210-1217",
    "snippet": "static void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&entry->hlist"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void\nfree_hash_entry(struct ftrace_hash *hash,\n\t\t  struct ftrace_func_entry *entry)\n{\n\thlist_del(&entry->hlist);\n\tkfree(entry);\n\thash->count--;\n}"
  },
  {
    "function_name": "add_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1196-1208",
    "snippet": "static int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_hash_entry",
          "args": [
            "hash",
            "entry"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "__add_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1184-1194",
          "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int add_hash_entry(struct ftrace_hash *hash, unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->ip = ip;\n\t__add_hash_entry(hash, entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__add_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1184-1194",
    "snippet": "static void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&entry->hlist",
            "hhd"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_key",
          "args": [
            "hash",
            "entry->ip"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1138-1145",
          "snippet": "static __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void __add_hash_entry(struct ftrace_hash *hash,\n\t\t\t     struct ftrace_func_entry *entry)\n{\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = ftrace_hash_key(hash, entry->ip);\n\thhd = &hash->buckets[key];\n\thlist_add_head(&entry->hlist, hhd);\n\thash->count++;\n}"
  },
  {
    "function_name": "ftrace_lookup_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1175-1182",
    "snippet": "struct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_lookup_ip",
          "args": [
            "hash",
            "ip"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_lookup_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1148-1163",
          "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_hash_empty",
          "args": [
            "hash"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "803-806",
          "snippet": "static __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline bool ftrace_hash_empty(struct ftrace_hash *hash)\n{\n\treturn !hash || !(hash->count || (hash->flags & FTRACE_HASH_FL_MOD));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_func_entry *\nftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (ftrace_hash_empty(hash))\n\t\treturn NULL;\n\n\treturn __ftrace_lookup_ip(hash, ip);\n}"
  },
  {
    "function_name": "__ftrace_lookup_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1148-1163",
    "snippet": "ftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu_notrace",
          "args": [
            "entry",
            "hhd",
            "hlist"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_hash_key",
          "args": [
            "hash",
            "ip"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_hash_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1138-1145",
          "snippet": "static __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nftrace_func_entry *\n__ftrace_lookup_ip(struct ftrace_hash *hash, unsigned long ip)\n{\n\tunsigned long key;\n\tstruct ftrace_func_entry *entry;\n\tstruct hlist_head *hhd;\n\n\tkey = ftrace_hash_key(hash, ip);\n\thhd = &hash->buckets[key];\n\n\thlist_for_each_entry_rcu_notrace(entry, hhd, hlist) {\n\t\tif (entry->ip == ip)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_hash_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1138-1145",
    "snippet": "static __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "ip",
            "hash->size_bits"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __always_inline unsigned long\nftrace_hash_key(struct ftrace_hash *hash, unsigned long ip)\n{\n\tif (hash->size_bits > 0)\n\t\treturn hash_long(ip, hash->size_bits);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_ftrace_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1117-1120",
    "snippet": "bool is_ftrace_trampoline(unsigned long addr)\n{\n\treturn ftrace_ops_trampoline(addr) != NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_trampoline",
          "args": [
            "addr"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1083-1109",
          "snippet": "struct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstruct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nbool is_ftrace_trampoline(unsigned long addr)\n{\n\treturn ftrace_ops_trampoline(addr) != NULL;\n}"
  },
  {
    "function_name": "ftrace_ops_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1083-1109",
    "snippet": "struct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstruct ftrace_ops *ftrace_ops_trampoline(unsigned long addr)\n{\n\tstruct ftrace_ops *op = NULL;\n\n\t/*\n\t * Some of the ops may be dynamically allocated,\n\t * they are freed after a synchronize_sched().\n\t */\n\tpreempt_disable_notrace();\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\t/*\n\t\t * This is to check for dynamically allocated trampolines.\n\t\t * Trampolines that are in kernel text will have\n\t\t * core_kernel_text() return true.\n\t\t */\n\t\tif (op->trampoline && op->trampoline_size)\n\t\t\tif (addr >= op->trampoline &&\n\t\t\t    addr < op->trampoline + op->trampoline_size) {\n\t\t\t\tpreempt_enable_notrace();\n\t\t\t\treturn op;\n\t\t\t}\n\t} while_for_each_ftrace_op(op);\n\tpreempt_enable_notrace();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_profile_tracefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "1019-1021",
    "snippet": "static __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n}"
  },
  {
    "function_name": "ftrace_profile_tracefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "978-1016",
    "snippet": "static __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct dentry *entry;\n\tchar *name;\n\tint ret;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\t\tname = kasprintf(GFP_KERNEL, \"function%d\", cpu);\n\t\tif (!name) {\n\t\t\t/*\n\t\t\t * The files created are permanent, if something happens\n\t\t\t * we still do not free memory.\n\t\t\t */\n\t\t\tWARN(1,\n\t\t\t     \"Could not allocate stat file for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\treturn;\n\t\t}\n\t\tstat->stat = function_stats;\n\t\tstat->stat.name = name;\n\t\tret = register_stat_tracer(&stat->stat);\n\t\tif (ret) {\n\t\t\tWARN(1,\n\t\t\t     \"Could not register function stat for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\tkfree(name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tentry = tracefs_create_file(\"function_profile_enabled\", 0644,\n\t\t\t\t    d_tracer, NULL, &ftrace_profile_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'function_profile_enabled' entry\\n\");\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'function_profile_enabled' entry\\n\""
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"function_profile_enabled\"",
            "0644",
            "d_tracer",
            "NULL",
            "&ftrace_profile_fops"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Could not register function stat for cpu %d\\n\"",
            "cpu"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_stat_tracer",
          "args": [
            "&stat->stat"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_stat_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_stat.c",
          "lines": "346-359",
          "snippet": "void unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_stat_sessions);",
            "static DEFINE_MUTEX(all_stat_sessions_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\nvoid unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Could not allocate stat file for cpu %d\\n\"",
            "cpu"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"function%d\"",
            "cpu"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ftrace_profile_stats",
            "cpu"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct dentry *entry;\n\tchar *name;\n\tint ret;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\t\tname = kasprintf(GFP_KERNEL, \"function%d\", cpu);\n\t\tif (!name) {\n\t\t\t/*\n\t\t\t * The files created are permanent, if something happens\n\t\t\t * we still do not free memory.\n\t\t\t */\n\t\t\tWARN(1,\n\t\t\t     \"Could not allocate stat file for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\treturn;\n\t\t}\n\t\tstat->stat = function_stats;\n\t\tstat->stat.name = name;\n\t\tret = register_stat_tracer(&stat->stat);\n\t\tif (ret) {\n\t\t\tWARN(1,\n\t\t\t     \"Could not register function stat for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\tkfree(name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tentry = tracefs_create_file(\"function_profile_enabled\", 0644,\n\t\t\t\t    d_tracer, NULL, &ftrace_profile_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'function_profile_enabled' entry\\n\");\n}"
  },
  {
    "function_name": "ftrace_profile_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "950-959",
    "snippet": "static ssize_t\nftrace_profile_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\t\t/* big enough to hold a number */\n\tint r;\n\n\tr = sprintf(buf, \"%u\\n\", ftrace_profile_enabled);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "r"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ftrace_profile_enabled"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_profile_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\t\t/* big enough to hold a number */\n\tint r;\n\n\tr = sprintf(buf, \"%u\\n\", ftrace_profile_enabled);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}"
  },
  {
    "function_name": "ftrace_profile_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "905-948",
    "snippet": "static ssize_t\nftrace_profile_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = !!val;\n\n\tmutex_lock(&ftrace_profile_lock);\n\tif (ftrace_profile_enabled ^ val) {\n\t\tif (val) {\n\t\t\tret = ftrace_profile_init();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t/*\n\t\t\t * unregister_ftrace_profiler calls stop_machine\n\t\t\t * so this acts like an synchronize_sched.\n\t\t\t */\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_profiler",
          "args": [],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_profiler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "899-902",
          "snippet": "static void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_profile_init",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "707-719",
          "snippet": "static int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_profile_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = !!val;\n\n\tmutex_lock(&ftrace_profile_lock);\n\tif (ftrace_profile_enabled ^ val) {\n\t\tif (val) {\n\t\t\tret = ftrace_profile_init();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t/*\n\t\t\t * unregister_ftrace_profiler calls stop_machine\n\t\t\t * so this acts like an synchronize_sched.\n\t\t\t */\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "unregister_ftrace_profiler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "899-902",
    "snippet": "static void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&ftrace_profile_ops"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_function(&ftrace_profile_ops);\n}"
  },
  {
    "function_name": "register_ftrace_profiler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "894-897",
    "snippet": "static int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_function(&ftrace_profile_ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&ftrace_profile_ops"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_function(&ftrace_profile_ops);\n}"
  },
  {
    "function_name": "unregister_ftrace_profiler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "883-886",
    "snippet": "static void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_graph();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7002-7019",
          "snippet": "void unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void unregister_ftrace_profiler(void)\n{\n\tunregister_ftrace_graph();\n}"
  },
  {
    "function_name": "register_ftrace_profiler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "877-881",
    "snippet": "static int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_graph(&profile_graph_return,\n\t\t\t\t     &profile_graph_entry);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&profile_graph_return",
            "&profile_graph_entry"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6962-7000",
          "snippet": "int register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nint register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int register_ftrace_profiler(void)\n{\n\treturn register_ftrace_graph(&profile_graph_return,\n\t\t\t\t     &profile_graph_entry);\n}"
  },
  {
    "function_name": "profile_graph_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "834-875",
    "snippet": "static void profile_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct ftrace_profile_stat *stat;\n\tunsigned long long calltime;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\t/* If the calltime was zero'd ignore it */\n\tif (!trace->calltime)\n\t\tgoto out;\n\n\tcalltime = trace->rettime - trace->calltime;\n\n\tif (!fgraph_graph_time) {\n\t\tint index;\n\n\t\tindex = trace->depth;\n\n\t\t/* Append this call time to the parent time to subtract */\n\t\tif (index)\n\t\t\tcurrent->ret_stack[index - 1].subtime += calltime;\n\n\t\tif (current->ret_stack[index].subtime < calltime)\n\t\t\tcalltime -= current->ret_stack[index].subtime;\n\t\telse\n\t\t\tcalltime = 0;\n\t}\n\n\trec = ftrace_find_profiled_func(stat, trace->func);\n\tif (rec) {\n\t\trec->time += calltime;\n\t\trec->time_squared += calltime * calltime;\n\t}\n\n out:\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_profiled_func",
          "args": [
            "stat",
            "trace->func"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_profiled_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "722-741",
          "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&ftrace_profile_stats"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void profile_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct ftrace_profile_stat *stat;\n\tunsigned long long calltime;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\t/* If the calltime was zero'd ignore it */\n\tif (!trace->calltime)\n\t\tgoto out;\n\n\tcalltime = trace->rettime - trace->calltime;\n\n\tif (!fgraph_graph_time) {\n\t\tint index;\n\n\t\tindex = trace->depth;\n\n\t\t/* Append this call time to the parent time to subtract */\n\t\tif (index)\n\t\t\tcurrent->ret_stack[index - 1].subtime += calltime;\n\n\t\tif (current->ret_stack[index].subtime < calltime)\n\t\t\tcalltime -= current->ret_stack[index].subtime;\n\t\telse\n\t\t\tcalltime = 0;\n\t}\n\n\trec = ftrace_find_profiled_func(stat, trace->func);\n\tif (rec) {\n\t\trec->time += calltime;\n\t\trec->time_squared += calltime * calltime;\n\t}\n\n out:\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "profile_graph_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "818-832",
    "snippet": "static int profile_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tint index = trace->depth;\n\n\tfunction_profile_call(trace->func, 0, NULL, NULL);\n\n\t/* If function graph is shutting down, ret_stack can be NULL */\n\tif (!current->ret_stack)\n\t\treturn 0;\n\n\tif (index >= 0 && index < FTRACE_RETFUNC_DEPTH)\n\t\tcurrent->ret_stack[index].subtime = 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "function_profile_call",
          "args": [
            "trace->func",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "function_profile_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "788-815",
          "snippet": "static void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct pt_regs *regs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct pt_regs *regs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int profile_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tint index = trace->depth;\n\n\tfunction_profile_call(trace->func, 0, NULL, NULL);\n\n\t/* If function graph is shutting down, ret_stack can be NULL */\n\tif (!current->ret_stack)\n\t\treturn 0;\n\n\tif (index >= 0 && index < FTRACE_RETFUNC_DEPTH)\n\t\tcurrent->ret_stack[index].subtime = 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "function_profile_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "788-815",
    "snippet": "static void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct pt_regs *regs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_profile_alloc",
          "args": [
            "stat",
            "ip"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "755-786",
          "snippet": "static struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nstatic struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_profiled_func",
          "args": [
            "stat",
            "ip"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_profiled_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "722-741",
          "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&ftrace_profile_stats"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void\nfunction_profile_call(unsigned long ip, unsigned long parent_ip,\n\t\t      struct ftrace_ops *ops, struct pt_regs *regs)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct ftrace_profile *rec;\n\tunsigned long flags;\n\n\tif (!ftrace_profile_enabled)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tstat = this_cpu_ptr(&ftrace_profile_stats);\n\tif (!stat->hash || !ftrace_profile_enabled)\n\t\tgoto out;\n\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (!rec) {\n\t\trec = ftrace_profile_alloc(stat, ip);\n\t\tif (!rec)\n\t\t\tgoto out;\n\t}\n\n\trec->counter++;\n out:\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "ftrace_profile_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "755-786",
    "snippet": "static struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&stat->disabled"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_add_profile",
          "args": [
            "stat",
            "rec"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_add_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "743-750",
          "snippet": "static void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_find_profiled_func",
          "args": [
            "stat",
            "ip"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_profiled_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "722-741",
          "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&stat->disabled"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nstatic struct ftrace_profile *\nftrace_profile_alloc(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec = NULL;\n\n\t/* prevent recursion (from NMIs) */\n\tif (atomic_inc_return(&stat->disabled) != 1)\n\t\tgoto out;\n\n\t/*\n\t * Try to find the function again since an NMI\n\t * could have added it\n\t */\n\trec = ftrace_find_profiled_func(stat, ip);\n\tif (rec)\n\t\tgoto out;\n\n\tif (stat->pages->index == PROFILES_PER_PAGE) {\n\t\tif (!stat->pages->next)\n\t\t\tgoto out;\n\t\tstat->pages = stat->pages->next;\n\t}\n\n\trec = &stat->pages->records[stat->pages->index++];\n\trec->ip = ip;\n\tftrace_add_profile(stat, rec);\n\n out:\n\tatomic_dec(&stat->disabled);\n\n\treturn rec;\n}"
  },
  {
    "function_name": "ftrace_add_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "743-750",
    "snippet": "static void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&rec->node",
            "&stat->hash[key]"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "rec->ip",
            "FTRACE_PROFILE_HASH_BITS"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic void ftrace_add_profile(struct ftrace_profile_stat *stat,\n\t\t\t       struct ftrace_profile *rec)\n{\n\tunsigned long key;\n\n\tkey = hash_long(rec->ip, FTRACE_PROFILE_HASH_BITS);\n\thlist_add_head_rcu(&rec->node, &stat->hash[key]);\n}"
  },
  {
    "function_name": "ftrace_find_profiled_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "722-741",
    "snippet": "static struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_BITS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu_notrace",
          "args": [
            "rec",
            "hhd",
            "node"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "hhd"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "ip",
            "FTRACE_PROFILE_HASH_BITS"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_BITS 10\n\nstatic struct ftrace_profile *\nftrace_find_profiled_func(struct ftrace_profile_stat *stat, unsigned long ip)\n{\n\tstruct ftrace_profile *rec;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, FTRACE_PROFILE_HASH_BITS);\n\thhd = &stat->hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu_notrace(rec, hhd, node) {\n\t\tif (rec->ip == ip)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_profile_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "707-719",
    "snippet": "static int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_profile_init_cpu",
          "args": [
            "cpu"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_init_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "673-705",
          "snippet": "static int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n\nstatic int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int ftrace_profile_init(void)\n{\n\tint cpu;\n\tint ret = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = ftrace_profile_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_profile_init_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "673-705",
    "snippet": "static int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stat->hash"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_profile_pages_init",
          "args": [
            "stat"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_pages_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "617-671",
          "snippet": "int ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nint ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(struct hlist_head)",
            "GFP_KERNEL"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_profile_reset",
          "args": [
            "stat"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_profile_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "601-615",
          "snippet": "static void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)",
            "#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))\n\nstatic void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ftrace_profile_stats",
            "cpu"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n\nstatic int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_profile_pages_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "617-671",
    "snippet": "int ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "tmp"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "functions",
            "PROFILES_PER_PAGE"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define PROFILES_PER_PAGE\t\t\t\t\t\\\n\t(PROFILE_RECORDS_SIZE / sizeof(struct ftrace_profile))\n\nint ftrace_profile_pages_init(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\tint functions;\n\tint pages;\n\tint i;\n\n\t/* If we already allocated, do nothing */\n\tif (stat->pages)\n\t\treturn 0;\n\n\tstat->pages = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!stat->pages)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tfunctions = ftrace_update_tot_cnt;\n#else\n\t/*\n\t * We do not know the number of functions that exist because\n\t * dynamic tracing is what counts them. With past experience\n\t * we have around 20K functions. That should be more than enough.\n\t * It is highly unlikely we will execute every function in\n\t * the kernel.\n\t */\n\tfunctions = 20000;\n#endif\n\n\tpg = stat->start = stat->pages;\n\n\tpages = DIV_ROUND_UP(functions, PROFILES_PER_PAGE);\n\n\tfor (i = 1; i < pages; i++) {\n\t\tpg->next = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto out_free;\n\t\tpg = pg->next;\n\t}\n\n\treturn 0;\n\n out_free:\n\tpg = stat->start;\n\twhile (pg) {\n\t\tunsigned long tmp = (unsigned long)pg;\n\n\t\tpg = pg->next;\n\t\tfree_page(tmp);\n\t}\n\n\tstat->pages = NULL;\n\tstat->start = NULL;\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ftrace_profile_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "601-615",
    "snippet": "static void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)",
      "#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stat->hash",
            "0",
            "FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pg->records",
            "0",
            "PROFILE_RECORDS_SIZE"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_PROFILE_HASH_SIZE (1 << FTRACE_PROFILE_HASH_BITS)\n#define PROFILE_RECORDS_SIZE\t\t\t\t\t\t\\\n\t(PAGE_SIZE - offsetof(struct ftrace_profile_page, records))\n\nstatic void ftrace_profile_reset(struct ftrace_profile_stat *stat)\n{\n\tstruct ftrace_profile_page *pg;\n\n\tpg = stat->pages = stat->start;\n\n\twhile (pg) {\n\t\tmemset(pg->records, 0, PROFILE_RECORDS_SIZE);\n\t\tpg->index = 0;\n\t\tpg = pg->next;\n\t}\n\n\tmemset(stat->hash, 0,\n\t       FTRACE_PROFILE_HASH_SIZE * sizeof(struct hlist_head));\n}"
  },
  {
    "function_name": "function_stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "537-599",
    "snippet": "static int function_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_profile *rec = v;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint ret = 0;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tstatic struct trace_seq s;\n\tunsigned long long avg;\n\tunsigned long long stddev;\n#endif\n\tmutex_lock(&ftrace_profile_lock);\n\n\t/* we raced with function_profile_reset() */\n\tif (unlikely(rec->counter == 0)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tavg = rec->time;\n\tdo_div(avg, rec->counter);\n\tif (tracing_thresh && (avg < tracing_thresh))\n\t\tgoto out;\n#endif\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, NULL, str);\n\tseq_printf(m, \"  %-30.30s  %10lu\", str, rec->counter);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"    \");\n\n\t/* Sample standard deviation (s^2) */\n\tif (rec->counter <= 1)\n\t\tstddev = 0;\n\telse {\n\t\t/*\n\t\t * Apply Welford's method:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = rec->counter * rec->time_squared -\n\t\t\t rec->time * rec->time;\n\n\t\t/*\n\t\t * Divide only 1000 for ns^2 -> us^2 conversion.\n\t\t * trace_print_graph_duration will divide 1000 again.\n\t\t */\n\t\tdo_div(stddev, rec->counter * (rec->counter - 1) * 1000);\n\t}\n\n\ttrace_seq_init(&s);\n\ttrace_print_graph_duration(rec->time, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(avg, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(stddev, &s);\n\ttrace_print_seq(m, &s);\n#endif\n\tseq_putc(m, '\\n');\nout:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_seq",
          "args": [
            "m",
            "&s"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "54-71",
          "snippet": "int trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t/*\n\t * Only reset this buffer if we successfully wrote to the\n\t * seq_file buffer. This lets the caller try again or\n\t * do something else with the contents.\n\t */\n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t/*\n\t * Only reset this buffer if we successfully wrote to the\n\t * seq_file buffer. This lets the caller try again or\n\t * do something else with the contents.\n\t */\n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_graph_duration",
          "args": [
            "stddev",
            "&s"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "758-789",
          "snippet": "void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "&s",
            "\"    \""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "&s"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "39-43",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stddev",
            "rec->counter * (rec->counter - 1) * 1000"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %-30.30s  %10lu\"",
            "str",
            "rec->counter"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "rec->ip",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "avg",
            "rec->counter"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rec->counter == 0"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ftrace_profile_lock"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_profile *rec = v;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint ret = 0;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tstatic struct trace_seq s;\n\tunsigned long long avg;\n\tunsigned long long stddev;\n#endif\n\tmutex_lock(&ftrace_profile_lock);\n\n\t/* we raced with function_profile_reset() */\n\tif (unlikely(rec->counter == 0)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tavg = rec->time;\n\tdo_div(avg, rec->counter);\n\tif (tracing_thresh && (avg < tracing_thresh))\n\t\tgoto out;\n#endif\n\n\tkallsyms_lookup(rec->ip, NULL, NULL, NULL, str);\n\tseq_printf(m, \"  %-30.30s  %10lu\", str, rec->counter);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"    \");\n\n\t/* Sample standard deviation (s^2) */\n\tif (rec->counter <= 1)\n\t\tstddev = 0;\n\telse {\n\t\t/*\n\t\t * Apply Welford's method:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = rec->counter * rec->time_squared -\n\t\t\t rec->time * rec->time;\n\n\t\t/*\n\t\t * Divide only 1000 for ns^2 -> us^2 conversion.\n\t\t * trace_print_graph_duration will divide 1000 again.\n\t\t */\n\t\tdo_div(stddev, rec->counter * (rec->counter - 1) * 1000);\n\t}\n\n\ttrace_seq_init(&s);\n\ttrace_print_graph_duration(rec->time, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(avg, &s);\n\ttrace_seq_puts(&s, \"    \");\n\ttrace_print_graph_duration(stddev, &s);\n\ttrace_print_seq(m, &s);\n#endif\n\tseq_putc(m, '\\n');\nout:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "function_stat_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "523-535",
    "snippet": "static int function_stat_headers(struct seq_file *m)\n{\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"  Function                               \"\n\t\t \"Hit    Time            Avg             s^2\\n\"\n\t\t    \"  --------                               \"\n\t\t \"---    ----            ---             ---\\n\");\n#else\n\tseq_puts(m, \"  Function                               Hit\\n\"\n\t\t    \"  --------                               ---\\n\");\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"  Function                               Hit\\n\"\n\t\t    \"  --------                               ---\\n\""
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_headers(struct seq_file *m)\n{\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tseq_puts(m, \"  Function                               \"\n\t\t \"Hit    Time            Avg             s^2\\n\"\n\t\t    \"  --------                               \"\n\t\t \"---    ----            ---             ---\\n\");\n#else\n\tseq_puts(m, \"  Function                               Hit\\n\"\n\t\t    \"  --------                               ---\\n\");\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "function_stat_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "509-520",
    "snippet": "static int function_stat_cmp(void *p1, void *p2)\n{\n\tstruct ftrace_profile *a = p1;\n\tstruct ftrace_profile *b = p2;\n\n\tif (a->counter < b->counter)\n\t\treturn -1;\n\tif (a->counter > b->counter)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_cmp(void *p1, void *p2)\n{\n\tstruct ftrace_profile *a = p1;\n\tstruct ftrace_profile *b = p2;\n\n\tif (a->counter < b->counter)\n\t\treturn -1;\n\tif (a->counter > b->counter)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "function_stat_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "495-506",
    "snippet": "static int function_stat_cmp(void *p1, void *p2)\n{\n\tstruct ftrace_profile *a = p1;\n\tstruct ftrace_profile *b = p2;\n\n\tif (a->time < b->time)\n\t\treturn -1;\n\tif (a->time > b->time)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic int function_stat_cmp(void *p1, void *p2)\n{\n\tstruct ftrace_profile *a = p1;\n\tstruct ftrace_profile *b = p2;\n\n\tif (a->time < b->time)\n\t\treturn -1;\n\tif (a->time > b->time)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "function_stat_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "482-491",
    "snippet": "static void *function_stat_start(struct tracer_stat *trace)\n{\n\tstruct ftrace_profile_stat *stat =\n\t\tcontainer_of(trace, struct ftrace_profile_stat, stat);\n\n\tif (!stat || !stat->start)\n\t\treturn NULL;\n\n\treturn function_stat_next(&stat->start->records[0], 0);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "function_stat_next",
          "args": [
            "&stat->start->records[0]",
            "0"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "function_stat_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "458-480",
          "snippet": "static void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "trace",
            "structftrace_profile_stat",
            "stat"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *function_stat_start(struct tracer_stat *trace)\n{\n\tstruct ftrace_profile_stat *stat =\n\t\tcontainer_of(trace, struct ftrace_profile_stat, stat);\n\n\tif (!stat || !stat->start)\n\t\treturn NULL;\n\n\treturn function_stat_next(&stat->start->records[0], 0);\n}"
  },
  {
    "function_name": "function_stat_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "458-480",
    "snippet": "static void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & PAGE_MASK);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >= (void *)&pg->records[pg->index]) {\n\t\tpg = pg->next;\n\t\tif (!pg)\n\t\t\treturn NULL;\n\t\trec = &pg->records[0];\n\t\tif (!rec->counter)\n\t\t\tgoto again;\n\t}\n\n\treturn rec;\n}"
  },
  {
    "function_name": "ftrace_update_pid_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "398-415",
    "snippet": "static void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "214-291",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
          ],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_ftrace_op",
          "args": [
            "op"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_update_trampoline",
          "args": [
            "op"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6222-6224",
          "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_pids_enabled",
          "args": [
            "op"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pids_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "95-105",
          "snippet": "static bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_ftrace_op",
          "args": [
            "op",
            "ftrace_ops_list"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\n\nstatic void ftrace_update_pid_func(void)\n{\n\tstruct ftrace_ops *op;\n\n\t/* Only do something if we are tracing something */\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->flags & FTRACE_OPS_FL_PID) {\n\t\t\top->func = ftrace_pids_enabled(op) ?\n\t\t\t\tftrace_pid_func : op->saved_func;\n\t\t\tftrace_update_trampoline(op);\n\t\t}\n\t} while_for_each_ftrace_op(op);\n\n\tupdate_ftrace_function();\n}"
  },
  {
    "function_name": "__unregister_ftrace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "378-396",
    "snippet": "static int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "214-291",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
          ],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_ftrace_ops",
          "args": [
            "&ftrace_ops_list",
            "ops"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "remove_ftrace_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "307-333",
          "snippet": "static int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(ops->flags & FTRACE_OPS_FL_ENABLED)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tif (WARN_ON(!(ops->flags & FTRACE_OPS_FL_ENABLED)))\n\t\treturn -EBUSY;\n\n\tret = remove_ftrace_ops(&ftrace_ops_list, ops);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\tops->func = ops->saved_func;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__register_ftrace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "337-376",
    "snippet": "static int __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\n\tif (!core_kernel_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ftrace_enabled",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ftrace_function",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "update_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "214-291",
          "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
          ],
          "globals_used": [
            "struct ftrace_ops *function_trace_op",
            "static struct ftrace_ops *set_function_trace_op;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "ftrace_func_t ftrace_trace_function",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_update_trampoline",
          "args": [
            "ops"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_update_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6222-6224",
          "snippet": "static void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_pids_enabled",
          "args": [
            "ops"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pids_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "95-105",
          "snippet": "static bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_ftrace_ops",
          "args": [
            "&ftrace_ops_list",
            "ops"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "add_ftrace_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "293-305",
          "snippet": "static void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "core_kernel_data",
          "args": [
            "(unsigned long)ops"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "core_kernel_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/extable.c",
          "lines": "97-103",
          "snippet": "int core_kernel_data(unsigned long addr)\n{\n\tif (addr >= (unsigned long)_sdata &&\n\t    addr < (unsigned long)_edata)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint core_kernel_data(unsigned long addr)\n{\n\tif (addr >= (unsigned long)_sdata &&\n\t    addr < (unsigned long)_edata)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ops->flags & FTRACE_OPS_FL_ENABLED"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int __register_ftrace_function(struct ftrace_ops *ops)\n{\n\tif (ops->flags & FTRACE_OPS_FL_DELETED)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EBUSY;\n\n#ifndef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/*\n\t * If the ftrace_ops specifies SAVE_REGS, then it only can be used\n\t * if the arch supports it, or SAVE_REGS_IF_SUPPORTED is also set.\n\t * Setting SAVE_REGS_IF_SUPPORTED makes SAVE_REGS irrelevant.\n\t */\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS &&\n\t    !(ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED))\n\t\treturn -EINVAL;\n\n\tif (ops->flags & FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED)\n\t\tops->flags |= FTRACE_OPS_FL_SAVE_REGS;\n#endif\n\n\tif (!core_kernel_data((unsigned long)ops))\n\t\tops->flags |= FTRACE_OPS_FL_DYNAMIC;\n\n\tadd_ftrace_ops(&ftrace_ops_list, ops);\n\n\t/* Always save the function, and reset at unregistering */\n\tops->saved_func = ops->func;\n\n\tif (ftrace_pids_enabled(ops))\n\t\tops->func = ftrace_pid_func;\n\n\tftrace_update_trampoline(ops);\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_ftrace_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "307-333",
    "snippet": "static int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ops->next",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic int remove_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t     struct ftrace_ops *ops)\n{\n\tstruct ftrace_ops **p;\n\n\t/*\n\t * If we are removing the last function, then simply point\n\t * to the ftrace_stub.\n\t */\n\tif (rcu_dereference_protected(*list,\n\t\t\tlockdep_is_held(&ftrace_lock)) == ops &&\n\t    rcu_dereference_protected(ops->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\t*list = &ftrace_list_end;\n\t\treturn 0;\n\t}\n\n\tfor (p = list; *p != &ftrace_list_end; p = &(*p)->next)\n\t\tif (*p == ops)\n\t\t\tbreak;\n\n\tif (*p != ops)\n\t\treturn -1;\n\n\t*p = (*p)->next;\n\treturn 0;\n}"
  },
  {
    "function_name": "add_ftrace_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "293-305",
    "snippet": "static void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*list",
            "ops"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ops->next",
            "*list"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void add_ftrace_ops(struct ftrace_ops __rcu **list,\n\t\t\t   struct ftrace_ops *ops)\n{\n\trcu_assign_pointer(ops->next, *list);\n\n\t/*\n\t * We are entering ops into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the ops->next pointer is valid before another CPU sees\n\t * the ops pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, ops);\n}"
  },
  {
    "function_name": "update_ftrace_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "214-291",
    "snippet": "static void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
    ],
    "globals_used": [
      "struct ftrace_ops *function_trace_op",
      "static struct ftrace_ops *set_function_trace_op;",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static DEFINE_MUTEX(ftrace_lock);",
      "static struct ftrace_ops __rcu *ftrace_ops_list",
      "ftrace_func_t ftrace_trace_function",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "ftrace_sync_ipi",
            "NULL",
            "1"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "489-496",
          "snippet": "int smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "ftrace_sync"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3151-3175",
          "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_function_graph_func",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "update_function_graph_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6932-6956",
          "snippet": "static void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static struct ftrace_ops __rcu *ftrace_ops_list",
            "static struct ftrace_ops global_ops;",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nstatic struct ftrace_ops global_ops;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_function_graph_func(void)\n{\n\tstruct ftrace_ops *op;\n\tbool do_test = false;\n\n\t/*\n\t * The graph and global ops share the same set of functions\n\t * to test. If any other ops is on the list, then\n\t * the graph tracing needs to test if its the function\n\t * it should call.\n\t */\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op != &global_ops && op != &graph_ops &&\n\t\t    op != &ftrace_list_end) {\n\t\t\tdo_test = true;\n\t\t\t/* in double loop, break out with goto */\n\t\t\tgoto out;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n out:\n\tif (do_test)\n\t\tftrace_graph_entry = ftrace_graph_entry_test;\n\telse\n\t\tftrace_graph_entry = __ftrace_graph_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_ops_get_list_func",
          "args": [
            "ftrace_ops_list"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_get_list_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "201-212",
          "snippet": "static ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list->next",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ftrace_ops_list",
            "lockdep_is_held(&ftrace_lock)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&ftrace_lock"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstruct ftrace_ops *function_trace_op;\nstatic struct ftrace_ops *set_function_trace_op;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic struct ftrace_ops __rcu *ftrace_ops_list;\nftrace_func_t ftrace_trace_function;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic void update_ftrace_function(void)\n{\n\tftrace_func_t func;\n\n\t/*\n\t * Prepare the ftrace_ops that the arch callback will use.\n\t * If there's only one ftrace_ops registered, the ftrace_ops_list\n\t * will point to the ops we want.\n\t */\n\tset_function_trace_op = rcu_dereference_protected(ftrace_ops_list,\n\t\t\t\t\t\tlockdep_is_held(&ftrace_lock));\n\n\t/* If there's no ftrace_ops registered, just call the stub function */\n\tif (set_function_trace_op == &ftrace_list_end) {\n\t\tfunc = ftrace_stub;\n\n\t/*\n\t * If we are at the end of the list and this ops is\n\t * recursion safe and not dynamic and the arch supports passing ops,\n\t * then have the mcount trampoline call the function directly.\n\t */\n\t} else if (rcu_dereference_protected(ftrace_ops_list->next,\n\t\t\tlockdep_is_held(&ftrace_lock)) == &ftrace_list_end) {\n\t\tfunc = ftrace_ops_get_list_func(ftrace_ops_list);\n\n\t} else {\n\t\t/* Just use the default ftrace_ops */\n\t\tset_function_trace_op = &ftrace_list_end;\n\t\tfunc = ftrace_ops_list_func;\n\t}\n\n\tupdate_function_graph_func();\n\n\t/* If there's no change, then do nothing more here */\n\tif (ftrace_trace_function == func)\n\t\treturn;\n\n\t/*\n\t * If we are using the list function, it doesn't care\n\t * about the function_trace_ops.\n\t */\n\tif (func == ftrace_ops_list_func) {\n\t\tftrace_trace_function = func;\n\t\t/*\n\t\t * Don't even bother setting function_trace_ops,\n\t\t * it would be racy to do so anyway.\n\t\t */\n\t\treturn;\n\t}\n\n#ifndef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * For static tracing, we need to be a bit more careful.\n\t * The function change takes affect immediately. Thus,\n\t * we need to coorditate the setting of the function_trace_ops\n\t * with the setting of the ftrace_trace_function.\n\t *\n\t * Set the function to the list ops, which will call the\n\t * function we want, albeit indirectly, but it handles the\n\t * ftrace_ops and doesn't depend on function_trace_op.\n\t */\n\tftrace_trace_function = ftrace_ops_list_func;\n\t/*\n\t * Make sure all CPUs see this. Yes this is slow, but static\n\t * tracing is slow and nasty to have enabled.\n\t */\n\tschedule_on_each_cpu(ftrace_sync);\n\t/* Now all cpus are using the list ops. */\n\tfunction_trace_op = set_function_trace_op;\n\t/* Make sure the function_trace_op is visible on all CPUs */\n\tsmp_wmb();\n\t/* Nasty way to force a rmb on all cpus */\n\tsmp_call_function(ftrace_sync_ipi, NULL, 1);\n\t/* OK, we are all set to update the ftrace_trace_function now! */\n#endif /* !CONFIG_DYNAMIC_FTRACE */\n\n\tftrace_trace_function = func;\n}"
  },
  {
    "function_name": "ftrace_ops_get_list_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "201-212",
    "snippet": "static ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [
      "#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)"
    ],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_ops_get_func",
          "args": [
            "ops"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_ops_get_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6355-6366",
          "snippet": "ftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion, needs to be RCU safe,\n\t * or does per cpu logic, then we need to call the assist handler.\n\t */\n\tif (!(ops->flags & FTRACE_OPS_FL_RECURSION_SAFE) ||\n\t    ops->flags & FTRACE_OPS_FL_RCU)\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If the function does not handle recursion, needs to be RCU safe,\n\t * or does per cpu logic, then we need to call the assist handler.\n\t */\n\tif (!(ops->flags & FTRACE_OPS_FL_RECURSION_SAFE) ||\n\t    ops->flags & FTRACE_OPS_FL_RCU)\n\t\treturn ftrace_ops_assist_func;\n\n\treturn ops->func;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic ftrace_func_t ftrace_ops_get_list_func(struct ftrace_ops *ops)\n{\n\t/*\n\t * If this is a dynamic, RCU, or per CPU ops, or we force list func,\n\t * then it needs to call the list anyway.\n\t */\n\tif (ops->flags & (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||\n\t    FTRACE_FORCE_LIST_FUNC)\n\t\treturn ftrace_ops_list_func;\n\n\treturn ftrace_ops_get_func(ops);\n}"
  },
  {
    "function_name": "update_function_graph_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "197-197",
    "snippet": "static inline void update_function_graph_func(void) { }",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic inline void update_function_graph_func(void) { }"
  },
  {
    "function_name": "ftrace_sync_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "183-187",
    "snippet": "static void ftrace_sync_ipi(void *data)\n{\n\t/* Probably not needed, but do it anyway */\n\tsmp_rmb();\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_sync_ipi(void *data)\n{\n\t/* Probably not needed, but do it anyway */\n\tsmp_rmb();\n}"
  },
  {
    "function_name": "ftrace_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "172-181",
    "snippet": "static void ftrace_sync(struct work_struct *work)\n{\n\t/*\n\t * This function is just a stub to implement a hard force\n\t * of synchronize_sched(). This requires synchronizing\n\t * tasks even in userspace and idle.\n\t *\n\t * Yes, function tracing is rude.\n\t */\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_sync(struct work_struct *work)\n{\n\t/*\n\t * This function is just a stub to implement a hard force\n\t * of synchronize_sched(). This requires synchronizing\n\t * tasks even in userspace and idle.\n\t *\n\t * Yes, function tracing is rude.\n\t */\n}"
  },
  {
    "function_name": "ftrace_pid_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "161-170",
    "snippet": "static void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t    struct ftrace_ops *op, struct pt_regs *regs)\n{\n\tstruct trace_array *tr = op->private;\n\n\tif (tr && this_cpu_read(tr->trace_buffer.data->ftrace_ignore_pid))\n\t\treturn;\n\n\top->saved_func(ip, parent_ip, op, regs);\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "op->saved_func",
          "args": [
            "ip",
            "parent_ip",
            "op",
            "regs"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tr->trace_buffer.data->ftrace_ignore_pid"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t    struct ftrace_ops *op, struct pt_regs *regs)\n{\n\tstruct trace_array *tr = op->private;\n\n\tif (tr && this_cpu_read(tr->trace_buffer.data->ftrace_ignore_pid))\n\t\treturn;\n\n\top->saved_func(ip, parent_ip, op, regs);\n}"
  },
  {
    "function_name": "ftrace_ops_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "150-159",
    "snippet": "static inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ops->local_hash.regex_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic inline void ftrace_ops_init(struct ftrace_ops *ops)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!(ops->flags & FTRACE_OPS_FL_INITIALIZED)) {\n\t\tmutex_init(&ops->local_hash.regex_lock);\n\t\tops->func_hash = &ops->local_hash;\n\t\tops->flags |= FTRACE_OPS_FL_INITIALIZED;\n\t}\n#endif\n}"
  },
  {
    "function_name": "ftrace_pids_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
    "lines": "95-105",
    "snippet": "static bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL;\n}",
    "includes": [
      "#include \"trace_stat.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <asm/sections.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/stop_machine.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
      "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nstatic bool ftrace_pids_enabled(struct ftrace_ops *ops)\n{\n\tstruct trace_array *tr;\n\n\tif (!(ops->flags & FTRACE_OPS_FL_PID) || !ops->private)\n\t\treturn false;\n\n\ttr = ops->private;\n\n\treturn tr->function_pids != NULL;\n}"
  }
]