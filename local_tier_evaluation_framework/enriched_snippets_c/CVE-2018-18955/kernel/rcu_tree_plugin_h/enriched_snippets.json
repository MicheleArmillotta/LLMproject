[
  {
    "function_name": "rcu_dynticks_task_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2691-2696",
    "snippet": "static void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "current->rcu_tasks_idle_cpu",
            "-1"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
  },
  {
    "function_name": "rcu_dynticks_task_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2683-2688",
    "snippet": "static void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "current->rcu_tasks_idle_cpu",
            "smp_processor_id()"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
  },
  {
    "function_name": "rcu_bind_gp_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2675-2680",
    "snippet": "static void rcu_bind_gp_kthread(void)\n{\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\thousekeeping_affine(current, HK_FLAG_RCU);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "housekeeping_affine",
          "args": [
            "current",
            "HK_FLAG_RCU"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_affine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "34-39",
          "snippet": "void housekeeping_affine(struct task_struct *t, enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\tset_cpus_allowed_ptr(t, housekeeping_mask);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nvoid housekeeping_affine(struct task_struct *t, enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\tset_cpus_allowed_ptr(t, housekeeping_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_bind_gp_kthread(void)\n{\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\thousekeeping_affine(current, HK_FLAG_RCU);\n}"
  },
  {
    "function_name": "rcu_nohz_full_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2661-2670",
    "snippet": "static bool rcu_nohz_full_cpu(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tif (tick_nohz_full_cpu(smp_processor_id()) &&\n\t    (!rcu_gp_in_progress() ||\n\t     ULONG_CMP_LT(jiffies, READ_ONCE(rcu_state.gp_start) + HZ)))\n\t\treturn true;\n#endif /* #ifdef CONFIG_NO_HZ_FULL */\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "jiffies",
            "READ_ONCE(rcu_state.gp_start) + HZ"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_start"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_nohz_full_cpu(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tif (tick_nohz_full_cpu(smp_processor_id()) &&\n\t    (!rcu_gp_in_progress() ||\n\t     ULONG_CMP_LT(jiffies, READ_ONCE(rcu_state.gp_start) + HZ)))\n\t\treturn true;\n#endif /* #ifdef CONFIG_NO_HZ_FULL */\n\treturn false;\n}"
  },
  {
    "function_name": "init_nocb_callback_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2645-2648",
    "snippet": "static bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_spawn_nocb_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2641-2643",
    "snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_spawn_nocb_kthreads(void)\n{\n}"
  },
  {
    "function_name": "rcu_spawn_all_nocb_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2637-2639",
    "snippet": "static void rcu_spawn_all_nocb_kthreads(int cpu)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_spawn_all_nocb_kthreads(int cpu)\n{\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2633-2635",
    "snippet": "static void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}"
  },
  {
    "function_name": "rcu_nocb_need_deferred_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2628-2631",
    "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_boot_init_nocb_percpu_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2624-2626",
    "snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}"
  },
  {
    "function_name": "rcu_nocb_adopt_orphan_cbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2617-2622",
    "snippet": "static bool __maybe_unused rcu_nocb_adopt_orphan_cbs(struct rcu_data *my_rdp,\n\t\t\t\t\t\t     struct rcu_data *rdp,\n\t\t\t\t\t\t     unsigned long flags)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool __maybe_unused rcu_nocb_adopt_orphan_cbs(struct rcu_data *my_rdp,\n\t\t\t\t\t\t     struct rcu_data *rdp,\n\t\t\t\t\t\t     unsigned long flags)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "__call_rcu_nocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2611-2615",
    "snippet": "static bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t    bool lazy, unsigned long flags)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t    bool lazy, unsigned long flags)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_init_one_nocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2607-2609",
    "snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}"
  },
  {
    "function_name": "rcu_nocb_gp_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2602-2605",
    "snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "rcu_nocb_gp_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2598-2600",
    "snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}"
  },
  {
    "function_name": "rcu_nocb_cpu_needs_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2592-2596",
    "snippet": "static bool rcu_nocb_cpu_needs_barrier(int cpu)\n{\n\tWARN_ON_ONCE(1); /* Should be dead code. */\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_nocb_cpu_needs_barrier(int cpu)\n{\n\tWARN_ON_ONCE(1); /* Should be dead code. */\n\treturn false;\n}"
  },
  {
    "function_name": "init_nocb_callback_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2571-2588",
    "snippet": "static bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\tif (!rcu_is_nocb_cpu(rdp->cpu))\n\t\treturn false;\n\n\t/* If there are early-boot callbacks, move them to nocb lists. */\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\trdp->nocb_head = rcu_segcblist_head(&rdp->cblist);\n\t\trdp->nocb_tail = rcu_segcblist_tail(&rdp->cblist);\n\t\tatomic_long_set(&rdp->nocb_q_count,\n\t\t\t\trcu_segcblist_n_cbs(&rdp->cblist));\n\t\tatomic_long_set(&rdp->nocb_q_count_lazy,\n\t\t\t\trcu_segcblist_n_lazy_cbs(&rdp->cblist));\n\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_disable(&rdp->cblist);\n\treturn true;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_disable",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "80-86",
          "snippet": "void rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_lazy_cbs(rsclp));\n\trsclp->tails[RCU_NEXT_TAIL] = NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_lazy_cbs(rsclp));\n\trsclp->tails[RCU_NEXT_TAIL] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "63-74",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&rdp->nocb_q_count_lazy",
            "rcu_segcblist_n_lazy_cbs(&rdp->cblist)"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_lazy_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_lazy_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-65",
          "snippet": "static inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&rdp->nocb_q_count",
            "rcu_segcblist_n_cbs(&rdp->cblist)"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_tail",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "107-111",
          "snippet": "static inline struct rcu_head **rcu_segcblist_tail(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(rcu_segcblist_empty(rsclp));\n\treturn rsclp->tails[RCU_NEXT_TAIL];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline struct rcu_head **rcu_segcblist_tail(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(rcu_segcblist_empty(rsclp));\n\treturn rsclp->tails[RCU_NEXT_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_head",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "97-100",
          "snippet": "static inline struct rcu_head *rcu_segcblist_head(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline struct rcu_head *rcu_segcblist_head(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\tif (!rcu_is_nocb_cpu(rdp->cpu))\n\t\treturn false;\n\n\t/* If there are early-boot callbacks, move them to nocb lists. */\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\trdp->nocb_head = rcu_segcblist_head(&rdp->cblist);\n\t\trdp->nocb_tail = rcu_segcblist_tail(&rdp->cblist);\n\t\tatomic_long_set(&rdp->nocb_q_count,\n\t\t\t\trcu_segcblist_n_cbs(&rdp->cblist));\n\t\tatomic_long_set(&rdp->nocb_q_count_lazy,\n\t\t\t\trcu_segcblist_n_lazy_cbs(&rdp->cblist));\n\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_disable(&rdp->cblist);\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_organize_nocb_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2533-2568",
    "snippet": "static void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tint ls = rcu_nocb_leader_stride;\n\tint nl = 0;  /* Next leader. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_leader = NULL;  /* Suppress misguided gcc warn. */\n\tstruct rcu_data *rdp_prev = NULL;\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_leader_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_cpu(cpu, rcu_nocb_mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New leader, set up for followers & next leader. */\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp->nocb_leader = rdp;\n\t\t\trdp_leader = rdp;\n\t\t} else {\n\t\t\t/* Another follower, link to previous leader. */\n\t\t\trdp->nocb_leader = rdp_leader;\n\t\t\trdp_prev->nocb_next_follower = rdp;\n\t\t}\n\t\trdp_prev = rdp;\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "rdp->cpu + 1",
            "ls"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "nr_cpu_ids"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tint ls = rcu_nocb_leader_stride;\n\tint nl = 0;  /* Next leader. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_leader = NULL;  /* Suppress misguided gcc warn. */\n\tstruct rcu_data *rdp_prev = NULL;\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_leader_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_cpu(cpu, rcu_nocb_mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New leader, set up for followers & next leader. */\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp->nocb_leader = rdp;\n\t\t\trdp_leader = rdp;\n\t\t} else {\n\t\t\t/* Another follower, link to previous leader. */\n\t\t\trdp->nocb_leader = rdp_leader;\n\t\t\trdp_prev->nocb_next_follower = rdp;\n\t\t}\n\t\trdp_prev = rdp;\n\t}\n}"
  },
  {
    "function_name": "rcu_spawn_nocb_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2518-2524",
    "snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\trcu_spawn_all_nocb_kthreads(cpu);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_spawn_nocb_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\trcu_spawn_all_nocb_kthreads(cpu);\n}"
  },
  {
    "function_name": "rcu_spawn_all_nocb_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2506-2510",
    "snippet": "static void rcu_spawn_all_nocb_kthreads(int cpu)\n{\n\tif (rcu_scheduler_fully_active)\n\t\trcu_spawn_one_nocb_kthread(cpu);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_spawn_one_nocb_kthread",
          "args": [
            "cpu"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_one_nocb_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2460-2500",
          "snippet": "static void rcu_spawn_one_nocb_kthread(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_last;\n\tstruct rcu_data *rdp_old_leader;\n\tstruct rcu_data *rdp_spawn = per_cpu_ptr(&rcu_data, cpu);\n\tstruct task_struct *t;\n\n\t/*\n\t * If this isn't a no-CBs CPU or if it already has an rcuo kthread,\n\t * then nothing to do.\n\t */\n\tif (!rcu_is_nocb_cpu(cpu) || rdp_spawn->nocb_kthread)\n\t\treturn;\n\n\t/* If we didn't spawn the leader first, reorganize! */\n\trdp_old_leader = rdp_spawn->nocb_leader;\n\tif (rdp_old_leader != rdp_spawn && !rdp_old_leader->nocb_kthread) {\n\t\trdp_last = NULL;\n\t\trdp = rdp_old_leader;\n\t\tdo {\n\t\t\trdp->nocb_leader = rdp_spawn;\n\t\t\tif (rdp_last && rdp != rdp_spawn)\n\t\t\t\trdp_last->nocb_next_follower = rdp;\n\t\t\tif (rdp == rdp_spawn) {\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t} else {\n\t\t\t\trdp_last = rdp;\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t\trdp_last->nocb_next_follower = NULL;\n\t\t\t}\n\t\t} while (rdp);\n\t\trdp_spawn->nocb_next_follower = rdp_old_leader;\n\t}\n\n\t/* Spawn the kthread for this CPU. */\n\tt = kthread_run(rcu_nocb_kthread, rdp_spawn,\n\t\t\t\"rcuo%c/%d\", rcu_state.abbr, cpu);\n\tBUG_ON(IS_ERR(t));\n\tWRITE_ONCE(rdp_spawn->nocb_kthread, t);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_spawn_one_nocb_kthread(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_last;\n\tstruct rcu_data *rdp_old_leader;\n\tstruct rcu_data *rdp_spawn = per_cpu_ptr(&rcu_data, cpu);\n\tstruct task_struct *t;\n\n\t/*\n\t * If this isn't a no-CBs CPU or if it already has an rcuo kthread,\n\t * then nothing to do.\n\t */\n\tif (!rcu_is_nocb_cpu(cpu) || rdp_spawn->nocb_kthread)\n\t\treturn;\n\n\t/* If we didn't spawn the leader first, reorganize! */\n\trdp_old_leader = rdp_spawn->nocb_leader;\n\tif (rdp_old_leader != rdp_spawn && !rdp_old_leader->nocb_kthread) {\n\t\trdp_last = NULL;\n\t\trdp = rdp_old_leader;\n\t\tdo {\n\t\t\trdp->nocb_leader = rdp_spawn;\n\t\t\tif (rdp_last && rdp != rdp_spawn)\n\t\t\t\trdp_last->nocb_next_follower = rdp;\n\t\t\tif (rdp == rdp_spawn) {\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t} else {\n\t\t\t\trdp_last = rdp;\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t\trdp_last->nocb_next_follower = NULL;\n\t\t\t}\n\t\t} while (rdp);\n\t\trdp_spawn->nocb_next_follower = rdp_old_leader;\n\t}\n\n\t/* Spawn the kthread for this CPU. */\n\tt = kthread_run(rcu_nocb_kthread, rdp_spawn,\n\t\t\t\"rcuo%c/%d\", rcu_state.abbr, cpu);\n\tBUG_ON(IS_ERR(t));\n\tWRITE_ONCE(rdp_spawn->nocb_kthread, t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_spawn_all_nocb_kthreads(int cpu)\n{\n\tif (rcu_scheduler_fully_active)\n\t\trcu_spawn_one_nocb_kthread(cpu);\n}"
  },
  {
    "function_name": "rcu_spawn_one_nocb_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2460-2500",
    "snippet": "static void rcu_spawn_one_nocb_kthread(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_last;\n\tstruct rcu_data *rdp_old_leader;\n\tstruct rcu_data *rdp_spawn = per_cpu_ptr(&rcu_data, cpu);\n\tstruct task_struct *t;\n\n\t/*\n\t * If this isn't a no-CBs CPU or if it already has an rcuo kthread,\n\t * then nothing to do.\n\t */\n\tif (!rcu_is_nocb_cpu(cpu) || rdp_spawn->nocb_kthread)\n\t\treturn;\n\n\t/* If we didn't spawn the leader first, reorganize! */\n\trdp_old_leader = rdp_spawn->nocb_leader;\n\tif (rdp_old_leader != rdp_spawn && !rdp_old_leader->nocb_kthread) {\n\t\trdp_last = NULL;\n\t\trdp = rdp_old_leader;\n\t\tdo {\n\t\t\trdp->nocb_leader = rdp_spawn;\n\t\t\tif (rdp_last && rdp != rdp_spawn)\n\t\t\t\trdp_last->nocb_next_follower = rdp;\n\t\t\tif (rdp == rdp_spawn) {\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t} else {\n\t\t\t\trdp_last = rdp;\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t\trdp_last->nocb_next_follower = NULL;\n\t\t\t}\n\t\t} while (rdp);\n\t\trdp_spawn->nocb_next_follower = rdp_old_leader;\n\t}\n\n\t/* Spawn the kthread for this CPU. */\n\tt = kthread_run(rcu_nocb_kthread, rdp_spawn,\n\t\t\t\"rcuo%c/%d\", rcu_state.abbr, cpu);\n\tBUG_ON(IS_ERR(t));\n\tWRITE_ONCE(rdp_spawn->nocb_kthread, t);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_spawn->nocb_kthread",
            "t"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(t)"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "rcu_nocb_kthread",
            "rdp_spawn",
            "\"rcuo%c/%d\"",
            "rcu_state.abbr",
            "cpu"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "cpu"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_spawn_one_nocb_kthread(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_last;\n\tstruct rcu_data *rdp_old_leader;\n\tstruct rcu_data *rdp_spawn = per_cpu_ptr(&rcu_data, cpu);\n\tstruct task_struct *t;\n\n\t/*\n\t * If this isn't a no-CBs CPU or if it already has an rcuo kthread,\n\t * then nothing to do.\n\t */\n\tif (!rcu_is_nocb_cpu(cpu) || rdp_spawn->nocb_kthread)\n\t\treturn;\n\n\t/* If we didn't spawn the leader first, reorganize! */\n\trdp_old_leader = rdp_spawn->nocb_leader;\n\tif (rdp_old_leader != rdp_spawn && !rdp_old_leader->nocb_kthread) {\n\t\trdp_last = NULL;\n\t\trdp = rdp_old_leader;\n\t\tdo {\n\t\t\trdp->nocb_leader = rdp_spawn;\n\t\t\tif (rdp_last && rdp != rdp_spawn)\n\t\t\t\trdp_last->nocb_next_follower = rdp;\n\t\t\tif (rdp == rdp_spawn) {\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t} else {\n\t\t\t\trdp_last = rdp;\n\t\t\t\trdp = rdp->nocb_next_follower;\n\t\t\t\trdp_last->nocb_next_follower = NULL;\n\t\t\t}\n\t\t} while (rdp);\n\t\trdp_spawn->nocb_next_follower = rdp_old_leader;\n\t}\n\n\t/* Spawn the kthread for this CPU. */\n\tt = kthread_run(rcu_nocb_kthread, rdp_spawn,\n\t\t\t\"rcuo%c/%d\", rcu_state.abbr, cpu);\n\tBUG_ON(IS_ERR(t));\n\tWRITE_ONCE(rdp_spawn->nocb_kthread, t);\n}"
  },
  {
    "function_name": "rcu_boot_init_nocb_percpu_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2446-2453",
    "snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n\trdp->nocb_tail = &rdp->nocb_head;\n\tinit_swait_queue_head(&rdp->nocb_wq);\n\trdp->nocb_follower_tail = &rdp->nocb_follower_head;\n\traw_spin_lock_init(&rdp->nocb_lock);\n\ttimer_setup(&rdp->nocb_timer, do_nocb_deferred_wakeup_timer, 0);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&rdp->nocb_timer",
            "do_nocb_deferred_wakeup_timer",
            "0"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rdp->nocb_wq"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n\trdp->nocb_tail = &rdp->nocb_head;\n\tinit_swait_queue_head(&rdp->nocb_wq);\n\trdp->nocb_follower_tail = &rdp->nocb_follower_head;\n\traw_spin_lock_init(&rdp->nocb_lock);\n\ttimer_setup(&rdp->nocb_timer, do_nocb_deferred_wakeup_timer, 0);\n}"
  },
  {
    "function_name": "rcu_init_nohz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2403-2443",
    "snippet": "void __init rcu_init_nohz(void)\n{\n\tint cpu;\n\tbool need_rcu_nocb_mask = false;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running && cpumask_weight(tick_nohz_full_mask))\n\t\tneed_rcu_nocb_mask = true;\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (!cpumask_available(rcu_nocb_mask) && need_rcu_nocb_mask) {\n\t\tif (!zalloc_cpumask_var(&rcu_nocb_mask, GFP_KERNEL)) {\n\t\t\tpr_info(\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running)\n\t\tcpumask_or(rcu_nocb_mask, rcu_nocb_mask, tick_nohz_full_mask);\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (!cpumask_subset(rcu_nocb_mask, cpu_possible_mask)) {\n\t\tpr_info(\"\\tNote: kernel parameter 'rcu_nocbs=', 'nohz_full', or 'isolcpus=' contains nonexistent CPUs.\\n\");\n\t\tcpumask_and(rcu_nocb_mask, cpu_possible_mask,\n\t\t\t    rcu_nocb_mask);\n\t}\n\tif (cpumask_empty(rcu_nocb_mask))\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: (none).\\n\");\n\telse\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: %*pbl.\\n\",\n\t\t\tcpumask_pr_args(rcu_nocb_mask));\n\tif (rcu_nocb_poll)\n\t\tpr_info(\"\\tPoll for callbacks from no-CBs CPUs.\\n\");\n\n\tfor_each_cpu(cpu, rcu_nocb_mask)\n\t\tinit_nocb_callback_list(per_cpu_ptr(&rcu_data, cpu));\n\trcu_organize_nocb_kthreads();\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_organize_nocb_kthreads",
          "args": [],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_organize_nocb_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2533-2568",
          "snippet": "static void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tint ls = rcu_nocb_leader_stride;\n\tint nl = 0;  /* Next leader. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_leader = NULL;  /* Suppress misguided gcc warn. */\n\tstruct rcu_data *rdp_prev = NULL;\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_leader_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_cpu(cpu, rcu_nocb_mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New leader, set up for followers & next leader. */\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp->nocb_leader = rdp;\n\t\t\trdp_leader = rdp;\n\t\t} else {\n\t\t\t/* Another follower, link to previous leader. */\n\t\t\trdp->nocb_leader = rdp_leader;\n\t\t\trdp_prev->nocb_next_follower = rdp;\n\t\t}\n\t\trdp_prev = rdp;\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_organize_nocb_kthreads(void)\n{\n\tint cpu;\n\tint ls = rcu_nocb_leader_stride;\n\tint nl = 0;  /* Next leader. */\n\tstruct rcu_data *rdp;\n\tstruct rcu_data *rdp_leader = NULL;  /* Suppress misguided gcc warn. */\n\tstruct rcu_data *rdp_prev = NULL;\n\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\tif (ls == -1) {\n\t\tls = int_sqrt(nr_cpu_ids);\n\t\trcu_nocb_leader_stride = ls;\n\t}\n\n\t/*\n\t * Each pass through this loop sets up one rcu_data structure.\n\t * Should the corresponding CPU come online in the future, then\n\t * we will spawn the needed set of rcu_nocb_kthread() kthreads.\n\t */\n\tfor_each_cpu(cpu, rcu_nocb_mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rdp->cpu >= nl) {\n\t\t\t/* New leader, set up for followers & next leader. */\n\t\t\tnl = DIV_ROUND_UP(rdp->cpu + 1, ls) * ls;\n\t\t\trdp->nocb_leader = rdp;\n\t\t\trdp_leader = rdp;\n\t\t} else {\n\t\t\t/* Another follower, link to previous leader. */\n\t\t\trdp->nocb_leader = rdp_leader;\n\t\t\trdp_prev->nocb_next_follower = rdp;\n\t\t}\n\t\trdp_prev = rdp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_nocb_callback_list",
          "args": [
            "per_cpu_ptr(&rcu_data, cpu)"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "init_nocb_callback_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2645-2648",
          "snippet": "static bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tPoll for callbacks from no-CBs CPUs.\\n\""
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tOffload RCU callbacks from CPUs: %*pbl.\\n\"",
            "cpumask_pr_args(rcu_nocb_mask)"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tOffload RCU callbacks from CPUs: (none).\\n\""
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "rcu_nocb_mask",
            "cpu_possible_mask",
            "rcu_nocb_mask"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tNote: kernel parameter 'rcu_nocbs=', 'nohz_full', or 'isolcpus=' contains nonexistent CPUs.\\n\""
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "rcu_nocb_mask",
            "cpu_possible_mask"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "rcu_nocb_mask",
            "rcu_nocb_mask",
            "tick_nohz_full_mask"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\""
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rcu_nocb_mask",
            "GFP_KERNEL"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "tick_nohz_full_mask"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __init rcu_init_nohz(void)\n{\n\tint cpu;\n\tbool need_rcu_nocb_mask = false;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running && cpumask_weight(tick_nohz_full_mask))\n\t\tneed_rcu_nocb_mask = true;\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (!cpumask_available(rcu_nocb_mask) && need_rcu_nocb_mask) {\n\t\tif (!zalloc_cpumask_var(&rcu_nocb_mask, GFP_KERNEL)) {\n\t\t\tpr_info(\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!cpumask_available(rcu_nocb_mask))\n\t\treturn;\n\n#if defined(CONFIG_NO_HZ_FULL)\n\tif (tick_nohz_full_running)\n\t\tcpumask_or(rcu_nocb_mask, rcu_nocb_mask, tick_nohz_full_mask);\n#endif /* #if defined(CONFIG_NO_HZ_FULL) */\n\n\tif (!cpumask_subset(rcu_nocb_mask, cpu_possible_mask)) {\n\t\tpr_info(\"\\tNote: kernel parameter 'rcu_nocbs=', 'nohz_full', or 'isolcpus=' contains nonexistent CPUs.\\n\");\n\t\tcpumask_and(rcu_nocb_mask, cpu_possible_mask,\n\t\t\t    rcu_nocb_mask);\n\t}\n\tif (cpumask_empty(rcu_nocb_mask))\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: (none).\\n\");\n\telse\n\t\tpr_info(\"\\tOffload RCU callbacks from CPUs: %*pbl.\\n\",\n\t\t\tcpumask_pr_args(rcu_nocb_mask));\n\tif (rcu_nocb_poll)\n\t\tpr_info(\"\\tPoll for callbacks from no-CBs CPUs.\\n\");\n\n\tfor_each_cpu(cpu, rcu_nocb_mask)\n\t\tinit_nocb_callback_list(per_cpu_ptr(&rcu_data, cpu));\n\trcu_organize_nocb_kthreads();\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2397-2401",
    "snippet": "static void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\tdo_nocb_deferred_wakeup_common(rdp);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup_common",
          "args": [
            "rdp"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2368-2382",
          "snippet": "static void do_nocb_deferred_wakeup_common(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tint ndw;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (!rcu_nocb_need_deferred_wakeup(rdp)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tndw = READ_ONCE(rdp->nocb_defer_wakeup);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t__wake_nocb_leader(rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup_common(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tint ndw;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (!rcu_nocb_need_deferred_wakeup(rdp)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tndw = READ_ONCE(rdp->nocb_defer_wakeup);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t__wake_nocb_leader(rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_need_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_need_deferred_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2628-2631",
          "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\tdo_nocb_deferred_wakeup_common(rdp);\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2385-2390",
    "snippet": "static void do_nocb_deferred_wakeup_timer(struct timer_list *t)\n{\n\tstruct rcu_data *rdp = from_timer(rdp, t, nocb_timer);\n\n\tdo_nocb_deferred_wakeup_common(rdp);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup_common",
          "args": [
            "rdp"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2368-2382",
          "snippet": "static void do_nocb_deferred_wakeup_common(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tint ndw;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (!rcu_nocb_need_deferred_wakeup(rdp)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tndw = READ_ONCE(rdp->nocb_defer_wakeup);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t__wake_nocb_leader(rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup_common(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tint ndw;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (!rcu_nocb_need_deferred_wakeup(rdp)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tndw = READ_ONCE(rdp->nocb_defer_wakeup);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t__wake_nocb_leader(rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "rdp",
            "t",
            "nocb_timer"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup_timer(struct timer_list *t)\n{\n\tstruct rcu_data *rdp = from_timer(rdp, t, nocb_timer);\n\n\tdo_nocb_deferred_wakeup_common(rdp);\n}"
  },
  {
    "function_name": "do_nocb_deferred_wakeup_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2368-2382",
    "snippet": "static void do_nocb_deferred_wakeup_common(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tint ndw;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (!rcu_nocb_need_deferred_wakeup(rdp)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tndw = READ_ONCE(rdp->nocb_defer_wakeup);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t__wake_nocb_leader(rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"DeferredWake\")"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"DeferredWake\""
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_nocb_leader",
          "args": [
            "rdp",
            "ndw == RCU_NOCB_WAKE_FORCE",
            "flags"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_nocb_leader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1924-1945",
          "snippet": "static void __wake_nocb_leader(struct rcu_data *rdp, bool force,\n\t\t\t       unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_data *rdp_leader = rdp->nocb_leader;\n\n\tlockdep_assert_held(&rdp->nocb_lock);\n\tif (!READ_ONCE(rdp_leader->nocb_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tif (rdp_leader->nocb_leader_sleep || force) {\n\t\t/* Prior smp_mb__after_atomic() orders against prior enqueue. */\n\t\tWRITE_ONCE(rdp_leader->nocb_leader_sleep, false);\n\t\tdel_timer(&rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tsmp_mb(); /* ->nocb_leader_sleep before swake_up_one(). */\n\t\tswake_up_one(&rdp_leader->nocb_wq);\n\t} else {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __wake_nocb_leader(struct rcu_data *rdp, bool force,\n\t\t\t       unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_data *rdp_leader = rdp->nocb_leader;\n\n\tlockdep_assert_held(&rdp->nocb_lock);\n\tif (!READ_ONCE(rdp_leader->nocb_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tif (rdp_leader->nocb_leader_sleep || force) {\n\t\t/* Prior smp_mb__after_atomic() orders against prior enqueue. */\n\t\tWRITE_ONCE(rdp_leader->nocb_leader_sleep, false);\n\t\tdel_timer(&rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tsmp_mb(); /* ->nocb_leader_sleep before swake_up_one(). */\n\t\tswake_up_one(&rdp_leader->nocb_wq);\n\t} else {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_defer_wakeup",
            "RCU_NOCB_WAKE_NOT"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_defer_wakeup"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_need_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_need_deferred_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2628-2631",
          "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup_common(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tint ndw;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (!rcu_nocb_need_deferred_wakeup(rdp)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tndw = READ_ONCE(rdp->nocb_defer_wakeup);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t__wake_nocb_leader(rdp, ndw == RCU_NOCB_WAKE_FORCE, flags);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"DeferredWake\"));\n}"
  },
  {
    "function_name": "rcu_nocb_need_deferred_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2362-2365",
    "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn READ_ONCE(rdp->nocb_defer_wakeup);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_defer_wakeup"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn READ_ONCE(rdp->nocb_defer_wakeup);\n}"
  },
  {
    "function_name": "rcu_nocb_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2301-2359",
    "snippet": "static int rcu_nocb_kthread(void *arg)\n{\n\tint c, cl;\n\tunsigned long flags;\n\tstruct rcu_head *list;\n\tstruct rcu_head *next;\n\tstruct rcu_head **tail;\n\tstruct rcu_data *rdp = arg;\n\n\t/* Each pass through this loop invokes one batch of callbacks */\n\tfor (;;) {\n\t\t/* Wait for callbacks. */\n\t\tif (rdp->nocb_leader == rdp)\n\t\t\tnocb_leader_wait(rdp);\n\t\telse\n\t\t\tnocb_follower_wait(rdp);\n\n\t\t/* Pull the ready-to-invoke callbacks onto local list. */\n\t\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t\tlist = rdp->nocb_follower_head;\n\t\trdp->nocb_follower_head = NULL;\n\t\ttail = rdp->nocb_follower_tail;\n\t\trdp->nocb_follower_tail = &rdp->nocb_follower_head;\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tBUG_ON(!list);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeNonEmpty\"));\n\n\t\t/* Each pass through the following loop invokes a callback. */\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      atomic_long_read(&rdp->nocb_q_count_lazy),\n\t\t\t\t      atomic_long_read(&rdp->nocb_q_count), -1);\n\t\tc = cl = 0;\n\t\twhile (list) {\n\t\t\tnext = list->next;\n\t\t\t/* Wait for enqueuing to complete, if needed. */\n\t\t\twhile (next == NULL && &list->next != tail) {\n\t\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t\t    TPS(\"WaitQueue\"));\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t\t    TPS(\"WokeQueue\"));\n\t\t\t\tnext = list->next;\n\t\t\t}\n\t\t\tdebug_rcu_head_unqueue(list);\n\t\t\tlocal_bh_disable();\n\t\t\tif (__rcu_reclaim(rcu_state.name, list))\n\t\t\t\tcl++;\n\t\t\tc++;\n\t\t\tlocal_bh_enable();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlist = next;\n\t\t}\n\t\ttrace_rcu_batch_end(rcu_state.name, c, !!list, 0, 0, 1);\n\t\tsmp_mb__before_atomic();  /* _add after CB invocation. */\n\t\tatomic_long_add(-c, &rdp->nocb_q_count);\n\t\tatomic_long_add(-cl, &rdp->nocb_q_count_lazy);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "-cl",
            "&rdp->nocb_q_count_lazy"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "-c",
            "&rdp->nocb_q_count"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_end",
          "args": [
            "rcu_state.name",
            "c",
            "!!list",
            "0",
            "0",
            "1"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rcu_reclaim",
          "args": [
            "rcu_state.name",
            "list"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "225-244",
          "snippet": "static inline bool __rcu_reclaim(const char *rn, struct rcu_head *head)\n{\n\trcu_callback_t f;\n\tunsigned long offset = (unsigned long)head->func;\n\n\trcu_lock_acquire(&rcu_callback_map);\n\tif (__is_kfree_rcu_offset(offset)) {\n\t\tRCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset);)\n\t\tkfree((void *)head - offset);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn true;\n\t} else {\n\t\tRCU_TRACE(trace_rcu_invoke_callback(rn, head);)\n\t\tf = head->func;\n\t\tWRITE_ONCE(head->func, (rcu_callback_t)0L);\n\t\tf(head);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool __rcu_reclaim(const char *rn, struct rcu_head *head)\n{\n\trcu_callback_t f;\n\tunsigned long offset = (unsigned long)head->func;\n\n\trcu_lock_acquire(&rcu_callback_map);\n\tif (__is_kfree_rcu_offset(offset)) {\n\t\tRCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset);)\n\t\tkfree((void *)head - offset);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn true;\n\t} else {\n\t\tRCU_TRACE(trace_rcu_invoke_callback(rn, head);)\n\t\tf = head->func;\n\t\tWRITE_ONCE(head->func, (rcu_callback_t)0L);\n\t\tf(head);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "list"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "214-216",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WokeQueue\")"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WokeQueue\""
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "1"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WaitQueue\")"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WaitQueue\""
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_start",
          "args": [
            "rcu_state.name",
            "atomic_long_read(&rdp->nocb_q_count_lazy)",
            "atomic_long_read(&rdp->nocb_q_count)",
            "-1"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count_lazy"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WokeNonEmpty\")"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WokeNonEmpty\""
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nocb_follower_wait",
          "args": [
            "rdp"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_follower_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2280-2293",
          "snippet": "static void nocb_follower_wait(struct rcu_data *rdp)\n{\n\tfor (;;) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"FollowerSleep\"));\n\t\tswait_event_interruptible_exclusive(rdp->nocb_wq,\n\t\t\t\t\t READ_ONCE(rdp->nocb_follower_head));\n\t\tif (smp_load_acquire(&rdp->nocb_follower_head)) {\n\t\t\t/* ^^^ Ensure CB invocation follows _head test. */\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void nocb_follower_wait(struct rcu_data *rdp)\n{\n\tfor (;;) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"FollowerSleep\"));\n\t\tswait_event_interruptible_exclusive(rdp->nocb_wq,\n\t\t\t\t\t READ_ONCE(rdp->nocb_follower_head));\n\t\tif (smp_load_acquire(&rdp->nocb_follower_head)) {\n\t\t\t/* ^^^ Ensure CB invocation follows _head test. */\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nocb_leader_wait",
          "args": [
            "rdp"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "nocb_leader_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2189-2274",
          "snippet": "static void nocb_leader_wait(struct rcu_data *my_rdp)\n{\n\tbool firsttime = true;\n\tunsigned long flags;\n\tbool gotcbs;\n\tstruct rcu_data *rdp;\n\tstruct rcu_head **tail;\n\nwait_again:\n\n\t/* Wait for callbacks to appear. */\n\tif (!rcu_nocb_poll) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_leader_sleep));\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\tmy_rdp->nocb_leader_sleep = true;\n\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&my_rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t} else if (firsttime) {\n\t\tfirsttime = false; /* Don't drown trace log with \"Poll\"! */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Poll\"));\n\t}\n\n\t/*\n\t * Each pass through the following loop checks a follower for CBs.\n\t * We are our own first follower.  Any CBs found are moved to\n\t * nocb_gp_head, where they await a grace period.\n\t */\n\tgotcbs = false;\n\tsmp_mb(); /* wakeup and _sleep before ->nocb_head reads. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\trdp->nocb_gp_head = READ_ONCE(rdp->nocb_head);\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue;  /* No CBs here, try next follower. */\n\n\t\t/* Move callbacks to wait-for-GP list, which is empty. */\n\t\tWRITE_ONCE(rdp->nocb_head, NULL);\n\t\trdp->nocb_gp_tail = xchg(&rdp->nocb_tail, &rdp->nocb_head);\n\t\tgotcbs = true;\n\t}\n\n\t/* No callbacks?  Sleep a bit if polling, and go retry.  */\n\tif (unlikely(!gotcbs)) {\n\t\tWARN_ON(signal_pending(current));\n\t\tif (rcu_nocb_poll) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu,\n\t\t\t\t\t    TPS(\"WokeEmpty\"));\n\t\t}\n\t\tgoto wait_again;\n\t}\n\n\t/* Wait for one grace period. */\n\trcu_nocb_wait_gp(my_rdp);\n\n\t/* Each pass through the following loop wakes a follower, if needed. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\tif (!rcu_nocb_poll &&\n\t\t    READ_ONCE(rdp->nocb_head) &&\n\t\t    READ_ONCE(my_rdp->nocb_leader_sleep)) {\n\t\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\t\tmy_rdp->nocb_leader_sleep = false;/* No need to sleep.*/\n\t\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t\t}\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue; /* No CBs, so no need to wake follower. */\n\n\t\t/* Append callbacks to follower's \"done\" list. */\n\t\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t\ttail = rdp->nocb_follower_tail;\n\t\trdp->nocb_follower_tail = rdp->nocb_gp_tail;\n\t\t*tail = rdp->nocb_gp_head;\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tif (rdp != my_rdp && tail == &rdp->nocb_follower_head) {\n\t\t\t/* List was empty, so wake up the follower.  */\n\t\t\tswake_up_one(&rdp->nocb_wq);\n\t\t}\n\t}\n\n\t/* If we (the leader) don't have CBs, go wait some more. */\n\tif (!my_rdp->nocb_follower_head)\n\t\tgoto wait_again;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void nocb_leader_wait(struct rcu_data *my_rdp)\n{\n\tbool firsttime = true;\n\tunsigned long flags;\n\tbool gotcbs;\n\tstruct rcu_data *rdp;\n\tstruct rcu_head **tail;\n\nwait_again:\n\n\t/* Wait for callbacks to appear. */\n\tif (!rcu_nocb_poll) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_leader_sleep));\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\tmy_rdp->nocb_leader_sleep = true;\n\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&my_rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t} else if (firsttime) {\n\t\tfirsttime = false; /* Don't drown trace log with \"Poll\"! */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Poll\"));\n\t}\n\n\t/*\n\t * Each pass through the following loop checks a follower for CBs.\n\t * We are our own first follower.  Any CBs found are moved to\n\t * nocb_gp_head, where they await a grace period.\n\t */\n\tgotcbs = false;\n\tsmp_mb(); /* wakeup and _sleep before ->nocb_head reads. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\trdp->nocb_gp_head = READ_ONCE(rdp->nocb_head);\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue;  /* No CBs here, try next follower. */\n\n\t\t/* Move callbacks to wait-for-GP list, which is empty. */\n\t\tWRITE_ONCE(rdp->nocb_head, NULL);\n\t\trdp->nocb_gp_tail = xchg(&rdp->nocb_tail, &rdp->nocb_head);\n\t\tgotcbs = true;\n\t}\n\n\t/* No callbacks?  Sleep a bit if polling, and go retry.  */\n\tif (unlikely(!gotcbs)) {\n\t\tWARN_ON(signal_pending(current));\n\t\tif (rcu_nocb_poll) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu,\n\t\t\t\t\t    TPS(\"WokeEmpty\"));\n\t\t}\n\t\tgoto wait_again;\n\t}\n\n\t/* Wait for one grace period. */\n\trcu_nocb_wait_gp(my_rdp);\n\n\t/* Each pass through the following loop wakes a follower, if needed. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\tif (!rcu_nocb_poll &&\n\t\t    READ_ONCE(rdp->nocb_head) &&\n\t\t    READ_ONCE(my_rdp->nocb_leader_sleep)) {\n\t\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\t\tmy_rdp->nocb_leader_sleep = false;/* No need to sleep.*/\n\t\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t\t}\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue; /* No CBs, so no need to wake follower. */\n\n\t\t/* Append callbacks to follower's \"done\" list. */\n\t\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t\ttail = rdp->nocb_follower_tail;\n\t\trdp->nocb_follower_tail = rdp->nocb_gp_tail;\n\t\t*tail = rdp->nocb_gp_head;\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tif (rdp != my_rdp && tail == &rdp->nocb_follower_head) {\n\t\t\t/* List was empty, so wake up the follower.  */\n\t\t\tswake_up_one(&rdp->nocb_wq);\n\t\t}\n\t}\n\n\t/* If we (the leader) don't have CBs, go wait some more. */\n\tif (!my_rdp->nocb_follower_head)\n\t\tgoto wait_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_nocb_kthread(void *arg)\n{\n\tint c, cl;\n\tunsigned long flags;\n\tstruct rcu_head *list;\n\tstruct rcu_head *next;\n\tstruct rcu_head **tail;\n\tstruct rcu_data *rdp = arg;\n\n\t/* Each pass through this loop invokes one batch of callbacks */\n\tfor (;;) {\n\t\t/* Wait for callbacks. */\n\t\tif (rdp->nocb_leader == rdp)\n\t\t\tnocb_leader_wait(rdp);\n\t\telse\n\t\t\tnocb_follower_wait(rdp);\n\n\t\t/* Pull the ready-to-invoke callbacks onto local list. */\n\t\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t\tlist = rdp->nocb_follower_head;\n\t\trdp->nocb_follower_head = NULL;\n\t\ttail = rdp->nocb_follower_tail;\n\t\trdp->nocb_follower_tail = &rdp->nocb_follower_head;\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tBUG_ON(!list);\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeNonEmpty\"));\n\n\t\t/* Each pass through the following loop invokes a callback. */\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      atomic_long_read(&rdp->nocb_q_count_lazy),\n\t\t\t\t      atomic_long_read(&rdp->nocb_q_count), -1);\n\t\tc = cl = 0;\n\t\twhile (list) {\n\t\t\tnext = list->next;\n\t\t\t/* Wait for enqueuing to complete, if needed. */\n\t\t\twhile (next == NULL && &list->next != tail) {\n\t\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t\t    TPS(\"WaitQueue\"));\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t\t    TPS(\"WokeQueue\"));\n\t\t\t\tnext = list->next;\n\t\t\t}\n\t\t\tdebug_rcu_head_unqueue(list);\n\t\t\tlocal_bh_disable();\n\t\t\tif (__rcu_reclaim(rcu_state.name, list))\n\t\t\t\tcl++;\n\t\t\tc++;\n\t\t\tlocal_bh_enable();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlist = next;\n\t\t}\n\t\ttrace_rcu_batch_end(rcu_state.name, c, !!list, 0, 0, 1);\n\t\tsmp_mb__before_atomic();  /* _add after CB invocation. */\n\t\tatomic_long_add(-c, &rdp->nocb_q_count);\n\t\tatomic_long_add(-cl, &rdp->nocb_q_count_lazy);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nocb_follower_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2280-2293",
    "snippet": "static void nocb_follower_wait(struct rcu_data *rdp)\n{\n\tfor (;;) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"FollowerSleep\"));\n\t\tswait_event_interruptible_exclusive(rdp->nocb_wq,\n\t\t\t\t\t READ_ONCE(rdp->nocb_follower_head));\n\t\tif (smp_load_acquire(&rdp->nocb_follower_head)) {\n\t\t\t/* ^^^ Ensure CB invocation follows _head test. */\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WokeEmpty\")"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WokeEmpty\""
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rdp->nocb_follower_head"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_interruptible_exclusive",
          "args": [
            "rdp->nocb_wq",
            "READ_ONCE(rdp->nocb_follower_head)"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_follower_head"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"FollowerSleep\")"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"FollowerSleep\""
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void nocb_follower_wait(struct rcu_data *rdp)\n{\n\tfor (;;) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"FollowerSleep\"));\n\t\tswait_event_interruptible_exclusive(rdp->nocb_wq,\n\t\t\t\t\t READ_ONCE(rdp->nocb_follower_head));\n\t\tif (smp_load_acquire(&rdp->nocb_follower_head)) {\n\t\t\t/* ^^^ Ensure CB invocation follows _head test. */\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WokeEmpty\"));\n\t}\n}"
  },
  {
    "function_name": "nocb_leader_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2189-2274",
    "snippet": "static void nocb_leader_wait(struct rcu_data *my_rdp)\n{\n\tbool firsttime = true;\n\tunsigned long flags;\n\tbool gotcbs;\n\tstruct rcu_data *rdp;\n\tstruct rcu_head **tail;\n\nwait_again:\n\n\t/* Wait for callbacks to appear. */\n\tif (!rcu_nocb_poll) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_leader_sleep));\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\tmy_rdp->nocb_leader_sleep = true;\n\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&my_rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t} else if (firsttime) {\n\t\tfirsttime = false; /* Don't drown trace log with \"Poll\"! */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Poll\"));\n\t}\n\n\t/*\n\t * Each pass through the following loop checks a follower for CBs.\n\t * We are our own first follower.  Any CBs found are moved to\n\t * nocb_gp_head, where they await a grace period.\n\t */\n\tgotcbs = false;\n\tsmp_mb(); /* wakeup and _sleep before ->nocb_head reads. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\trdp->nocb_gp_head = READ_ONCE(rdp->nocb_head);\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue;  /* No CBs here, try next follower. */\n\n\t\t/* Move callbacks to wait-for-GP list, which is empty. */\n\t\tWRITE_ONCE(rdp->nocb_head, NULL);\n\t\trdp->nocb_gp_tail = xchg(&rdp->nocb_tail, &rdp->nocb_head);\n\t\tgotcbs = true;\n\t}\n\n\t/* No callbacks?  Sleep a bit if polling, and go retry.  */\n\tif (unlikely(!gotcbs)) {\n\t\tWARN_ON(signal_pending(current));\n\t\tif (rcu_nocb_poll) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu,\n\t\t\t\t\t    TPS(\"WokeEmpty\"));\n\t\t}\n\t\tgoto wait_again;\n\t}\n\n\t/* Wait for one grace period. */\n\trcu_nocb_wait_gp(my_rdp);\n\n\t/* Each pass through the following loop wakes a follower, if needed. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\tif (!rcu_nocb_poll &&\n\t\t    READ_ONCE(rdp->nocb_head) &&\n\t\t    READ_ONCE(my_rdp->nocb_leader_sleep)) {\n\t\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\t\tmy_rdp->nocb_leader_sleep = false;/* No need to sleep.*/\n\t\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t\t}\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue; /* No CBs, so no need to wake follower. */\n\n\t\t/* Append callbacks to follower's \"done\" list. */\n\t\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t\ttail = rdp->nocb_follower_tail;\n\t\trdp->nocb_follower_tail = rdp->nocb_gp_tail;\n\t\t*tail = rdp->nocb_gp_head;\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tif (rdp != my_rdp && tail == &rdp->nocb_follower_head) {\n\t\t\t/* List was empty, so wake up the follower.  */\n\t\t\tswake_up_one(&rdp->nocb_wq);\n\t\t}\n\t}\n\n\t/* If we (the leader) don't have CBs, go wait some more. */\n\tif (!my_rdp->nocb_follower_head)\n\t\tgoto wait_again;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rdp->nocb_wq"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "35-42",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "my_rdp->nocb_leader_sleep"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_head"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_wait_gp",
          "args": [
            "my_rdp"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_wait_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2147-2183",
          "snippet": "static void rcu_nocb_wait_gp(struct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool d;\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlocal_irq_save(flags);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_start_this_gp(rnp, rdp, c);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n\n\t/*\n\t * Wait for the grace period.  Do so interruptibly to avoid messing\n\t * up the load average.\n\t */\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"StartWait\"));\n\tfor (;;) {\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(c) & 0x1],\n\t\t\t(d = rcu_seq_done(&rnp->gp_seq, c)));\n\t\tif (likely(d))\n\t\t\tbreak;\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"ResumeWait\"));\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"EndWait\"));\n\tsmp_mb(); /* Ensure that CB invocation happens after GP end. */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_nocb_wait_gp(struct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool d;\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlocal_irq_save(flags);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_start_this_gp(rnp, rdp, c);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n\n\t/*\n\t * Wait for the grace period.  Do so interruptibly to avoid messing\n\t * up the load average.\n\t */\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"StartWait\"));\n\tfor (;;) {\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(c) & 0x1],\n\t\t\t(d = rcu_seq_done(&rnp->gp_seq, c)));\n\t\tif (likely(d))\n\t\t\tbreak;\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"ResumeWait\"));\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"EndWait\"));\n\tsmp_mb(); /* Ensure that CB invocation happens after GP end. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "my_rdp->cpu",
            "TPS(\"WokeEmpty\")"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WokeEmpty\""
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "1"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!gotcbs"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&rdp->nocb_tail",
            "&rdp->nocb_head"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_head",
            "NULL"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_head"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "my_rdp->cpu",
            "TPS(\"Poll\")"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Poll\""
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&my_rdp->nocb_timer"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "my_rdp->nocb_defer_wakeup",
            "RCU_NOCB_WAKE_NOT"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_interruptible_exclusive",
          "args": [
            "my_rdp->nocb_wq",
            "!READ_ONCE(my_rdp->nocb_leader_sleep)"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "my_rdp->nocb_leader_sleep"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "my_rdp->cpu",
            "TPS(\"Sleep\")"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Sleep\""
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void nocb_leader_wait(struct rcu_data *my_rdp)\n{\n\tbool firsttime = true;\n\tunsigned long flags;\n\tbool gotcbs;\n\tstruct rcu_data *rdp;\n\tstruct rcu_head **tail;\n\nwait_again:\n\n\t/* Wait for callbacks to appear. */\n\tif (!rcu_nocb_poll) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Sleep\"));\n\t\tswait_event_interruptible_exclusive(my_rdp->nocb_wq,\n\t\t\t\t!READ_ONCE(my_rdp->nocb_leader_sleep));\n\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\tmy_rdp->nocb_leader_sleep = true;\n\t\tWRITE_ONCE(my_rdp->nocb_defer_wakeup, RCU_NOCB_WAKE_NOT);\n\t\tdel_timer(&my_rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t} else if (firsttime) {\n\t\tfirsttime = false; /* Don't drown trace log with \"Poll\"! */\n\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu, TPS(\"Poll\"));\n\t}\n\n\t/*\n\t * Each pass through the following loop checks a follower for CBs.\n\t * We are our own first follower.  Any CBs found are moved to\n\t * nocb_gp_head, where they await a grace period.\n\t */\n\tgotcbs = false;\n\tsmp_mb(); /* wakeup and _sleep before ->nocb_head reads. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\trdp->nocb_gp_head = READ_ONCE(rdp->nocb_head);\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue;  /* No CBs here, try next follower. */\n\n\t\t/* Move callbacks to wait-for-GP list, which is empty. */\n\t\tWRITE_ONCE(rdp->nocb_head, NULL);\n\t\trdp->nocb_gp_tail = xchg(&rdp->nocb_tail, &rdp->nocb_head);\n\t\tgotcbs = true;\n\t}\n\n\t/* No callbacks?  Sleep a bit if polling, and go retry.  */\n\tif (unlikely(!gotcbs)) {\n\t\tWARN_ON(signal_pending(current));\n\t\tif (rcu_nocb_poll) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else {\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, my_rdp->cpu,\n\t\t\t\t\t    TPS(\"WokeEmpty\"));\n\t\t}\n\t\tgoto wait_again;\n\t}\n\n\t/* Wait for one grace period. */\n\trcu_nocb_wait_gp(my_rdp);\n\n\t/* Each pass through the following loop wakes a follower, if needed. */\n\tfor (rdp = my_rdp; rdp; rdp = rdp->nocb_next_follower) {\n\t\tif (!rcu_nocb_poll &&\n\t\t    READ_ONCE(rdp->nocb_head) &&\n\t\t    READ_ONCE(my_rdp->nocb_leader_sleep)) {\n\t\t\traw_spin_lock_irqsave(&my_rdp->nocb_lock, flags);\n\t\t\tmy_rdp->nocb_leader_sleep = false;/* No need to sleep.*/\n\t\t\traw_spin_unlock_irqrestore(&my_rdp->nocb_lock, flags);\n\t\t}\n\t\tif (!rdp->nocb_gp_head)\n\t\t\tcontinue; /* No CBs, so no need to wake follower. */\n\n\t\t/* Append callbacks to follower's \"done\" list. */\n\t\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t\ttail = rdp->nocb_follower_tail;\n\t\trdp->nocb_follower_tail = rdp->nocb_gp_tail;\n\t\t*tail = rdp->nocb_gp_head;\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tif (rdp != my_rdp && tail == &rdp->nocb_follower_head) {\n\t\t\t/* List was empty, so wake up the follower.  */\n\t\t\tswake_up_one(&rdp->nocb_wq);\n\t\t}\n\t}\n\n\t/* If we (the leader) don't have CBs, go wait some more. */\n\tif (!my_rdp->nocb_follower_head)\n\t\tgoto wait_again;\n}"
  },
  {
    "function_name": "rcu_nocb_wait_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2147-2183",
    "snippet": "static void rcu_nocb_wait_gp(struct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool d;\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlocal_irq_save(flags);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_start_this_gp(rnp, rdp, c);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n\n\t/*\n\t * Wait for the grace period.  Do so interruptibly to avoid messing\n\t * up the load average.\n\t */\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"StartWait\"));\n\tfor (;;) {\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(c) & 0x1],\n\t\t\t(d = rcu_seq_done(&rnp->gp_seq, c)));\n\t\tif (likely(d))\n\t\t\tbreak;\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"ResumeWait\"));\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"EndWait\"));\n\tsmp_mb(); /* Ensure that CB invocation happens after GP end. */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "c",
            "TPS(\"EndWait\")"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1434-1439",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"EndWait\""
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"ResumeWait\""
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "d"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_interruptible_exclusive",
          "args": [
            "rnp->nocb_gp_wq[rcu_seq_ctr(c) & 0x1]",
            "(d = rcu_seq_done(&rnp->gp_seq, c))"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rnp->gp_seq",
            "c"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "c"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"StartWait\""
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_start_this_gp",
          "args": [
            "rnp",
            "rdp",
            "c"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_start_this_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1457-1526",
          "snippet": "static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\trnp->gp_seq_needed = gp_seq_req;\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\trcu_state.gp_req_activity = jiffies;\n\tif (!rcu_state.gp_kthread) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\trnp_start->gp_seq_needed = rnp->gp_seq_needed;\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\trnp->gp_seq_needed = gp_seq_req;\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\trcu_state.gp_req_activity = jiffies;\n\tif (!rcu_state.gp_kthread) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\trnp_start->gp_seq_needed = rnp->gp_seq_needed;\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rdp->gp_seq_needed",
            "c"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_nocb_wait_gp(struct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool d;\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlocal_irq_save(flags);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\tlocal_irq_restore(flags);\n\t} else {\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_start_this_gp(rnp, rdp, c);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n\n\t/*\n\t * Wait for the grace period.  Do so interruptibly to avoid messing\n\t * up the load average.\n\t */\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"StartWait\"));\n\tfor (;;) {\n\t\tswait_event_interruptible_exclusive(\n\t\t\trnp->nocb_gp_wq[rcu_seq_ctr(c) & 0x1],\n\t\t\t(d = rcu_seq_done(&rnp->gp_seq, c)));\n\t\tif (likely(d))\n\t\t\tbreak;\n\t\tWARN_ON(signal_pending(current));\n\t\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"ResumeWait\"));\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, c, TPS(\"EndWait\"));\n\tsmp_mb(); /* Ensure that CB invocation happens after GP end. */\n}"
  },
  {
    "function_name": "rcu_nocb_adopt_orphan_cbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2127-2141",
    "snippet": "static bool __maybe_unused rcu_nocb_adopt_orphan_cbs(struct rcu_data *my_rdp,\n\t\t\t\t\t\t     struct rcu_data *rdp,\n\t\t\t\t\t\t     unsigned long flags)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (!rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn false; /* Not NOCBs CPU, caller must migrate CBs. */\n\t__call_rcu_nocb_enqueue(my_rdp, rcu_segcblist_head(&rdp->cblist),\n\t\t\t\trcu_segcblist_tail(&rdp->cblist),\n\t\t\t\trcu_segcblist_n_cbs(&rdp->cblist),\n\t\t\t\trcu_segcblist_n_lazy_cbs(&rdp->cblist), flags);\n\trcu_segcblist_init(&rdp->cblist);\n\trcu_segcblist_disable(&rdp->cblist);\n\treturn true;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_disable",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "80-86",
          "snippet": "void rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_lazy_cbs(rsclp));\n\trsclp->tails[RCU_NEXT_TAIL] = NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_lazy_cbs(rsclp));\n\trsclp->tails[RCU_NEXT_TAIL] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "63-74",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__call_rcu_nocb_enqueue",
          "args": [
            "my_rdp",
            "rcu_segcblist_head(&rdp->cblist)",
            "rcu_segcblist_tail(&rdp->cblist)",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "rcu_segcblist_n_lazy_cbs(&rdp->cblist)",
            "flags"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_nocb_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2030-2082",
          "snippet": "static void __call_rcu_nocb_enqueue(struct rcu_data *rdp,\n\t\t\t\t    struct rcu_head *rhp,\n\t\t\t\t    struct rcu_head **rhtp,\n\t\t\t\t    int rhcount, int rhcount_lazy,\n\t\t\t\t    unsigned long flags)\n{\n\tint len;\n\tstruct rcu_head **old_rhpp;\n\tstruct task_struct *t;\n\n\t/* Enqueue the callback on the nocb list and update counts. */\n\tatomic_long_add(rhcount, &rdp->nocb_q_count);\n\t/* rcu_barrier() relies on ->nocb_q_count add before xchg. */\n\told_rhpp = xchg(&rdp->nocb_tail, rhtp);\n\tWRITE_ONCE(*old_rhpp, rhp);\n\tatomic_long_add(rhcount_lazy, &rdp->nocb_q_count_lazy);\n\tsmp_mb__after_atomic(); /* Store *old_rhpp before _wake test. */\n\n\t/* If we are not being polled and there is a kthread, awaken it ... */\n\tt = READ_ONCE(rdp->nocb_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\tlen = atomic_long_read(&rdp->nocb_q_count);\n\tif (old_rhpp == &rdp->nocb_head) {\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\twake_nocb_leader(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t       TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = 0;\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\twake_nocb_leader(rdp, true);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeOvf\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t       TPS(\"WakeOvfIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = LONG_MAX / 2;\n\t} else {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __call_rcu_nocb_enqueue(struct rcu_data *rdp,\n\t\t\t\t    struct rcu_head *rhp,\n\t\t\t\t    struct rcu_head **rhtp,\n\t\t\t\t    int rhcount, int rhcount_lazy,\n\t\t\t\t    unsigned long flags)\n{\n\tint len;\n\tstruct rcu_head **old_rhpp;\n\tstruct task_struct *t;\n\n\t/* Enqueue the callback on the nocb list and update counts. */\n\tatomic_long_add(rhcount, &rdp->nocb_q_count);\n\t/* rcu_barrier() relies on ->nocb_q_count add before xchg. */\n\told_rhpp = xchg(&rdp->nocb_tail, rhtp);\n\tWRITE_ONCE(*old_rhpp, rhp);\n\tatomic_long_add(rhcount_lazy, &rdp->nocb_q_count_lazy);\n\tsmp_mb__after_atomic(); /* Store *old_rhpp before _wake test. */\n\n\t/* If we are not being polled and there is a kthread, awaken it ... */\n\tt = READ_ONCE(rdp->nocb_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\tlen = atomic_long_read(&rdp->nocb_q_count);\n\tif (old_rhpp == &rdp->nocb_head) {\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\twake_nocb_leader(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t       TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = 0;\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\twake_nocb_leader(rdp, true);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeOvf\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t       TPS(\"WakeOvfIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = LONG_MAX / 2;\n\t} else {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_lazy_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_lazy_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-65",
          "snippet": "static inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_tail",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "107-111",
          "snippet": "static inline struct rcu_head **rcu_segcblist_tail(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(rcu_segcblist_empty(rsclp));\n\treturn rsclp->tails[RCU_NEXT_TAIL];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline struct rcu_head **rcu_segcblist_tail(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(rcu_segcblist_empty(rsclp));\n\treturn rsclp->tails[RCU_NEXT_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_head",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "97-100",
          "snippet": "static inline struct rcu_head *rcu_segcblist_head(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline struct rcu_head *rcu_segcblist_head(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool __maybe_unused rcu_nocb_adopt_orphan_cbs(struct rcu_data *my_rdp,\n\t\t\t\t\t\t     struct rcu_data *rdp,\n\t\t\t\t\t\t     unsigned long flags)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (!rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn false; /* Not NOCBs CPU, caller must migrate CBs. */\n\t__call_rcu_nocb_enqueue(my_rdp, rcu_segcblist_head(&rdp->cblist),\n\t\t\t\trcu_segcblist_tail(&rdp->cblist),\n\t\t\t\trcu_segcblist_n_cbs(&rdp->cblist),\n\t\t\t\trcu_segcblist_n_lazy_cbs(&rdp->cblist), flags);\n\trcu_segcblist_init(&rdp->cblist);\n\trcu_segcblist_disable(&rdp->cblist);\n\treturn true;\n}"
  },
  {
    "function_name": "__call_rcu_nocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2093-2121",
    "snippet": "static bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t    bool lazy, unsigned long flags)\n{\n\n\tif (!rcu_is_nocb_cpu(rdp->cpu))\n\t\treturn false;\n\t__call_rcu_nocb_enqueue(rdp, rhp, &rhp->next, 1, lazy, flags);\n\tif (__is_kfree_rcu_offset((unsigned long)rhp->func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, rhp,\n\t\t\t\t\t (unsigned long)rhp->func,\n\t\t\t\t\t -atomic_long_read(&rdp->nocb_q_count_lazy),\n\t\t\t\t\t -atomic_long_read(&rdp->nocb_q_count));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, rhp,\n\t\t\t\t   -atomic_long_read(&rdp->nocb_q_count_lazy),\n\t\t\t\t   -atomic_long_read(&rdp->nocb_q_count));\n\n\t/*\n\t * If called from an extended quiescent state with interrupts\n\t * disabled, invoke the RCU core in order to allow the idle-entry\n\t * deferred-wakeup check to function.\n\t */\n\tif (irqs_disabled_flags(flags) &&\n\t    !rcu_is_watching() &&\n\t    cpu_online(smp_processor_id()))\n\t\tinvoke_rcu_core();\n\n\treturn true;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_callback",
          "args": [
            "rcu_state.name",
            "rhp",
            "-atomic_long_read(&rdp->nocb_q_count_lazy)",
            "-atomic_long_read(&rdp->nocb_q_count)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count_lazy"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_kfree_callback",
          "args": [
            "rcu_state.name",
            "rhp",
            "(unsigned long)rhp->func",
            "-atomic_long_read(&rdp->nocb_q_count_lazy)",
            "-atomic_long_read(&rdp->nocb_q_count)"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count_lazy"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_kfree_rcu_offset",
          "args": [
            "(unsigned long)rhp->func"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__call_rcu_nocb_enqueue",
          "args": [
            "rdp",
            "rhp",
            "&rhp->next",
            "1",
            "lazy",
            "flags"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_nocb_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2030-2082",
          "snippet": "static void __call_rcu_nocb_enqueue(struct rcu_data *rdp,\n\t\t\t\t    struct rcu_head *rhp,\n\t\t\t\t    struct rcu_head **rhtp,\n\t\t\t\t    int rhcount, int rhcount_lazy,\n\t\t\t\t    unsigned long flags)\n{\n\tint len;\n\tstruct rcu_head **old_rhpp;\n\tstruct task_struct *t;\n\n\t/* Enqueue the callback on the nocb list and update counts. */\n\tatomic_long_add(rhcount, &rdp->nocb_q_count);\n\t/* rcu_barrier() relies on ->nocb_q_count add before xchg. */\n\told_rhpp = xchg(&rdp->nocb_tail, rhtp);\n\tWRITE_ONCE(*old_rhpp, rhp);\n\tatomic_long_add(rhcount_lazy, &rdp->nocb_q_count_lazy);\n\tsmp_mb__after_atomic(); /* Store *old_rhpp before _wake test. */\n\n\t/* If we are not being polled and there is a kthread, awaken it ... */\n\tt = READ_ONCE(rdp->nocb_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\tlen = atomic_long_read(&rdp->nocb_q_count);\n\tif (old_rhpp == &rdp->nocb_head) {\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\twake_nocb_leader(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t       TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = 0;\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\twake_nocb_leader(rdp, true);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeOvf\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t       TPS(\"WakeOvfIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = LONG_MAX / 2;\n\t} else {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __call_rcu_nocb_enqueue(struct rcu_data *rdp,\n\t\t\t\t    struct rcu_head *rhp,\n\t\t\t\t    struct rcu_head **rhtp,\n\t\t\t\t    int rhcount, int rhcount_lazy,\n\t\t\t\t    unsigned long flags)\n{\n\tint len;\n\tstruct rcu_head **old_rhpp;\n\tstruct task_struct *t;\n\n\t/* Enqueue the callback on the nocb list and update counts. */\n\tatomic_long_add(rhcount, &rdp->nocb_q_count);\n\t/* rcu_barrier() relies on ->nocb_q_count add before xchg. */\n\told_rhpp = xchg(&rdp->nocb_tail, rhtp);\n\tWRITE_ONCE(*old_rhpp, rhp);\n\tatomic_long_add(rhcount_lazy, &rdp->nocb_q_count_lazy);\n\tsmp_mb__after_atomic(); /* Store *old_rhpp before _wake test. */\n\n\t/* If we are not being polled and there is a kthread, awaken it ... */\n\tt = READ_ONCE(rdp->nocb_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\tlen = atomic_long_read(&rdp->nocb_q_count);\n\tif (old_rhpp == &rdp->nocb_head) {\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\twake_nocb_leader(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t       TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = 0;\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\twake_nocb_leader(rdp, true);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeOvf\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t       TPS(\"WakeOvfIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = LONG_MAX / 2;\n\t} else {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t    bool lazy, unsigned long flags)\n{\n\n\tif (!rcu_is_nocb_cpu(rdp->cpu))\n\t\treturn false;\n\t__call_rcu_nocb_enqueue(rdp, rhp, &rhp->next, 1, lazy, flags);\n\tif (__is_kfree_rcu_offset((unsigned long)rhp->func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, rhp,\n\t\t\t\t\t (unsigned long)rhp->func,\n\t\t\t\t\t -atomic_long_read(&rdp->nocb_q_count_lazy),\n\t\t\t\t\t -atomic_long_read(&rdp->nocb_q_count));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, rhp,\n\t\t\t\t   -atomic_long_read(&rdp->nocb_q_count_lazy),\n\t\t\t\t   -atomic_long_read(&rdp->nocb_q_count));\n\n\t/*\n\t * If called from an extended quiescent state with interrupts\n\t * disabled, invoke the RCU core in order to allow the idle-entry\n\t * deferred-wakeup check to function.\n\t */\n\tif (irqs_disabled_flags(flags) &&\n\t    !rcu_is_watching() &&\n\t    cpu_online(smp_processor_id()))\n\t\tinvoke_rcu_core();\n\n\treturn true;\n}"
  },
  {
    "function_name": "__call_rcu_nocb_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "2030-2082",
    "snippet": "static void __call_rcu_nocb_enqueue(struct rcu_data *rdp,\n\t\t\t\t    struct rcu_head *rhp,\n\t\t\t\t    struct rcu_head **rhtp,\n\t\t\t\t    int rhcount, int rhcount_lazy,\n\t\t\t\t    unsigned long flags)\n{\n\tint len;\n\tstruct rcu_head **old_rhpp;\n\tstruct task_struct *t;\n\n\t/* Enqueue the callback on the nocb list and update counts. */\n\tatomic_long_add(rhcount, &rdp->nocb_q_count);\n\t/* rcu_barrier() relies on ->nocb_q_count add before xchg. */\n\told_rhpp = xchg(&rdp->nocb_tail, rhtp);\n\tWRITE_ONCE(*old_rhpp, rhp);\n\tatomic_long_add(rhcount_lazy, &rdp->nocb_q_count_lazy);\n\tsmp_mb__after_atomic(); /* Store *old_rhpp before _wake test. */\n\n\t/* If we are not being polled and there is a kthread, awaken it ... */\n\tt = READ_ONCE(rdp->nocb_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\tlen = atomic_long_read(&rdp->nocb_q_count);\n\tif (old_rhpp == &rdp->nocb_head) {\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\twake_nocb_leader(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t       TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = 0;\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\twake_nocb_leader(rdp, true);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeOvf\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t       TPS(\"WakeOvfIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = LONG_MAX / 2;\n\t} else {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeNot\")"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeNot\""
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_nocb_leader_defer",
          "args": [
            "rdp",
            "RCU_NOCB_WAKE_FORCE",
            "TPS(\"WakeOvfIsDeferred\")"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "wake_nocb_leader_defer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1963-1974",
          "snippet": "static void wake_nocb_leader_defer(struct rcu_data *rdp, int waketype,\n\t\t\t\t   const char *reason)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (rdp->nocb_defer_wakeup == RCU_NOCB_WAKE_NOT)\n\t\tmod_timer(&rdp->nocb_timer, jiffies + 1);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, waketype);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void wake_nocb_leader_defer(struct rcu_data *rdp, int waketype,\n\t\t\t\t   const char *reason)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (rdp->nocb_defer_wakeup == RCU_NOCB_WAKE_NOT)\n\t\tmod_timer(&rdp->nocb_timer, jiffies + 1);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, waketype);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeOvfIsDeferred\""
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeOvf\")"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeOvf\""
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_nocb_leader",
          "args": [
            "rdp",
            "true"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "wake_nocb_leader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1951-1957",
          "snippet": "static void wake_nocb_leader(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t__wake_nocb_leader(rdp, force, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void wake_nocb_leader(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t__wake_nocb_leader(rdp, force, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeEmptyIsDeferred\""
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeEmpty\")"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeEmpty\""
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "TPS(\"WakeNotPoll\")"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"WakeNotPoll\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_kthread"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "rhcount_lazy",
            "&rdp->nocb_q_count_lazy"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*old_rhpp",
            "rhp"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&rdp->nocb_tail",
            "rhtp"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "rhcount",
            "&rdp->nocb_q_count"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __call_rcu_nocb_enqueue(struct rcu_data *rdp,\n\t\t\t\t    struct rcu_head *rhp,\n\t\t\t\t    struct rcu_head **rhtp,\n\t\t\t\t    int rhcount, int rhcount_lazy,\n\t\t\t\t    unsigned long flags)\n{\n\tint len;\n\tstruct rcu_head **old_rhpp;\n\tstruct task_struct *t;\n\n\t/* Enqueue the callback on the nocb list and update counts. */\n\tatomic_long_add(rhcount, &rdp->nocb_q_count);\n\t/* rcu_barrier() relies on ->nocb_q_count add before xchg. */\n\told_rhpp = xchg(&rdp->nocb_tail, rhtp);\n\tWRITE_ONCE(*old_rhpp, rhp);\n\tatomic_long_add(rhcount_lazy, &rdp->nocb_q_count_lazy);\n\tsmp_mb__after_atomic(); /* Store *old_rhpp before _wake test. */\n\n\t/* If we are not being polled and there is a kthread, awaken it ... */\n\tt = READ_ONCE(rdp->nocb_kthread);\n\tif (rcu_nocb_poll || !t) {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t    TPS(\"WakeNotPoll\"));\n\t\treturn;\n\t}\n\tlen = atomic_long_read(&rdp->nocb_q_count);\n\tif (old_rhpp == &rdp->nocb_head) {\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\t/* ... if queue was empty ... */\n\t\t\twake_nocb_leader(rdp, false);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeEmpty\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE,\n\t\t\t\t\t       TPS(\"WakeEmptyIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = 0;\n\t} else if (len > rdp->qlen_last_fqs_check + qhimark) {\n\t\t/* ... or if many callbacks queued. */\n\t\tif (!irqs_disabled_flags(flags)) {\n\t\t\twake_nocb_leader(rdp, true);\n\t\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu,\n\t\t\t\t\t    TPS(\"WakeOvf\"));\n\t\t} else {\n\t\t\twake_nocb_leader_defer(rdp, RCU_NOCB_WAKE_FORCE,\n\t\t\t\t\t       TPS(\"WakeOvfIsDeferred\"));\n\t\t}\n\t\trdp->qlen_last_fqs_check = LONG_MAX / 2;\n\t} else {\n\t\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS(\"WakeNot\"));\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "rcu_nocb_cpu_needs_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1980-2020",
    "snippet": "static bool rcu_nocb_cpu_needs_barrier(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tunsigned long ret;\n#ifdef CONFIG_PROVE_RCU\n\tstruct rcu_head *rhp;\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\n\t/*\n\t * Check count of all no-CBs callbacks awaiting invocation.\n\t * There needs to be a barrier before this function is called,\n\t * but associated with a prior determination that no more\n\t * callbacks would be posted.  In the worst case, the first\n\t * barrier in rcu_barrier() suffices (but the caller cannot\n\t * necessarily rely on this, not a substitute for the caller\n\t * getting the concurrency design right!).  There must also be\n\t * a barrier between the following load an posting of a callback\n\t * (if a callback is in fact needed).  This is associated with an\n\t * atomic_inc() in the caller.\n\t */\n\tret = atomic_long_read(&rdp->nocb_q_count);\n\n#ifdef CONFIG_PROVE_RCU\n\trhp = READ_ONCE(rdp->nocb_head);\n\tif (!rhp)\n\t\trhp = READ_ONCE(rdp->nocb_gp_head);\n\tif (!rhp)\n\t\trhp = READ_ONCE(rdp->nocb_follower_head);\n\n\t/* Having no rcuo kthread but CBs after scheduler starts is bad! */\n\tif (!READ_ONCE(rdp->nocb_kthread) && rhp &&\n\t    rcu_scheduler_fully_active) {\n\t\t/* RCU callback enqueued before CPU first came online??? */\n\t\tpr_err(\"RCU: Never-onlined no-CBs CPU %d has CB %p\\n\",\n\t\t       cpu, rhp->func);\n\t\tWARN_ON_ONCE(1);\n\t}\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\n\treturn !!ret;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RCU: Never-onlined no-CBs CPU %d has CB %p\\n\"",
            "cpu",
            "rhp->func"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_kthread"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_follower_head"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_gp_head"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->nocb_head"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&rdp->nocb_q_count"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_nocb_cpu_needs_barrier(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tunsigned long ret;\n#ifdef CONFIG_PROVE_RCU\n\tstruct rcu_head *rhp;\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\n\t/*\n\t * Check count of all no-CBs callbacks awaiting invocation.\n\t * There needs to be a barrier before this function is called,\n\t * but associated with a prior determination that no more\n\t * callbacks would be posted.  In the worst case, the first\n\t * barrier in rcu_barrier() suffices (but the caller cannot\n\t * necessarily rely on this, not a substitute for the caller\n\t * getting the concurrency design right!).  There must also be\n\t * a barrier between the following load an posting of a callback\n\t * (if a callback is in fact needed).  This is associated with an\n\t * atomic_inc() in the caller.\n\t */\n\tret = atomic_long_read(&rdp->nocb_q_count);\n\n#ifdef CONFIG_PROVE_RCU\n\trhp = READ_ONCE(rdp->nocb_head);\n\tif (!rhp)\n\t\trhp = READ_ONCE(rdp->nocb_gp_head);\n\tif (!rhp)\n\t\trhp = READ_ONCE(rdp->nocb_follower_head);\n\n\t/* Having no rcuo kthread but CBs after scheduler starts is bad! */\n\tif (!READ_ONCE(rdp->nocb_kthread) && rhp &&\n\t    rcu_scheduler_fully_active) {\n\t\t/* RCU callback enqueued before CPU first came online??? */\n\t\tpr_err(\"RCU: Never-onlined no-CBs CPU %d has CB %p\\n\",\n\t\t       cpu, rhp->func);\n\t\tWARN_ON_ONCE(1);\n\t}\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\n\treturn !!ret;\n}"
  },
  {
    "function_name": "wake_nocb_leader_defer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1963-1974",
    "snippet": "static void wake_nocb_leader_defer(struct rcu_data *rdp, int waketype,\n\t\t\t\t   const char *reason)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (rdp->nocb_defer_wakeup == RCU_NOCB_WAKE_NOT)\n\t\tmod_timer(&rdp->nocb_timer, jiffies + 1);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, waketype);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_nocb_wake",
          "args": [
            "rcu_state.name",
            "rdp->cpu",
            "reason"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->nocb_defer_wakeup",
            "waketype"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&rdp->nocb_timer",
            "jiffies + 1"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void wake_nocb_leader_defer(struct rcu_data *rdp, int waketype,\n\t\t\t\t   const char *reason)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\tif (rdp->nocb_defer_wakeup == RCU_NOCB_WAKE_NOT)\n\t\tmod_timer(&rdp->nocb_timer, jiffies + 1);\n\tWRITE_ONCE(rdp->nocb_defer_wakeup, waketype);\n\ttrace_rcu_nocb_wake(rcu_state.name, rdp->cpu, reason);\n\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n}"
  },
  {
    "function_name": "wake_nocb_leader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1951-1957",
    "snippet": "static void wake_nocb_leader(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t__wake_nocb_leader(rdp, force, flags);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_nocb_leader",
          "args": [
            "rdp",
            "force",
            "flags"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_nocb_leader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1924-1945",
          "snippet": "static void __wake_nocb_leader(struct rcu_data *rdp, bool force,\n\t\t\t       unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_data *rdp_leader = rdp->nocb_leader;\n\n\tlockdep_assert_held(&rdp->nocb_lock);\n\tif (!READ_ONCE(rdp_leader->nocb_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tif (rdp_leader->nocb_leader_sleep || force) {\n\t\t/* Prior smp_mb__after_atomic() orders against prior enqueue. */\n\t\tWRITE_ONCE(rdp_leader->nocb_leader_sleep, false);\n\t\tdel_timer(&rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tsmp_mb(); /* ->nocb_leader_sleep before swake_up_one(). */\n\t\tswake_up_one(&rdp_leader->nocb_wq);\n\t} else {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __wake_nocb_leader(struct rcu_data *rdp, bool force,\n\t\t\t       unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_data *rdp_leader = rdp->nocb_leader;\n\n\tlockdep_assert_held(&rdp->nocb_lock);\n\tif (!READ_ONCE(rdp_leader->nocb_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tif (rdp_leader->nocb_leader_sleep || force) {\n\t\t/* Prior smp_mb__after_atomic() orders against prior enqueue. */\n\t\tWRITE_ONCE(rdp_leader->nocb_leader_sleep, false);\n\t\tdel_timer(&rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tsmp_mb(); /* ->nocb_leader_sleep before swake_up_one(). */\n\t\tswake_up_one(&rdp_leader->nocb_wq);\n\t} else {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void wake_nocb_leader(struct rcu_data *rdp, bool force)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rdp->nocb_lock, flags);\n\t__wake_nocb_leader(rdp, force, flags);\n}"
  },
  {
    "function_name": "__wake_nocb_leader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1924-1945",
    "snippet": "static void __wake_nocb_leader(struct rcu_data *rdp, bool force,\n\t\t\t       unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_data *rdp_leader = rdp->nocb_leader;\n\n\tlockdep_assert_held(&rdp->nocb_lock);\n\tif (!READ_ONCE(rdp_leader->nocb_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tif (rdp_leader->nocb_leader_sleep || force) {\n\t\t/* Prior smp_mb__after_atomic() orders against prior enqueue. */\n\t\tWRITE_ONCE(rdp_leader->nocb_leader_sleep, false);\n\t\tdel_timer(&rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tsmp_mb(); /* ->nocb_leader_sleep before swake_up_one(). */\n\t\tswake_up_one(&rdp_leader->nocb_wq);\n\t} else {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rdp->nocb_lock",
            "flags"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rdp_leader->nocb_wq"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "35-42",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&rdp->nocb_timer"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp_leader->nocb_leader_sleep",
            "false"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp_leader->nocb_kthread"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rdp->nocb_lock"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rdp->nocb_lock"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __wake_nocb_leader(struct rcu_data *rdp, bool force,\n\t\t\t       unsigned long flags)\n\t__releases(rdp->nocb_lock)\n{\n\tstruct rcu_data *rdp_leader = rdp->nocb_leader;\n\n\tlockdep_assert_held(&rdp->nocb_lock);\n\tif (!READ_ONCE(rdp_leader->nocb_kthread)) {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\treturn;\n\t}\n\tif (rdp_leader->nocb_leader_sleep || force) {\n\t\t/* Prior smp_mb__after_atomic() orders against prior enqueue. */\n\t\tWRITE_ONCE(rdp_leader->nocb_leader_sleep, false);\n\t\tdel_timer(&rdp->nocb_timer);\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t\tsmp_mb(); /* ->nocb_leader_sleep before swake_up_one(). */\n\t\tswake_up_one(&rdp_leader->nocb_wq);\n\t} else {\n\t\traw_spin_unlock_irqrestore(&rdp->nocb_lock, flags);\n\t}\n}"
  },
  {
    "function_name": "rcu_is_nocb_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1913-1918",
    "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "rcu_nocb_mask"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "rcu_nocb_mask"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_init_one_nocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1906-1910",
    "snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[0]);\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[1]);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rnp->nocb_gp_wq[1]"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rnp->nocb_gp_wq[0]"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[0]);\n\tinit_swait_queue_head(&rnp->nocb_gp_wq[1]);\n}"
  },
  {
    "function_name": "rcu_nocb_gp_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1901-1904",
    "snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn &rnp->nocb_gp_wq[rcu_seq_ctr(rnp->gp_seq) & 0x1];\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rnp->gp_seq"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn &rnp->nocb_gp_wq[rcu_seq_ctr(rnp->gp_seq) & 0x1];\n}"
  },
  {
    "function_name": "rcu_nocb_gp_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1896-1899",
    "snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n\tswake_up_all(sq);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_all",
          "args": [
            "sq"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "49-69",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n\tswake_up_all(sq);\n}"
  },
  {
    "function_name": "parse_rcu_nocb_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1885-1889",
    "snippet": "static int __init parse_rcu_nocb_poll(char *arg)\n{\n\trcu_nocb_poll = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int __init parse_rcu_nocb_poll(char *arg)\n{\n\trcu_nocb_poll = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_nocb_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1877-1882",
    "snippet": "static int __init rcu_nocb_setup(char *str)\n{\n\talloc_bootmem_cpumask_var(&rcu_nocb_mask);\n\tcpulist_parse(str, rcu_nocb_mask);\n\treturn 1;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpulist_parse",
          "args": [
            "str",
            "rcu_nocb_mask"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_bootmem_cpumask_var",
          "args": [
            "&rcu_nocb_mask"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int __init rcu_nocb_setup(char *str)\n{\n\talloc_bootmem_cpumask_var(&rcu_nocb_mask);\n\tcpulist_parse(str, rcu_nocb_mask);\n\treturn 1;\n}"
  },
  {
    "function_name": "zero_cpu_stall_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1846-1851",
    "snippet": "static void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->last_fqs_resched",
            "jiffies"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_softirqs_cpu",
          "args": [
            "RCU_SOFTIRQ",
            "smp_processor_id()"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}"
  },
  {
    "function_name": "print_cpu_stall_info_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1840-1843",
    "snippet": "static void print_cpu_stall_info_end(void)\n{\n\tpr_err(\"\\t\");\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\t\""
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info_end(void)\n{\n\tpr_err(\"\\t\");\n}"
  },
  {
    "function_name": "print_cpu_stall_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1800-1837",
    "snippet": "static void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tchar fast_no_hz[72];\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tprint_cpu_stall_fast_no_hz(fast_no_hz, cpu);\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       fast_no_hz);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\"",
            "cpu",
            "\"O.\"[!!cpu_online(cpu)]",
            "\"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)]",
            "\"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)]",
            "!IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta]",
            "ticks_value",
            "ticks_title",
            "rcu_dynticks_snap(rdp) & 0xfff",
            "rdp->dynticks_nesting",
            "rdp->dynticks_nmi_nesting",
            "rdp->softirq_snap",
            "kstat_softirqs_cpu(RCU_SOFTIRQ, cpu)",
            "READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart",
            "fast_no_hz"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_softirqs_cpu",
          "args": [
            "RCU_SOFTIRQ",
            "cpu"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "299-304",
          "snippet": "int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "delta",
            "9UL"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_WORK"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_fast_no_hz",
          "args": [
            "fast_no_hz",
            "cpu"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_fast_no_hz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1776-1779",
          "snippet": "static void print_cpu_stall_fast_no_hz(char *cp, int cpu)\n{\n\t*cp = '\\0';\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_fast_no_hz(char *cp, int cpu)\n{\n\t*cp = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tchar fast_no_hz[72];\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tprint_cpu_stall_fast_no_hz(fast_no_hz, cpu);\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       fast_no_hz);\n}"
  },
  {
    "function_name": "print_cpu_stall_info_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1784-1787",
    "snippet": "static void print_cpu_stall_info_begin(void)\n{\n\tpr_cont(\"\\n\");\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info_begin(void)\n{\n\tpr_cont(\"\\n\");\n}"
  },
  {
    "function_name": "print_cpu_stall_fast_no_hz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1776-1779",
    "snippet": "static void print_cpu_stall_fast_no_hz(char *cp, int cpu)\n{\n\t*cp = '\\0';\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_fast_no_hz(char *cp, int cpu)\n{\n\t*cp = '\\0';\n}"
  },
  {
    "function_name": "print_cpu_stall_fast_no_hz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1762-1772",
    "snippet": "static void print_cpu_stall_fast_no_hz(char *cp, int cpu)\n{\n\tstruct rcu_data *rdp = &per_cpu(rcu_data, cpu);\n\tunsigned long nlpd = rdp->nonlazy_posted - rdp->nonlazy_posted_snap;\n\n\tsprintf(cp, \"last_accelerate: %04lx/%04lx, nonlazy_posted: %ld, %c%c\",\n\t\trdp->last_accelerate & 0xffff, jiffies & 0xffff,\n\t\tulong2long(nlpd),\n\t\trdp->all_lazy ? 'L' : '.',\n\t\trdp->tick_nohz_enabled_snap ? '.' : 'D');\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"last_accelerate: %04lx/%04lx, nonlazy_posted: %ld, %c%c\"",
            "rdp->last_accelerate & 0xffff",
            "jiffies & 0xffff",
            "ulong2long(nlpd)",
            "rdp->all_lazy ? 'L' : '.'",
            "rdp->tick_nohz_enabled_snap ? '.' : 'D'"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulong2long",
          "args": [
            "nlpd"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_data",
            "cpu"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_fast_no_hz(char *cp, int cpu)\n{\n\tstruct rcu_data *rdp = &per_cpu(rcu_data, cpu);\n\tunsigned long nlpd = rdp->nonlazy_posted - rdp->nonlazy_posted_snap;\n\n\tsprintf(cp, \"last_accelerate: %04lx/%04lx, nonlazy_posted: %ld, %c%c\",\n\t\trdp->last_accelerate & 0xffff, jiffies & 0xffff,\n\t\tulong2long(nlpd),\n\t\trdp->all_lazy ? 'L' : '.',\n\t\trdp->tick_nohz_enabled_snap ? '.' : 'D');\n}"
  },
  {
    "function_name": "rcu_idle_count_callbacks_posted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1753-1756",
    "snippet": "static void rcu_idle_count_callbacks_posted(void)\n{\n\t__this_cpu_add(rcu_data.nonlazy_posted, 1);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "rcu_data.nonlazy_posted",
            "1"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_idle_count_callbacks_posted(void)\n{\n\t__this_cpu_add(rcu_data.nonlazy_posted, 1);\n}"
  },
  {
    "function_name": "rcu_cleanup_after_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1736-1743",
    "snippet": "static void rcu_cleanup_after_idle(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\tif (rcu_try_advance_all_cbs())\n\t\tinvoke_rcu_core();\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_try_advance_all_cbs",
          "args": [],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cleanup_after_idle(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\tif (rcu_try_advance_all_cbs())\n\t\tinvoke_rcu_core();\n}"
  },
  {
    "function_name": "rcu_prepare_for_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1679-1729",
    "snippet": "static void rcu_prepare_for_idle(void)\n{\n\tbool needwake;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\tint tne;\n\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\n\t/* Handle nohz enablement switches conservatively. */\n\ttne = READ_ONCE(tick_nohz_active);\n\tif (tne != rdp->tick_nohz_enabled_snap) {\n\t\tif (rcu_cpu_has_callbacks(NULL))\n\t\t\tinvoke_rcu_core(); /* force nohz to see update. */\n\t\trdp->tick_nohz_enabled_snap = tne;\n\t\treturn;\n\t}\n\tif (!tne)\n\t\treturn;\n\n\t/*\n\t * If a non-lazy callback arrived at a CPU having only lazy\n\t * callbacks, invoke RCU core for the side-effect of recalculating\n\t * idle duration on re-entry to idle.\n\t */\n\tif (rdp->all_lazy &&\n\t    rdp->nonlazy_posted != rdp->nonlazy_posted_snap) {\n\t\trdp->all_lazy = false;\n\t\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\t\tinvoke_rcu_core();\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have not yet accelerated this jiffy, accelerate all\n\t * callbacks on this CPU.\n\t */\n\tif (rdp->last_accelerate == jiffies)\n\t\treturn;\n\trdp->last_accelerate = jiffies;\n\tif (rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "102-106",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cpu_has_callbacks",
          "args": [
            "NULL"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_has_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2999-3014",
          "snippet": "static bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tick_nohz_active"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_for_idle(void)\n{\n\tbool needwake;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\tint tne;\n\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\n\t/* Handle nohz enablement switches conservatively. */\n\ttne = READ_ONCE(tick_nohz_active);\n\tif (tne != rdp->tick_nohz_enabled_snap) {\n\t\tif (rcu_cpu_has_callbacks(NULL))\n\t\t\tinvoke_rcu_core(); /* force nohz to see update. */\n\t\trdp->tick_nohz_enabled_snap = tne;\n\t\treturn;\n\t}\n\tif (!tne)\n\t\treturn;\n\n\t/*\n\t * If a non-lazy callback arrived at a CPU having only lazy\n\t * callbacks, invoke RCU core for the side-effect of recalculating\n\t * idle duration on re-entry to idle.\n\t */\n\tif (rdp->all_lazy &&\n\t    rdp->nonlazy_posted != rdp->nonlazy_posted_snap) {\n\t\trdp->all_lazy = false;\n\t\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\t\tinvoke_rcu_core();\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have not yet accelerated this jiffy, accelerate all\n\t * callbacks on this CPU.\n\t */\n\tif (rdp->last_accelerate == jiffies)\n\t\treturn;\n\trdp->last_accelerate = jiffies;\n\tif (rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}"
  },
  {
    "function_name": "rcu_needs_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1634-1667",
    "snippet": "int rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tunsigned long dj;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Snapshot to detect later posting of non-lazy callback. */\n\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\n\t/* If no callbacks, RCU doesn't need the CPU. */\n\tif (!rcu_cpu_has_callbacks(&rdp->all_lazy)) {\n\t\t*nextevt = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\t/* Attempt to advance callbacks. */\n\tif (rcu_try_advance_all_cbs()) {\n\t\t/* Some ready to invoke, so initiate later invocation. */\n\t\tinvoke_rcu_core();\n\t\treturn 1;\n\t}\n\trdp->last_accelerate = jiffies;\n\n\t/* Request timer delay depending on laziness, and round. */\n\tif (!rdp->all_lazy) {\n\t\tdj = round_up(rcu_idle_gp_delay + jiffies,\n\t\t\t       rcu_idle_gp_delay) - jiffies;\n\t} else {\n\t\tdj = round_jiffies(rcu_idle_lazy_gp_delay + jiffies) - jiffies;\n\t}\n\t*nextevt = basemono + dj * TICK_NSEC;\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies",
          "args": [
            "rcu_idle_lazy_gp_delay + jiffies"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_up_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "466-469",
          "snippet": "unsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "rcu_idle_gp_delay + jiffies",
            "rcu_idle_gp_delay"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_try_advance_all_cbs",
          "args": [],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cpu_has_callbacks",
          "args": [
            "&rdp->all_lazy"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_has_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2999-3014",
          "snippet": "static bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nint rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tunsigned long dj;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Snapshot to detect later posting of non-lazy callback. */\n\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\n\t/* If no callbacks, RCU doesn't need the CPU. */\n\tif (!rcu_cpu_has_callbacks(&rdp->all_lazy)) {\n\t\t*nextevt = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\t/* Attempt to advance callbacks. */\n\tif (rcu_try_advance_all_cbs()) {\n\t\t/* Some ready to invoke, so initiate later invocation. */\n\t\tinvoke_rcu_core();\n\t\treturn 1;\n\t}\n\trdp->last_accelerate = jiffies;\n\n\t/* Request timer delay depending on laziness, and round. */\n\tif (!rdp->all_lazy) {\n\t\tdj = round_up(rcu_idle_gp_delay + jiffies,\n\t\t\t       rcu_idle_gp_delay) - jiffies;\n\t} else {\n\t\tdj = round_jiffies(rcu_idle_lazy_gp_delay + jiffies) - jiffies;\n\t}\n\t*nextevt = basemono + dj * TICK_NSEC;\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_idle_count_callbacks_posted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1555-1557",
    "snippet": "static void rcu_idle_count_callbacks_posted(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_idle_count_callbacks_posted(void)\n{\n}"
  },
  {
    "function_name": "rcu_prepare_for_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1547-1549",
    "snippet": "static void rcu_prepare_for_idle(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_for_idle(void)\n{\n}"
  },
  {
    "function_name": "rcu_cleanup_after_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1539-1541",
    "snippet": "static void rcu_cleanup_after_idle(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cleanup_after_idle(void)\n{\n}"
  },
  {
    "function_name": "rcu_needs_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1529-1533",
    "snippet": "int rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\t*nextevt = KTIME_MAX;\n\treturn rcu_cpu_has_callbacks(NULL);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_cpu_has_callbacks",
          "args": [
            "NULL"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_has_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2999-3014",
          "snippet": "static bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nint rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\t*nextevt = KTIME_MAX;\n\treturn rcu_cpu_has_callbacks(NULL);\n}"
  },
  {
    "function_name": "rcu_prepare_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1512-1514",
    "snippet": "static void rcu_prepare_kthreads(int cpu)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_kthreads(int cpu)\n{\n}"
  },
  {
    "function_name": "rcu_spawn_boost_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1508-1510",
    "snippet": "static void __init rcu_spawn_boost_kthreads(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_spawn_boost_kthreads(void)\n{\n}"
  },
  {
    "function_name": "rcu_boost_kthread_setaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1504-1506",
    "snippet": "static void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}"
  },
  {
    "function_name": "rcu_preempt_boost_start_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1500-1502",
    "snippet": "static void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n}"
  },
  {
    "function_name": "rcu_is_callbacks_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1495-1498",
    "snippet": "static bool rcu_is_callbacks_kthread(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_is_callbacks_kthread(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "invoke_rcu_callbacks_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1490-1493",
    "snippet": "static void invoke_rcu_callbacks_kthread(void)\n{\n\tWARN_ON_ONCE(1);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void invoke_rcu_callbacks_kthread(void)\n{\n\tWARN_ON_ONCE(1);\n}"
  },
  {
    "function_name": "rcu_initiate_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1484-1488",
    "snippet": "static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
  },
  {
    "function_name": "rcu_prepare_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1472-1480",
    "snippet": "static void rcu_prepare_kthreads(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/* Fire up the incoming CPU's kthread and leaf rcu_node kthread. */\n\tif (rcu_scheduler_fully_active)\n\t\t(void)rcu_spawn_one_boost_kthread(rnp);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_spawn_one_boost_kthread",
          "args": [
            "rnp"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_one_boost_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1330-1357",
          "snippet": "static int rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n\tint rnp_index = rnp - rcu_get_root();\n\tunsigned long flags;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RCU))\n\t\treturn 0;\n\n\tif (!rcu_scheduler_fully_active || rcu_rnp_online_cpus(rnp) == 0)\n\t\treturn 0;\n\n\trcu_state.boost = 1;\n\tif (rnp->boost_kthread_task != NULL)\n\t\treturn 0;\n\tt = kthread_create(rcu_boost_kthread, (void *)rnp,\n\t\t\t   \"rcub/%d\", rnp_index);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->boost_kthread_task = t;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\twake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n\tint rnp_index = rnp - rcu_get_root();\n\tunsigned long flags;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RCU))\n\t\treturn 0;\n\n\tif (!rcu_scheduler_fully_active || rcu_rnp_online_cpus(rnp) == 0)\n\t\treturn 0;\n\n\trcu_state.boost = 1;\n\tif (rnp->boost_kthread_task != NULL)\n\t\treturn 0;\n\tt = kthread_create(rcu_boost_kthread, (void *)rnp,\n\t\t\t   \"rcub/%d\", rnp_index);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->boost_kthread_task = t;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\twake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_kthreads(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/* Fire up the incoming CPU's kthread and leaf rcu_node kthread. */\n\tif (rcu_scheduler_fully_active)\n\t\t(void)rcu_spawn_one_boost_kthread(rnp);\n}"
  },
  {
    "function_name": "rcu_spawn_boost_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1460-1470",
    "snippet": "static void __init rcu_spawn_boost_kthreads(void)\n{\n\tstruct rcu_node *rnp;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_cpu_has_work, cpu) = 0;\n\tBUG_ON(smpboot_register_percpu_thread(&rcu_cpu_thread_spec));\n\trcu_for_each_leaf_node(rnp)\n\t\t(void)rcu_spawn_one_boost_kthread(rnp);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_spawn_one_boost_kthread",
          "args": [
            "rnp"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_one_boost_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1330-1357",
          "snippet": "static int rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n\tint rnp_index = rnp - rcu_get_root();\n\tunsigned long flags;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RCU))\n\t\treturn 0;\n\n\tif (!rcu_scheduler_fully_active || rcu_rnp_online_cpus(rnp) == 0)\n\t\treturn 0;\n\n\trcu_state.boost = 1;\n\tif (rnp->boost_kthread_task != NULL)\n\t\treturn 0;\n\tt = kthread_create(rcu_boost_kthread, (void *)rnp,\n\t\t\t   \"rcub/%d\", rnp_index);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->boost_kthread_task = t;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\twake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n\tint rnp_index = rnp - rcu_get_root();\n\tunsigned long flags;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RCU))\n\t\treturn 0;\n\n\tif (!rcu_scheduler_fully_active || rcu_rnp_online_cpus(rnp) == 0)\n\t\treturn 0;\n\n\trcu_state.boost = 1;\n\tif (rnp->boost_kthread_task != NULL)\n\t\treturn 0;\n\tt = kthread_create(rcu_boost_kthread, (void *)rnp,\n\t\t\t   \"rcub/%d\", rnp_index);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->boost_kthread_task = t;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\twake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "smpboot_register_percpu_thread(&rcu_cpu_thread_spec)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&rcu_cpu_thread_spec"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smpboot.c",
          "lines": "288-308",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tget_online_cpus();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tput_online_cpus();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tget_online_cpus();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tput_online_cpus();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_spawn_boost_kthreads(void)\n{\n\tstruct rcu_node *rnp;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_cpu_has_work, cpu) = 0;\n\tBUG_ON(smpboot_register_percpu_thread(&rcu_cpu_thread_spec));\n\trcu_for_each_leaf_node(rnp)\n\t\t(void)rcu_spawn_one_boost_kthread(rnp);\n}"
  },
  {
    "function_name": "rcu_boost_kthread_setaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1427-1446",
    "snippet": "static void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n\tstruct task_struct *t = rnp->boost_kthread_task;\n\tunsigned long mask = rcu_rnp_online_cpus(rnp);\n\tcpumask_var_t cm;\n\tint cpu;\n\n\tif (!t)\n\t\treturn;\n\tif (!zalloc_cpumask_var(&cm, GFP_KERNEL))\n\t\treturn;\n\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\tif ((mask & leaf_node_cpu_bit(rnp, cpu)) &&\n\t\t    cpu != outgoingcpu)\n\t\t\tcpumask_set_cpu(cpu, cm);\n\tif (cpumask_weight(cm) == 0)\n\t\tcpumask_setall(cm);\n\tset_cpus_allowed_ptr(t, cm);\n\tfree_cpumask_var(cm);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cm"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "t",
            "cm"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1126-1129",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_setall",
          "args": [
            "cm"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cm"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "cm"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&cm",
            "GFP_KERNEL"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "195-198",
          "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n\tstruct task_struct *t = rnp->boost_kthread_task;\n\tunsigned long mask = rcu_rnp_online_cpus(rnp);\n\tcpumask_var_t cm;\n\tint cpu;\n\n\tif (!t)\n\t\treturn;\n\tif (!zalloc_cpumask_var(&cm, GFP_KERNEL))\n\t\treturn;\n\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\tif ((mask & leaf_node_cpu_bit(rnp, cpu)) &&\n\t\t    cpu != outgoingcpu)\n\t\t\tcpumask_set_cpu(cpu, cm);\n\tif (cpumask_weight(cm) == 0)\n\t\tcpumask_setall(cm);\n\tset_cpus_allowed_ptr(t, cm);\n\tfree_cpumask_var(cm);\n}"
  },
  {
    "function_name": "rcu_cpu_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1387-1416",
    "snippet": "static void rcu_cpu_kthread(unsigned int cpu)\n{\n\tunsigned int *statusp = this_cpu_ptr(&rcu_cpu_kthread_status);\n\tchar work, *workp = this_cpu_ptr(&rcu_cpu_has_work);\n\tint spincnt;\n\n\tfor (spincnt = 0; spincnt < 10; spincnt++) {\n\t\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_wait\"));\n\t\tlocal_bh_disable();\n\t\t*statusp = RCU_KTHREAD_RUNNING;\n\t\tthis_cpu_inc(rcu_cpu_kthread_loops);\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_kthread_do_work();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_wait\"));\n\t\t\t*statusp = RCU_KTHREAD_WAITING;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = RCU_KTHREAD_YIELDING;\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_yield\"));\n\tschedule_timeout_interruptible(2);\n\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_yield\"));\n\t*statusp = RCU_KTHREAD_WAITING;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End CPU kthread@rcu_yield\")"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End CPU kthread@rcu_yield\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "2"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start CPU kthread@rcu_yield\")"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start CPU kthread@rcu_yield\""
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End CPU kthread@rcu_wait\")"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End CPU kthread@rcu_wait\""
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_kthread_do_work",
          "args": [],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_kthread_do_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1359-1362",
          "snippet": "static void rcu_kthread_do_work(void)\n{\n\trcu_do_batch(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_kthread_do_work(void)\n{\n\trcu_do_batch(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "rcu_cpu_kthread_loops"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start CPU kthread@rcu_wait\")"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start CPU kthread@rcu_wait\""
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_cpu_has_work"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_cpu_kthread_status"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cpu_kthread(unsigned int cpu)\n{\n\tunsigned int *statusp = this_cpu_ptr(&rcu_cpu_kthread_status);\n\tchar work, *workp = this_cpu_ptr(&rcu_cpu_has_work);\n\tint spincnt;\n\n\tfor (spincnt = 0; spincnt < 10; spincnt++) {\n\t\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_wait\"));\n\t\tlocal_bh_disable();\n\t\t*statusp = RCU_KTHREAD_RUNNING;\n\t\tthis_cpu_inc(rcu_cpu_kthread_loops);\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_kthread_do_work();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_wait\"));\n\t\t\t*statusp = RCU_KTHREAD_WAITING;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = RCU_KTHREAD_YIELDING;\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_yield\"));\n\tschedule_timeout_interruptible(2);\n\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_yield\"));\n\t*statusp = RCU_KTHREAD_WAITING;\n}"
  },
  {
    "function_name": "rcu_cpu_kthread_should_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1377-1380",
    "snippet": "static int rcu_cpu_kthread_should_run(unsigned int cpu)\n{\n\treturn __this_cpu_read(rcu_cpu_has_work);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_cpu_has_work"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_cpu_kthread_should_run(unsigned int cpu)\n{\n\treturn __this_cpu_read(rcu_cpu_has_work);\n}"
  },
  {
    "function_name": "rcu_cpu_kthread_park",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1372-1375",
    "snippet": "static void rcu_cpu_kthread_park(unsigned int cpu)\n{\n\tper_cpu(rcu_cpu_kthread_status, cpu) = RCU_KTHREAD_OFFCPU;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_cpu_kthread_status",
            "cpu"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cpu_kthread_park(unsigned int cpu)\n{\n\tper_cpu(rcu_cpu_kthread_status, cpu) = RCU_KTHREAD_OFFCPU;\n}"
  },
  {
    "function_name": "rcu_cpu_kthread_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1364-1370",
    "snippet": "static void rcu_cpu_kthread_setup(unsigned int cpu)\n{\n\tstruct sched_param sp;\n\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(current, SCHED_FIFO, &sp);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "current",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4416-4420",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cpu_kthread_setup(unsigned int cpu)\n{\n\tstruct sched_param sp;\n\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(current, SCHED_FIFO, &sp);\n}"
  },
  {
    "function_name": "rcu_kthread_do_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1359-1362",
    "snippet": "static void rcu_kthread_do_work(void)\n{\n\trcu_do_batch(this_cpu_ptr(&rcu_data));\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_do_batch",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_do_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2400-2482",
          "snippet": "static void rcu_do_batch(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tbl = rdp->blimit;\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tlocal_irq_restore(flags);\n\n\t/* Invoke callbacks. */\n\trhp = rcu_cblist_dequeue(&rcl);\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tif (__rcu_reclaim(rcu_state.name, rhp))\n\t\t\trcu_cblist_dequeued_lazy(&rcl);\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t * Note: The rcl structure counts down from zero.\n\t\t */\n\t\tif (-rcl.len >= bl &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t}\n\n\tlocal_irq_save(flags);\n\tcount = -rcl.len;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\tsmp_mb(); /* List handling before counting for rcu_barrier(). */\n\trcu_segcblist_insert_count(&rdp->cblist, &rcl);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit == LONG_MAX && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tWARN_ON_ONCE(rcu_segcblist_empty(&rdp->cblist) != (count == 0));\n\n\tlocal_irq_restore(flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_core(void);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static long qhimark = DEFAULT_RCU_QHIMARK;",
            "static long qlowmark = DEFAULT_RCU_QLOMARK;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tbl = rdp->blimit;\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tlocal_irq_restore(flags);\n\n\t/* Invoke callbacks. */\n\trhp = rcu_cblist_dequeue(&rcl);\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tif (__rcu_reclaim(rcu_state.name, rhp))\n\t\t\trcu_cblist_dequeued_lazy(&rcl);\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t * Note: The rcl structure counts down from zero.\n\t\t */\n\t\tif (-rcl.len >= bl &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t}\n\n\tlocal_irq_save(flags);\n\tcount = -rcl.len;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\tsmp_mb(); /* List handling before counting for rcu_barrier(). */\n\trcu_segcblist_insert_count(&rdp->cblist, &rcl);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit == LONG_MAX && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tWARN_ON_ONCE(rcu_segcblist_empty(&rdp->cblist) != (count == 0));\n\n\tlocal_irq_restore(flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_kthread_do_work(void)\n{\n\trcu_do_batch(this_cpu_ptr(&rcu_data));\n}"
  },
  {
    "function_name": "rcu_spawn_one_boost_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1330-1357",
    "snippet": "static int rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n\tint rnp_index = rnp - rcu_get_root();\n\tunsigned long flags;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RCU))\n\t\treturn 0;\n\n\tif (!rcu_scheduler_fully_active || rcu_rnp_online_cpus(rnp) == 0)\n\t\treturn 0;\n\n\trcu_state.boost = 1;\n\tif (rnp->boost_kthread_task != NULL)\n\t\treturn 0;\n\tt = kthread_create(rcu_boost_kthread, (void *)rnp,\n\t\t\t   \"rcub/%d\", rnp_index);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->boost_kthread_task = t;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\twake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "t"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "t",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4416-4420",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "rcu_boost_kthread",
            "(void *)rnp",
            "\"rcub/%d\"",
            "rnp_index"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "716-727",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "195-198",
          "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RCU"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_spawn_one_boost_kthread(struct rcu_node *rnp)\n{\n\tint rnp_index = rnp - rcu_get_root();\n\tunsigned long flags;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RCU))\n\t\treturn 0;\n\n\tif (!rcu_scheduler_fully_active || rcu_rnp_online_cpus(rnp) == 0)\n\t\treturn 0;\n\n\trcu_state.boost = 1;\n\tif (rnp->boost_kthread_task != NULL)\n\t\treturn 0;\n\tt = kthread_create(rcu_boost_kthread, (void *)rnp,\n\t\t\t   \"rcub/%d\", rnp_index);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->boost_kthread_task = t;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tsp.sched_priority = kthread_prio;\n\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\twake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_preempt_boost_start_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1320-1323",
    "snippet": "static void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n\trnp->boost_time = jiffies + RCU_BOOST_DELAY_JIFFIES;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define RCU_BOOST_DELAY_JIFFIES DIV_ROUND_UP(CONFIG_RCU_BOOST_DELAY * HZ, 1000)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\n#define RCU_BOOST_DELAY_JIFFIES DIV_ROUND_UP(CONFIG_RCU_BOOST_DELAY * HZ, 1000)\n\nstatic void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n\trnp->boost_time = jiffies + RCU_BOOST_DELAY_JIFFIES;\n}"
  },
  {
    "function_name": "rcu_is_callbacks_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1310-1313",
    "snippet": "static bool rcu_is_callbacks_kthread(void)\n{\n\treturn __this_cpu_read(rcu_cpu_kthread_task) == current;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_cpu_kthread_task"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_is_callbacks_kthread(void)\n{\n\treturn __this_cpu_read(rcu_cpu_kthread_task) == current;\n}"
  },
  {
    "function_name": "invoke_rcu_callbacks_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1292-1304",
    "snippet": "static void invoke_rcu_callbacks_kthread(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_cpu_has_work, 1);\n\tif (__this_cpu_read(rcu_cpu_kthread_task) != NULL &&\n\t    current != __this_cpu_read(rcu_cpu_kthread_task)) {\n\t\trcu_wake_cond(__this_cpu_read(rcu_cpu_kthread_task),\n\t\t\t      __this_cpu_read(rcu_cpu_kthread_status));\n\t}\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_wake_cond",
          "args": [
            "__this_cpu_read(rcu_cpu_kthread_task)",
            "__this_cpu_read(rcu_cpu_kthread_status)"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_wake_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1142-1150",
          "snippet": "static void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (status != RCU_KTHREAD_YIELDING || is_idle_task(current))\n\t\twake_up_process(t);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (status != RCU_KTHREAD_YIELDING || is_idle_task(current))\n\t\twake_up_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_cpu_kthread_status"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_cpu_kthread_task"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_cpu_kthread_task"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_cpu_kthread_task"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_cpu_has_work",
            "1"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void invoke_rcu_callbacks_kthread(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_cpu_has_work, 1);\n\tif (__this_cpu_read(rcu_cpu_kthread_task) != NULL &&\n\t    current != __this_cpu_read(rcu_cpu_kthread_task)) {\n\t\trcu_wake_cond(__this_cpu_read(rcu_cpu_kthread_task),\n\t\t\t      __this_cpu_read(rcu_cpu_kthread_status));\n\t}\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_initiate_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1263-1287",
    "snippet": "static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tstruct task_struct *t;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp) && rnp->exp_tasks == NULL) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tif (rnp->exp_tasks != NULL ||\n\t    (rnp->gp_tasks != NULL &&\n\t     rnp->boost_tasks == NULL &&\n\t     rnp->qsmask == 0 &&\n\t     ULONG_CMP_GE(jiffies, rnp->boost_time))) {\n\t\tif (rnp->exp_tasks == NULL)\n\t\t\trnp->boost_tasks = rnp->gp_tasks;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\tt = rnp->boost_kthread_task;\n\t\tif (t)\n\t\t\trcu_wake_cond(t, rnp->boost_kthread_status);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_wake_cond",
          "args": [
            "t",
            "rnp->boost_kthread_status"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_wake_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1142-1150",
          "snippet": "static void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (status != RCU_KTHREAD_YIELDING || is_idle_task(current))\n\t\twake_up_process(t);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (status != RCU_KTHREAD_YIELDING || is_idle_task(current))\n\t\twake_up_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "jiffies",
            "rnp->boost_time"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tstruct task_struct *t;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp) && rnp->exp_tasks == NULL) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tif (rnp->exp_tasks != NULL ||\n\t    (rnp->gp_tasks != NULL &&\n\t     rnp->boost_tasks == NULL &&\n\t     rnp->qsmask == 0 &&\n\t     ULONG_CMP_GE(jiffies, rnp->boost_time))) {\n\t\tif (rnp->exp_tasks == NULL)\n\t\t\trnp->boost_tasks = rnp->gp_tasks;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\tt = rnp->boost_kthread_task;\n\t\tif (t)\n\t\t\trcu_wake_cond(t, rnp->boost_kthread_status);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
  },
  {
    "function_name": "rcu_boost_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1222-1251",
    "snippet": "static int rcu_boost_kthread(void *arg)\n{\n\tstruct rcu_node *rnp = (struct rcu_node *)arg;\n\tint spincnt = 0;\n\tint more2boost;\n\n\ttrace_rcu_utilization(TPS(\"Start boost kthread@init\"));\n\tfor (;;) {\n\t\trnp->boost_kthread_status = RCU_KTHREAD_WAITING;\n\t\ttrace_rcu_utilization(TPS(\"End boost kthread@rcu_wait\"));\n\t\trcu_wait(rnp->boost_tasks || rnp->exp_tasks);\n\t\ttrace_rcu_utilization(TPS(\"Start boost kthread@rcu_wait\"));\n\t\trnp->boost_kthread_status = RCU_KTHREAD_RUNNING;\n\t\tmore2boost = rcu_boost(rnp);\n\t\tif (more2boost)\n\t\t\tspincnt++;\n\t\telse\n\t\t\tspincnt = 0;\n\t\tif (spincnt > 10) {\n\t\t\trnp->boost_kthread_status = RCU_KTHREAD_YIELDING;\n\t\t\ttrace_rcu_utilization(TPS(\"End boost kthread@rcu_yield\"));\n\t\t\tschedule_timeout_interruptible(2);\n\t\t\ttrace_rcu_utilization(TPS(\"Start boost kthread@rcu_yield\"));\n\t\t\tspincnt = 0;\n\t\t}\n\t}\n\t/* NOTREACHED */\n\ttrace_rcu_utilization(TPS(\"End boost kthread@notreached\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End boost kthread@notreached\")"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End boost kthread@notreached\""
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start boost kthread@rcu_yield\")"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start boost kthread@rcu_yield\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "2"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End boost kthread@rcu_yield\")"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End boost kthread@rcu_yield\""
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_boost",
          "args": [
            "rnp"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boost_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1222-1251",
          "snippet": "static int rcu_boost_kthread(void *arg)\n{\n\tstruct rcu_node *rnp = (struct rcu_node *)arg;\n\tint spincnt = 0;\n\tint more2boost;\n\n\ttrace_rcu_utilization(TPS(\"Start boost kthread@init\"));\n\tfor (;;) {\n\t\trnp->boost_kthread_status = RCU_KTHREAD_WAITING;\n\t\ttrace_rcu_utilization(TPS(\"End boost kthread@rcu_wait\"));\n\t\trcu_wait(rnp->boost_tasks || rnp->exp_tasks);\n\t\ttrace_rcu_utilization(TPS(\"Start boost kthread@rcu_wait\"));\n\t\trnp->boost_kthread_status = RCU_KTHREAD_RUNNING;\n\t\tmore2boost = rcu_boost(rnp);\n\t\tif (more2boost)\n\t\t\tspincnt++;\n\t\telse\n\t\t\tspincnt = 0;\n\t\tif (spincnt > 10) {\n\t\t\trnp->boost_kthread_status = RCU_KTHREAD_YIELDING;\n\t\t\ttrace_rcu_utilization(TPS(\"End boost kthread@rcu_yield\"));\n\t\t\tschedule_timeout_interruptible(2);\n\t\t\ttrace_rcu_utilization(TPS(\"Start boost kthread@rcu_yield\"));\n\t\t\tspincnt = 0;\n\t\t}\n\t}\n\t/* NOTREACHED */\n\ttrace_rcu_utilization(TPS(\"End boost kthread@notreached\"));\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start boost kthread@rcu_wait\")"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start boost kthread@rcu_wait\""
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_wait",
          "args": [
            "rnp->boost_tasks || rnp->exp_tasks"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End boost kthread@rcu_wait\")"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End boost kthread@rcu_wait\""
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start boost kthread@init\")"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start boost kthread@init\""
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_boost_kthread(void *arg)\n{\n\tstruct rcu_node *rnp = (struct rcu_node *)arg;\n\tint spincnt = 0;\n\tint more2boost;\n\n\ttrace_rcu_utilization(TPS(\"Start boost kthread@init\"));\n\tfor (;;) {\n\t\trnp->boost_kthread_status = RCU_KTHREAD_WAITING;\n\t\ttrace_rcu_utilization(TPS(\"End boost kthread@rcu_wait\"));\n\t\trcu_wait(rnp->boost_tasks || rnp->exp_tasks);\n\t\ttrace_rcu_utilization(TPS(\"Start boost kthread@rcu_wait\"));\n\t\trnp->boost_kthread_status = RCU_KTHREAD_RUNNING;\n\t\tmore2boost = rcu_boost(rnp);\n\t\tif (more2boost)\n\t\t\tspincnt++;\n\t\telse\n\t\t\tspincnt = 0;\n\t\tif (spincnt > 10) {\n\t\t\trnp->boost_kthread_status = RCU_KTHREAD_YIELDING;\n\t\t\ttrace_rcu_utilization(TPS(\"End boost kthread@rcu_yield\"));\n\t\t\tschedule_timeout_interruptible(2);\n\t\t\ttrace_rcu_utilization(TPS(\"Start boost kthread@rcu_yield\"));\n\t\t\tspincnt = 0;\n\t\t}\n\t}\n\t/* NOTREACHED */\n\ttrace_rcu_utilization(TPS(\"End boost kthread@notreached\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1160-1217",
    "snippet": "static int rcu_boost(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\tstruct list_head *tb;\n\n\tif (READ_ONCE(rnp->exp_tasks) == NULL &&\n\t    READ_ONCE(rnp->boost_tasks) == NULL)\n\t\treturn 0;  /* Nothing left to boost. */\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/*\n\t * Recheck under the lock: all tasks in need of boosting\n\t * might exit their RCU read-side critical sections on their own.\n\t */\n\tif (rnp->exp_tasks == NULL && rnp->boost_tasks == NULL) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Preferentially boost tasks blocking expedited grace periods.\n\t * This cannot starve the normal grace periods because a second\n\t * expedited grace period must boost all blocked tasks, including\n\t * those blocking the pre-existing normal grace period.\n\t */\n\tif (rnp->exp_tasks != NULL)\n\t\ttb = rnp->exp_tasks;\n\telse\n\t\ttb = rnp->boost_tasks;\n\n\t/*\n\t * We boost task t by manufacturing an rt_mutex that appears to\n\t * be held by task t.  We leave a pointer to that rt_mutex where\n\t * task t can find it, and task t will release the mutex when it\n\t * exits its outermost RCU read-side critical section.  Then\n\t * simply acquiring this artificial rt_mutex will boost task\n\t * t's priority.  (Thanks to tglx for suggesting this approach!)\n\t *\n\t * Note that task t must acquire rnp->lock to remove itself from\n\t * the ->blkd_tasks list, which it will do from exit() if from\n\t * nowhere else.  We therefore are guaranteed that task t will\n\t * stay around at least until we drop rnp->lock.  Note that\n\t * rnp->lock also resolves races between our priority boosting\n\t * and task t's exiting its outermost RCU read-side critical\n\t * section.\n\t */\n\tt = container_of(tb, struct task_struct, rcu_node_entry);\n\trt_mutex_init_proxy_locked(&rnp->boost_mtx, t);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t/* Lock only for side effect: boosts task t's priority. */\n\trt_mutex_lock(&rnp->boost_mtx);\n\trt_mutex_unlock(&rnp->boost_mtx);  /* Then keep lockdep happy. */\n\n\treturn READ_ONCE(rnp->exp_tasks) != NULL ||\n\t       READ_ONCE(rnp->boost_tasks) != NULL;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->boost_tasks"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_unlock",
          "args": [
            "&rnp->boost_mtx"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_lock",
          "args": [
            "&rnp->boost_mtx"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_init_proxy_locked",
          "args": [
            "&rnp->boost_mtx",
            "t"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_proxy_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1702-1708",
          "snippet": "void rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, NULL, NULL);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, NULL, NULL);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tb",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->boost_tasks"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_boost(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\tstruct list_head *tb;\n\n\tif (READ_ONCE(rnp->exp_tasks) == NULL &&\n\t    READ_ONCE(rnp->boost_tasks) == NULL)\n\t\treturn 0;  /* Nothing left to boost. */\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/*\n\t * Recheck under the lock: all tasks in need of boosting\n\t * might exit their RCU read-side critical sections on their own.\n\t */\n\tif (rnp->exp_tasks == NULL && rnp->boost_tasks == NULL) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Preferentially boost tasks blocking expedited grace periods.\n\t * This cannot starve the normal grace periods because a second\n\t * expedited grace period must boost all blocked tasks, including\n\t * those blocking the pre-existing normal grace period.\n\t */\n\tif (rnp->exp_tasks != NULL)\n\t\ttb = rnp->exp_tasks;\n\telse\n\t\ttb = rnp->boost_tasks;\n\n\t/*\n\t * We boost task t by manufacturing an rt_mutex that appears to\n\t * be held by task t.  We leave a pointer to that rt_mutex where\n\t * task t can find it, and task t will release the mutex when it\n\t * exits its outermost RCU read-side critical section.  Then\n\t * simply acquiring this artificial rt_mutex will boost task\n\t * t's priority.  (Thanks to tglx for suggesting this approach!)\n\t *\n\t * Note that task t must acquire rnp->lock to remove itself from\n\t * the ->blkd_tasks list, which it will do from exit() if from\n\t * nowhere else.  We therefore are guaranteed that task t will\n\t * stay around at least until we drop rnp->lock.  Note that\n\t * rnp->lock also resolves races between our priority boosting\n\t * and task t's exiting its outermost RCU read-side critical\n\t * section.\n\t */\n\tt = container_of(tb, struct task_struct, rcu_node_entry);\n\trt_mutex_init_proxy_locked(&rnp->boost_mtx, t);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t/* Lock only for side effect: boosts task t's priority. */\n\trt_mutex_lock(&rnp->boost_mtx);\n\trt_mutex_unlock(&rnp->boost_mtx);  /* Then keep lockdep happy. */\n\n\treturn READ_ONCE(rnp->exp_tasks) != NULL ||\n\t       READ_ONCE(rnp->boost_tasks) != NULL;\n}"
  },
  {
    "function_name": "rcu_wake_cond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1142-1150",
    "snippet": "static void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (status != RCU_KTHREAD_YIELDING || is_idle_task(current))\n\t\twake_up_process(t);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "t"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (status != RCU_KTHREAD_YIELDING || is_idle_task(current))\n\t\twake_up_process(t);\n}"
  },
  {
    "function_name": "dump_blkd_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1132-1136",
    "snippet": "static void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&rnp->blkd_tasks)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rnp->blkd_tasks"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}"
  },
  {
    "function_name": "exit_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1125-1127",
    "snippet": "void exit_rcu(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid exit_rcu(void)\n{\n}"
  },
  {
    "function_name": "synchronize_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1106-1118",
    "snippet": "void synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_rcu_gp",
          "args": [
            "call_rcu"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_expedited",
          "args": [],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "822-834",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* If only one CPU, this is automatically a grace period. */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t_synchronize_rcu_expedited(sync_sched_exp_handler);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nvoid synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* If only one CPU, this is automatically a grace period. */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t_synchronize_rcu_expedited(sync_sched_exp_handler);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "149-153",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_blocking_is_gp",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_blocking_is_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "810-819",
          "snippet": "static int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\tret = num_online_cpus() <= 1;\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\tret = num_online_cpus() <= 1;\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_rcu() in RCU read-side critical section\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}"
  },
  {
    "function_name": "rcu_flavor_check_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1085-1103",
    "snippet": "static void rcu_flavor_check_callbacks(int user)\n{\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\n\t\t/*\n\t\t * Get here if this CPU took its interrupt from user\n\t\t * mode or from the idle loop, and if this is not a\n\t\t * nested interrupt.  In this case, the CPU is in\n\t\t * a quiescent state, so note it.\n\t\t *\n\t\t * No memory barrier is required here because rcu_qs()\n\t\t * references only CPU-local variables that other CPUs\n\t\t * neither access nor modify, at least not while the\n\t\t * corresponding CPU is online.\n\t\t */\n\n\t\trcu_qs();\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "377-381",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_flavor_check_callbacks(int user)\n{\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\n\t\t/*\n\t\t * Get here if this CPU took its interrupt from user\n\t\t * mode or from the idle loop, and if this is not a\n\t\t * nested interrupt.  In this case, the CPU is in\n\t\t * a quiescent state, so note it.\n\t\t *\n\t\t * No memory barrier is required here because rcu_qs()\n\t\t * references only CPU-local variables that other CPUs\n\t\t * neither access nor modify, at least not while the\n\t\t * corresponding CPU is online.\n\t\t */\n\n\t\trcu_qs();\n\t}\n}"
  },
  {
    "function_name": "rcu_preempt_check_blocked_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1072-1075",
    "snippet": "static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tWARN_ON_ONCE(rnp->qsmask);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tWARN_ON_ONCE(rnp->qsmask);\n}"
  },
  {
    "function_name": "rcu_print_task_exp_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1062-1065",
    "snippet": "static int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_print_task_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1052-1055",
    "snippet": "static int rcu_print_task_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_print_task_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_print_detail_task_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1044-1046",
    "snippet": "static void rcu_print_detail_task_stall(void)\n{\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_detail_task_stall(void)\n{\n}"
  },
  {
    "function_name": "rcu_preempt_deferred_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1038-1038",
    "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
  },
  {
    "function_name": "rcu_preempt_need_deferred_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1034-1037",
    "snippet": "static bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_preempt_has_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1025-1028",
    "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_preempt_blocked_readers_cgp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "1017-1020",
    "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_note_context_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "994-1010",
    "snippet": "void rcu_note_context_switch(bool preempt)\n{\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\ttrace_rcu_utilization(TPS(\"Start context switch\"));\n\trcu_qs();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs)))\n\t\tgoto out;\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs)))\n\t\trcu_momentary_dyntick_idle();\n\tif (!preempt)\n\t\trcu_tasks_qs(current);\nout:\n\ttrace_rcu_utilization(TPS(\"End context switch\"));\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End context switch\")"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End context switch\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_tasks_qs",
          "args": [
            "current"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_momentary_dyntick_idle",
          "args": [],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "raw_cpu_read(rcu_data.rcu_need_heavy_qs)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_read",
          "args": [
            "rcu_data.rcu_need_heavy_qs"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "rcu_data.rcu_urgent_qs",
            "false"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "this_cpu_ptr(&rcu_data.rcu_urgent_qs)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start context switch\")"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start context switch\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid rcu_note_context_switch(bool preempt)\n{\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\ttrace_rcu_utilization(TPS(\"Start context switch\"));\n\trcu_qs();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs)))\n\t\tgoto out;\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs)))\n\t\trcu_momentary_dyntick_idle();\n\tif (!preempt)\n\t\trcu_tasks_qs(current);\nout:\n\ttrace_rcu_utilization(TPS(\"End context switch\"));\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n}"
  },
  {
    "function_name": "rcu_all_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "966-988",
    "snippet": "void rcu_all_qs(void)\n{\n\tunsigned long flags;\n\n\tif (!raw_cpu_read(rcu_data.rcu_urgent_qs))\n\t\treturn;\n\tpreempt_disable();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\tpreempt_enable();\n\t\treturn;\n\t}\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs))) {\n\t\tlocal_irq_save(flags);\n\t\trcu_momentary_dyntick_idle();\n\t\tlocal_irq_restore(flags);\n\t}\n\trcu_qs();\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_momentary_dyntick_idle",
          "args": [],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "raw_cpu_read(rcu_data.rcu_need_heavy_qs)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_read",
          "args": [
            "rcu_data.rcu_need_heavy_qs"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "rcu_data.rcu_urgent_qs",
            "false"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "this_cpu_ptr(&rcu_data.rcu_urgent_qs)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_read",
          "args": [
            "rcu_data.rcu_urgent_qs"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid rcu_all_qs(void)\n{\n\tunsigned long flags;\n\n\tif (!raw_cpu_read(rcu_data.rcu_urgent_qs))\n\t\treturn;\n\tpreempt_disable();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\tpreempt_enable();\n\t\treturn;\n\t}\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs))) {\n\t\tlocal_irq_save(flags);\n\t\trcu_momentary_dyntick_idle();\n\t\tlocal_irq_restore(flags);\n\t}\n\trcu_qs();\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "rcu_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "940-952",
    "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.cpu_no_qs.b.exp",
            "false"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.cpu_no_qs.b.exp"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.cpu_no_qs.b.norm",
            "false"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "TPS(\"rcu_sched\")",
            "__this_cpu_read(rcu_data.gp_seq)",
            "TPS(\"cpuqs\")"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuqs\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.gp_seq"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"rcu_sched\""
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.cpu_no_qs.s"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "preemptible()",
            "\"rcu_qs() invoked with preemption enabled!!!\""
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
  },
  {
    "function_name": "rcu_bootup_announce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "928-932",
    "snippet": "static void __init rcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical RCU implementation.\\n\");\n\trcu_bootup_announce_oddness();\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_bootup_announce_oddness",
          "args": [],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_bootup_announce_oddness",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "70-123",
          "snippet": "static void __init rcu_bootup_announce_oddness(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TRACE))\n\t\tpr_info(\"\\tRCU event tracing is enabled.\\n\");\n\tif ((IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 64) ||\n\t    (!IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 32))\n\t\tpr_info(\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\",\n\t\t\tRCU_FANOUT);\n\tif (rcu_fanout_exact)\n\t\tpr_info(\"\\tHierarchical RCU autobalancing is disabled.\\n\");\n\tif (IS_ENABLED(CONFIG_RCU_FAST_NO_HZ))\n\t\tpr_info(\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\");\n\tif (IS_ENABLED(CONFIG_PROVE_RCU))\n\t\tpr_info(\"\\tRCU lockdep checking is enabled.\\n\");\n\tif (RCU_NUM_LVLS >= 4)\n\t\tpr_info(\"\\tFour(or more)-level hierarchy is enabled.\\n\");\n\tif (RCU_FANOUT_LEAF != 16)\n\t\tpr_info(\"\\tBuild-time adjustment of leaf fanout to %d.\\n\",\n\t\t\tRCU_FANOUT_LEAF);\n\tif (rcu_fanout_leaf != RCU_FANOUT_LEAF)\n\t\tpr_info(\"\\tBoot-time adjustment of leaf fanout to %d.\\n\",\n\t\t\trcu_fanout_leaf);\n\tif (nr_cpu_ids != NR_CPUS)\n\t\tpr_info(\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\", NR_CPUS, nr_cpu_ids);\n#ifdef CONFIG_RCU_BOOST\n\tpr_info(\"\\tRCU priority boosting: priority %d delay %d ms.\\n\",\n\t\tkthread_prio, CONFIG_RCU_BOOST_DELAY);\n#endif\n\tif (blimit != DEFAULT_RCU_BLIMIT)\n\t\tpr_info(\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\", blimit);\n\tif (qhimark != DEFAULT_RCU_QHIMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\", qhimark);\n\tif (qlowmark != DEFAULT_RCU_QLOMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\", qlowmark);\n\tif (jiffies_till_first_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\", jiffies_till_first_fqs);\n\tif (jiffies_till_next_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\", jiffies_till_next_fqs);\n\tif (jiffies_till_sched_qs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\", jiffies_till_sched_qs);\n\tif (rcu_kick_kthreads)\n\t\tpr_info(\"\\tKick kthreads if too-long grace period.\\n\");\n\tif (IS_ENABLED(CONFIG_DEBUG_OBJECTS_RCU_HEAD))\n\t\tpr_info(\"\\tRCU callback double-/use-after-free debug enabled.\\n\");\n\tif (gp_preinit_delay)\n\t\tpr_info(\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\", gp_preinit_delay);\n\tif (gp_init_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_init_delay);\n\tif (gp_cleanup_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_cleanup_delay);\n\tif (IS_ENABLED(CONFIG_RCU_EQS_DEBUG))\n\t\tpr_info(\"\\tRCU debug extended QS entry/exit.\\n\");\n\trcupdate_announce_bootup_oddness();\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_bootup_announce_oddness(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TRACE))\n\t\tpr_info(\"\\tRCU event tracing is enabled.\\n\");\n\tif ((IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 64) ||\n\t    (!IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 32))\n\t\tpr_info(\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\",\n\t\t\tRCU_FANOUT);\n\tif (rcu_fanout_exact)\n\t\tpr_info(\"\\tHierarchical RCU autobalancing is disabled.\\n\");\n\tif (IS_ENABLED(CONFIG_RCU_FAST_NO_HZ))\n\t\tpr_info(\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\");\n\tif (IS_ENABLED(CONFIG_PROVE_RCU))\n\t\tpr_info(\"\\tRCU lockdep checking is enabled.\\n\");\n\tif (RCU_NUM_LVLS >= 4)\n\t\tpr_info(\"\\tFour(or more)-level hierarchy is enabled.\\n\");\n\tif (RCU_FANOUT_LEAF != 16)\n\t\tpr_info(\"\\tBuild-time adjustment of leaf fanout to %d.\\n\",\n\t\t\tRCU_FANOUT_LEAF);\n\tif (rcu_fanout_leaf != RCU_FANOUT_LEAF)\n\t\tpr_info(\"\\tBoot-time adjustment of leaf fanout to %d.\\n\",\n\t\t\trcu_fanout_leaf);\n\tif (nr_cpu_ids != NR_CPUS)\n\t\tpr_info(\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\", NR_CPUS, nr_cpu_ids);\n#ifdef CONFIG_RCU_BOOST\n\tpr_info(\"\\tRCU priority boosting: priority %d delay %d ms.\\n\",\n\t\tkthread_prio, CONFIG_RCU_BOOST_DELAY);\n#endif\n\tif (blimit != DEFAULT_RCU_BLIMIT)\n\t\tpr_info(\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\", blimit);\n\tif (qhimark != DEFAULT_RCU_QHIMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\", qhimark);\n\tif (qlowmark != DEFAULT_RCU_QLOMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\", qlowmark);\n\tif (jiffies_till_first_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\", jiffies_till_first_fqs);\n\tif (jiffies_till_next_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\", jiffies_till_next_fqs);\n\tif (jiffies_till_sched_qs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\", jiffies_till_sched_qs);\n\tif (rcu_kick_kthreads)\n\t\tpr_info(\"\\tKick kthreads if too-long grace period.\\n\");\n\tif (IS_ENABLED(CONFIG_DEBUG_OBJECTS_RCU_HEAD))\n\t\tpr_info(\"\\tRCU callback double-/use-after-free debug enabled.\\n\");\n\tif (gp_preinit_delay)\n\t\tpr_info(\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\", gp_preinit_delay);\n\tif (gp_init_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_init_delay);\n\tif (gp_cleanup_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_cleanup_delay);\n\tif (IS_ENABLED(CONFIG_RCU_EQS_DEBUG))\n\t\tpr_info(\"\\tRCU debug extended QS entry/exit.\\n\");\n\trcupdate_announce_bootup_oddness();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Hierarchical RCU implementation.\\n\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical RCU implementation.\\n\");\n\trcu_bootup_announce_oddness();\n}"
  },
  {
    "function_name": "dump_blkd_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "886-921",
    "snippet": "static void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tint cpu;\n\tint i;\n\tstruct list_head *lhp;\n\tbool onl;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp1;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx\\n\",\n\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext);\n\tpr_info(\"%s: ->gp_tasks %p ->boost_tasks %p ->exp_tasks %p\\n\",\n\t\t__func__, rnp->gp_tasks, rnp->boost_tasks, rnp->exp_tasks);\n\tpr_info(\"%s: ->blkd_tasks\", __func__);\n\ti = 0;\n\tlist_for_each(lhp, &rnp->blkd_tasks) {\n\t\tpr_cont(\" %p\", lhp);\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\tfor (cpu = rnp->grplo; cpu <= rnp->grphi; cpu++) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"\\t%d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\tcpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\t%d: %c online: %ld(%d) offline: %ld(%d)\\n\"",
            "cpu",
            "\".o\"[onl]",
            "(long)rdp->rcu_onl_gp_seq",
            "rdp->rcu_onl_gp_flags",
            "(long)rdp->rcu_ofl_gp_seq",
            "rdp->rcu_ofl_gp_flags"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "195-198",
          "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %p\"",
            "lhp"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "lhp",
            "&rnp->blkd_tasks"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: ->blkd_tasks\"",
            "__func__"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: ->gp_tasks %p ->boost_tasks %p ->exp_tasks %p\\n\"",
            "__func__",
            "rnp->gp_tasks",
            "rnp->boost_tasks",
            "rnp->exp_tasks"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx\\n\"",
            "__func__",
            "rnp1->grplo",
            "rnp1->grphi",
            "rnp1->qsmask",
            "rnp1->qsmaskinit",
            "rnp1->qsmaskinitnext"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\"",
            "__func__",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->level",
            "(long)rnp->gp_seq",
            "(long)rnp->completedqs"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tint cpu;\n\tint i;\n\tstruct list_head *lhp;\n\tbool onl;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp1;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx\\n\",\n\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext);\n\tpr_info(\"%s: ->gp_tasks %p ->boost_tasks %p ->exp_tasks %p\\n\",\n\t\t__func__, rnp->gp_tasks, rnp->boost_tasks, rnp->exp_tasks);\n\tpr_info(\"%s: ->blkd_tasks\", __func__);\n\ti = 0;\n\tlist_for_each(lhp, &rnp->blkd_tasks) {\n\t\tpr_cont(\" %p\", lhp);\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\tfor (cpu = rnp->grplo; cpu <= rnp->grphi; cpu++) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"\\t%d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\tcpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t}\n}"
  },
  {
    "function_name": "exit_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "869-880",
    "snippet": "void exit_rcu(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (likely(list_empty(&current->rcu_node_entry)))\n\t\treturn;\n\tt->rcu_read_lock_nesting = 1;\n\tbarrier();\n\tt->rcu_read_unlock_special.b.blocked = true;\n\t__rcu_read_unlock();\n\trcu_preempt_deferred_qs(current);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "__rcu_read_unlock",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "list_empty(&current->rcu_node_entry)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&current->rcu_node_entry"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid exit_rcu(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (likely(list_empty(&current->rcu_node_entry)))\n\t\treturn;\n\tt->rcu_read_lock_nesting = 1;\n\tbarrier();\n\tt->rcu_read_unlock_special.b.blocked = true;\n\t__rcu_read_unlock();\n\trcu_preempt_deferred_qs(current);\n}"
  },
  {
    "function_name": "synchronize_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "848-860",
    "snippet": "void synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_rcu_gp",
          "args": [
            "call_rcu"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_expedited",
          "args": [],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "822-834",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* If only one CPU, this is automatically a grace period. */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t_synchronize_rcu_expedited(sync_sched_exp_handler);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nvoid synchronize_rcu_expedited(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* If only one CPU, this is automatically a grace period. */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t_synchronize_rcu_expedited(sync_sched_exp_handler);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "149-153",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_rcu() in RCU read-side critical section\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}"
  },
  {
    "function_name": "rcu_flavor_check_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "784-813",
    "snippet": "static void rcu_flavor_check_callbacks(int user)\n{\n\tstruct task_struct *t = current;\n\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\t\trcu_note_voluntary_context_switch(current);\n\t}\n\tif (t->rcu_read_lock_nesting > 0 ||\n\t    (preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK))) {\n\t\t/* No QS, force context switch if deferred. */\n\t\tif (rcu_preempt_need_deferred_qs(t)) {\n\t\t\tset_tsk_need_resched(t);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t} else if (rcu_preempt_need_deferred_qs(t)) {\n\t\trcu_preempt_deferred_qs(t); /* Report deferred QS. */\n\t\treturn;\n\t} else if (!t->rcu_read_lock_nesting) {\n\t\trcu_qs(); /* Report immediate QS. */\n\t\treturn;\n\t}\n\n\t/* If GP is oldish, ask for help from rcu_read_unlock_special(). */\n\tif (t->rcu_read_lock_nesting > 0 &&\n\t    __this_cpu_read(rcu_data.core_needs_qs) &&\n\t    __this_cpu_read(rcu_data.cpu_no_qs.b.norm) &&\n\t    !t->rcu_read_unlock_special.b.need_qs &&\n\t    time_after(jiffies, rcu_state.gp_start + HZ))\n\t\tt->rcu_read_unlock_special.b.need_qs = true;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.gp_start + HZ"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.cpu_no_qs.b.norm"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.core_needs_qs"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "t"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_need_deferred_qs",
          "args": [
            "t"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_need_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1034-1037",
          "snippet": "static bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "t"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_note_voluntary_context_switch",
          "args": [
            "current"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "377-381",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_flavor_check_callbacks(int user)\n{\n\tstruct task_struct *t = current;\n\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\t\trcu_note_voluntary_context_switch(current);\n\t}\n\tif (t->rcu_read_lock_nesting > 0 ||\n\t    (preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK))) {\n\t\t/* No QS, force context switch if deferred. */\n\t\tif (rcu_preempt_need_deferred_qs(t)) {\n\t\t\tset_tsk_need_resched(t);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t} else if (rcu_preempt_need_deferred_qs(t)) {\n\t\trcu_preempt_deferred_qs(t); /* Report deferred QS. */\n\t\treturn;\n\t} else if (!t->rcu_read_lock_nesting) {\n\t\trcu_qs(); /* Report immediate QS. */\n\t\treturn;\n\t}\n\n\t/* If GP is oldish, ask for help from rcu_read_unlock_special(). */\n\tif (t->rcu_read_lock_nesting > 0 &&\n\t    __this_cpu_read(rcu_data.core_needs_qs) &&\n\t    __this_cpu_read(rcu_data.cpu_no_qs.b.norm) &&\n\t    !t->rcu_read_unlock_special.b.need_qs &&\n\t    time_after(jiffies, rcu_state.gp_start + HZ))\n\t\tt->rcu_read_unlock_special.b.need_qs = true;\n}"
  },
  {
    "function_name": "rcu_preempt_check_blocked_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "759-775",
    "snippet": "static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tstruct task_struct *t;\n\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_preempt_check_blocked_tasks() invoked with preemption enabled!!!\\n\");\n\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\tdump_blkd_tasks(rnp, 10);\n\tif (rcu_preempt_has_tasks(rnp) &&\n\t    (rnp->qsmaskinit || rnp->wait_blkd_tasks)) {\n\t\trnp->gp_tasks = rnp->blkd_tasks.next;\n\t\tt = container_of(rnp->gp_tasks, struct task_struct,\n\t\t\t\t rcu_node_entry);\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt-GPS\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t}\n\tWARN_ON_ONCE(rnp->qsmask);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_unlock_preempted_task",
          "args": [
            "TPS(\"rcu_preempt-GPS\")",
            "rnp->gp_seq",
            "t->pid"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"rcu_preempt-GPS\""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rnp->gp_tasks",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1025-1028",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_blkd_tasks",
          "args": [
            "rnp",
            "10"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "dump_blkd_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1132-1136",
          "snippet": "static void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "preemptible()",
            "\"rcu_preempt_check_blocked_tasks() invoked with preemption enabled!!!\\n\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tstruct task_struct *t;\n\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_preempt_check_blocked_tasks() invoked with preemption enabled!!!\\n\");\n\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\tdump_blkd_tasks(rnp, 10);\n\tif (rcu_preempt_has_tasks(rnp) &&\n\t    (rnp->qsmaskinit || rnp->wait_blkd_tasks)) {\n\t\trnp->gp_tasks = rnp->blkd_tasks.next;\n\t\tt = container_of(rnp->gp_tasks, struct task_struct,\n\t\t\t\t rcu_node_entry);\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt-GPS\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t}\n\tWARN_ON_ONCE(rnp->qsmask);\n}"
  },
  {
    "function_name": "rcu_print_task_exp_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "733-747",
    "snippet": "static int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\tstruct task_struct *t;\n\tint ndetected = 0;\n\n\tif (!rnp->exp_tasks)\n\t\treturn 0;\n\tt = list_entry(rnp->exp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tpr_cont(\" P%d\", t->pid);\n\t\tndetected++;\n\t}\n\treturn ndetected;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" P%d\"",
            "t->pid"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "t",
            "&rnp->blkd_tasks",
            "rcu_node_entry"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rnp->exp_tasks->prev",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\tstruct task_struct *t;\n\tint ndetected = 0;\n\n\tif (!rnp->exp_tasks)\n\t\treturn 0;\n\tt = list_entry(rnp->exp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tpr_cont(\" P%d\", t->pid);\n\t\tndetected++;\n\t}\n\treturn ndetected;\n}"
  },
  {
    "function_name": "rcu_print_task_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "710-726",
    "snippet": "static int rcu_print_task_stall(struct rcu_node *rnp)\n{\n\tstruct task_struct *t;\n\tint ndetected = 0;\n\n\tif (!rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn 0;\n\trcu_print_task_stall_begin(rnp);\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tpr_cont(\" P%d\", t->pid);\n\t\tndetected++;\n\t}\n\trcu_print_task_stall_end();\n\treturn ndetected;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_print_task_stall_end",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_task_stall_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "701-704",
          "snippet": "static void rcu_print_task_stall_end(void)\n{\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_task_stall_end(void)\n{\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" P%d\"",
            "t->pid"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "t",
            "&rnp->blkd_tasks",
            "rcu_node_entry"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rnp->gp_tasks->prev",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_print_task_stall_begin",
          "args": [
            "rnp"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_task_stall_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "695-699",
          "snippet": "static void rcu_print_task_stall_begin(struct rcu_node *rnp)\n{\n\tpr_err(\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\",\n\t       rnp->level, rnp->grplo, rnp->grphi);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_task_stall_begin(struct rcu_node *rnp)\n{\n\tpr_err(\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\",\n\t       rnp->level, rnp->grplo, rnp->grphi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_print_task_stall(struct rcu_node *rnp)\n{\n\tstruct task_struct *t;\n\tint ndetected = 0;\n\n\tif (!rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn 0;\n\trcu_print_task_stall_begin(rnp);\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tpr_cont(\" P%d\", t->pid);\n\t\tndetected++;\n\t}\n\trcu_print_task_stall_end();\n\treturn ndetected;\n}"
  },
  {
    "function_name": "rcu_print_task_stall_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "701-704",
    "snippet": "static void rcu_print_task_stall_end(void)\n{\n\tpr_cont(\"\\n\");\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_task_stall_end(void)\n{\n\tpr_cont(\"\\n\");\n}"
  },
  {
    "function_name": "rcu_print_task_stall_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "695-699",
    "snippet": "static void rcu_print_task_stall_begin(struct rcu_node *rnp)\n{\n\tpr_err(\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\",\n\t       rnp->level, rnp->grplo, rnp->grphi);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\"",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_task_stall_begin(struct rcu_node *rnp)\n{\n\tpr_err(\"\\tTasks blocked on level-%d rcu_node (CPUs %d-%d):\",\n\t       rnp->level, rnp->grplo, rnp->grphi);\n}"
  },
  {
    "function_name": "rcu_print_detail_task_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "686-693",
    "snippet": "static void rcu_print_detail_task_stall(void)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\trcu_print_detail_task_stall_rnp(rnp);\n\trcu_for_each_leaf_node(rnp)\n\t\trcu_print_detail_task_stall_rnp(rnp);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_print_detail_task_stall_rnp",
          "args": [
            "rnp"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_detail_task_stall_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "659-680",
          "snippet": "static void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\t/*\n\t\t * We could be printing a lot while holding a spinlock.\n\t\t * Avoid triggering hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tsched_show_task(t);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\t/*\n\t\t * We could be printing a lot while holding a spinlock.\n\t\t * Avoid triggering hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tsched_show_task(t);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_detail_task_stall(void)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\trcu_print_detail_task_stall_rnp(rnp);\n\trcu_for_each_leaf_node(rnp)\n\t\trcu_print_detail_task_stall_rnp(rnp);\n}"
  },
  {
    "function_name": "rcu_print_detail_task_stall_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "659-680",
    "snippet": "static void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\t/*\n\t\t * We could be printing a lot while holding a spinlock.\n\t\t * Avoid triggering hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tsched_show_task(t);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "t"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "t",
            "&rnp->blkd_tasks",
            "rcu_node_entry"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rnp->gp_tasks->prev",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tstruct task_struct *t;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tt = list_entry(rnp->gp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\t/*\n\t\t * We could be printing a lot while holding a spinlock.\n\t\t * Avoid triggering hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tsched_show_task(t);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
  },
  {
    "function_name": "rcu_read_unlock_special",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "632-653",
    "snippet": "static void rcu_read_unlock_special(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool preempt_bh_were_disabled =\n\t\t\t!!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK));\n\tbool irqs_were_disabled;\n\n\t/* NMI handlers cannot block and cannot safely manipulate state. */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tirqs_were_disabled = irqs_disabled_flags(flags);\n\tif ((preempt_bh_were_disabled || irqs_were_disabled) &&\n\t    t->rcu_read_unlock_special.b.blocked) {\n\t\t/* Need to defer quiescent state until everything is enabled. */\n\t\traise_softirq_irqoff(RCU_SOFTIRQ);\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs_irqrestore",
          "args": [
            "t",
            "flags"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "473-587",
          "snippet": "static void\nrcu_preempt_deferred_qs_irqrestore(struct task_struct *t, unsigned long flags)\n{\n\tbool empty_exp;\n\tbool empty_norm;\n\tbool empty_exp_now;\n\tstruct list_head *np;\n\tbool drop_boost_mutex = false;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunion rcu_special special;\n\n\t/*\n\t * If RCU core is waiting for this CPU to exit its critical section,\n\t * report the fact that it has exited.  Because irqs are disabled,\n\t * t->rcu_read_unlock_special cannot change.\n\t */\n\tspecial = t->rcu_read_unlock_special;\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!special.s && !rdp->deferred_qs) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tif (special.b.need_qs) {\n\t\trcu_qs();\n\t\tt->rcu_read_unlock_special.b.need_qs = false;\n\t\tif (!t->rcu_read_unlock_special.s && !rdp->deferred_qs) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Respond to a request by an expedited grace period for a\n\t * quiescent state from this CPU.  Note that requests from\n\t * tasks are handled when removing the task from the\n\t * blocked-tasks list below.\n\t */\n\tif (rdp->deferred_qs) {\n\t\trcu_report_exp_rdp(rdp);\n\t\tif (!t->rcu_read_unlock_special.s) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Clean up if blocked during RCU read-side critical section. */\n\tif (special.b.blocked) {\n\t\tt->rcu_read_unlock_special.b.blocked = false;\n\n\t\t/*\n\t\t * Remove this task from the list it blocked on.  The task\n\t\t * now remains queued on the rcu_node corresponding to the\n\t\t * CPU it first blocked on, so there is no longer any need\n\t\t * to loop.  Retain a WARN_ON_ONCE() out of sheer paranoia.\n\t\t */\n\t\trnp = t->rcu_blocked_node;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tWARN_ON_ONCE(rnp != t->rcu_blocked_node);\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t\tempty_norm = !rcu_preempt_blocked_readers_cgp(rnp);\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask));\n\t\tempty_exp = sync_rcu_preempt_exp_done(rnp);\n\t\tsmp_mb(); /* ensure expedited fastpath sees end of RCU c-s. */\n\t\tnp = rcu_next_node_entry(t, rnp);\n\t\tlist_del_init(&t->rcu_node_entry);\n\t\tt->rcu_blocked_node = NULL;\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t\tif (&t->rcu_node_entry == rnp->gp_tasks)\n\t\t\trnp->gp_tasks = np;\n\t\tif (&t->rcu_node_entry == rnp->exp_tasks)\n\t\t\trnp->exp_tasks = np;\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST)) {\n\t\t\t/* Snapshot ->boost_mtx ownership w/rnp->lock held. */\n\t\t\tdrop_boost_mutex = rt_mutex_owner(&rnp->boost_mtx) == t;\n\t\t\tif (&t->rcu_node_entry == rnp->boost_tasks)\n\t\t\t\trnp->boost_tasks = np;\n\t\t}\n\n\t\t/*\n\t\t * If this was the last task on the current list, and if\n\t\t * we aren't waiting on any CPUs, report the quiescent state.\n\t\t * Note that rcu_report_unblock_qs_rnp() releases rnp->lock,\n\t\t * so we must take a snapshot of the expedited state.\n\t\t */\n\t\tempty_exp_now = sync_rcu_preempt_exp_done(rnp);\n\t\tif (!empty_norm && !rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\ttrace_rcu_quiescent_state_report(TPS(\"preempt_rcu\"),\n\t\t\t\t\t\t\t rnp->gp_seq,\n\t\t\t\t\t\t\t 0, rnp->qsmask,\n\t\t\t\t\t\t\t rnp->level,\n\t\t\t\t\t\t\t rnp->grplo,\n\t\t\t\t\t\t\t rnp->grphi,\n\t\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\t\trcu_report_unblock_qs_rnp(rnp, flags);\n\t\t} else {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\n\t\t/* Unboost if we were boosted. */\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST) && drop_boost_mutex)\n\t\t\trt_mutex_futex_unlock(&rnp->boost_mtx);\n\n\t\t/*\n\t\t * If this was the last task on the expedited lists,\n\t\t * then we need to report up the rcu_node hierarchy.\n\t\t */\n\t\tif (!empty_exp && empty_exp_now)\n\t\t\trcu_report_exp_rnp(rnp, true);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\nrcu_preempt_deferred_qs_irqrestore(struct task_struct *t, unsigned long flags)\n{\n\tbool empty_exp;\n\tbool empty_norm;\n\tbool empty_exp_now;\n\tstruct list_head *np;\n\tbool drop_boost_mutex = false;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunion rcu_special special;\n\n\t/*\n\t * If RCU core is waiting for this CPU to exit its critical section,\n\t * report the fact that it has exited.  Because irqs are disabled,\n\t * t->rcu_read_unlock_special cannot change.\n\t */\n\tspecial = t->rcu_read_unlock_special;\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!special.s && !rdp->deferred_qs) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tif (special.b.need_qs) {\n\t\trcu_qs();\n\t\tt->rcu_read_unlock_special.b.need_qs = false;\n\t\tif (!t->rcu_read_unlock_special.s && !rdp->deferred_qs) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Respond to a request by an expedited grace period for a\n\t * quiescent state from this CPU.  Note that requests from\n\t * tasks are handled when removing the task from the\n\t * blocked-tasks list below.\n\t */\n\tif (rdp->deferred_qs) {\n\t\trcu_report_exp_rdp(rdp);\n\t\tif (!t->rcu_read_unlock_special.s) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Clean up if blocked during RCU read-side critical section. */\n\tif (special.b.blocked) {\n\t\tt->rcu_read_unlock_special.b.blocked = false;\n\n\t\t/*\n\t\t * Remove this task from the list it blocked on.  The task\n\t\t * now remains queued on the rcu_node corresponding to the\n\t\t * CPU it first blocked on, so there is no longer any need\n\t\t * to loop.  Retain a WARN_ON_ONCE() out of sheer paranoia.\n\t\t */\n\t\trnp = t->rcu_blocked_node;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tWARN_ON_ONCE(rnp != t->rcu_blocked_node);\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t\tempty_norm = !rcu_preempt_blocked_readers_cgp(rnp);\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask));\n\t\tempty_exp = sync_rcu_preempt_exp_done(rnp);\n\t\tsmp_mb(); /* ensure expedited fastpath sees end of RCU c-s. */\n\t\tnp = rcu_next_node_entry(t, rnp);\n\t\tlist_del_init(&t->rcu_node_entry);\n\t\tt->rcu_blocked_node = NULL;\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t\tif (&t->rcu_node_entry == rnp->gp_tasks)\n\t\t\trnp->gp_tasks = np;\n\t\tif (&t->rcu_node_entry == rnp->exp_tasks)\n\t\t\trnp->exp_tasks = np;\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST)) {\n\t\t\t/* Snapshot ->boost_mtx ownership w/rnp->lock held. */\n\t\t\tdrop_boost_mutex = rt_mutex_owner(&rnp->boost_mtx) == t;\n\t\t\tif (&t->rcu_node_entry == rnp->boost_tasks)\n\t\t\t\trnp->boost_tasks = np;\n\t\t}\n\n\t\t/*\n\t\t * If this was the last task on the current list, and if\n\t\t * we aren't waiting on any CPUs, report the quiescent state.\n\t\t * Note that rcu_report_unblock_qs_rnp() releases rnp->lock,\n\t\t * so we must take a snapshot of the expedited state.\n\t\t */\n\t\tempty_exp_now = sync_rcu_preempt_exp_done(rnp);\n\t\tif (!empty_norm && !rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\ttrace_rcu_quiescent_state_report(TPS(\"preempt_rcu\"),\n\t\t\t\t\t\t\t rnp->gp_seq,\n\t\t\t\t\t\t\t 0, rnp->qsmask,\n\t\t\t\t\t\t\t rnp->level,\n\t\t\t\t\t\t\t rnp->grplo,\n\t\t\t\t\t\t\t rnp->grphi,\n\t\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\t\trcu_report_unblock_qs_rnp(rnp, flags);\n\t\t} else {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\n\t\t/* Unboost if we were boosted. */\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST) && drop_boost_mutex)\n\t\t\trt_mutex_futex_unlock(&rnp->boost_mtx);\n\n\t\t/*\n\t\t * If this was the last task on the expedited lists,\n\t\t * then we need to report up the rcu_node hierarchy.\n\t\t */\n\t\tif (!empty_exp && empty_exp_now)\n\t\t\trcu_report_exp_rnp(rnp, true);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "RCU_SOFTIRQ"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "449-453",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_read_unlock_special(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool preempt_bh_were_disabled =\n\t\t\t!!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK));\n\tbool irqs_were_disabled;\n\n\t/* NMI handlers cannot block and cannot safely manipulate state. */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tirqs_were_disabled = irqs_disabled_flags(flags);\n\tif ((preempt_bh_were_disabled || irqs_were_disabled) &&\n\t    t->rcu_read_unlock_special.b.blocked) {\n\t\t/* Need to defer quiescent state until everything is enabled. */\n\t\traise_softirq_irqoff(RCU_SOFTIRQ);\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n}"
  },
  {
    "function_name": "rcu_preempt_deferred_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "612-625",
    "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool couldrecurse = t->rcu_read_lock_nesting >= 0;\n\n\tif (!rcu_preempt_need_deferred_qs(t))\n\t\treturn;\n\tif (couldrecurse)\n\t\tt->rcu_read_lock_nesting -= INT_MIN;\n\tlocal_irq_save(flags);\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n\tif (couldrecurse)\n\t\tt->rcu_read_lock_nesting += INT_MIN;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs_irqrestore",
          "args": [
            "t",
            "flags"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "473-587",
          "snippet": "static void\nrcu_preempt_deferred_qs_irqrestore(struct task_struct *t, unsigned long flags)\n{\n\tbool empty_exp;\n\tbool empty_norm;\n\tbool empty_exp_now;\n\tstruct list_head *np;\n\tbool drop_boost_mutex = false;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunion rcu_special special;\n\n\t/*\n\t * If RCU core is waiting for this CPU to exit its critical section,\n\t * report the fact that it has exited.  Because irqs are disabled,\n\t * t->rcu_read_unlock_special cannot change.\n\t */\n\tspecial = t->rcu_read_unlock_special;\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!special.s && !rdp->deferred_qs) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tif (special.b.need_qs) {\n\t\trcu_qs();\n\t\tt->rcu_read_unlock_special.b.need_qs = false;\n\t\tif (!t->rcu_read_unlock_special.s && !rdp->deferred_qs) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Respond to a request by an expedited grace period for a\n\t * quiescent state from this CPU.  Note that requests from\n\t * tasks are handled when removing the task from the\n\t * blocked-tasks list below.\n\t */\n\tif (rdp->deferred_qs) {\n\t\trcu_report_exp_rdp(rdp);\n\t\tif (!t->rcu_read_unlock_special.s) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Clean up if blocked during RCU read-side critical section. */\n\tif (special.b.blocked) {\n\t\tt->rcu_read_unlock_special.b.blocked = false;\n\n\t\t/*\n\t\t * Remove this task from the list it blocked on.  The task\n\t\t * now remains queued on the rcu_node corresponding to the\n\t\t * CPU it first blocked on, so there is no longer any need\n\t\t * to loop.  Retain a WARN_ON_ONCE() out of sheer paranoia.\n\t\t */\n\t\trnp = t->rcu_blocked_node;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tWARN_ON_ONCE(rnp != t->rcu_blocked_node);\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t\tempty_norm = !rcu_preempt_blocked_readers_cgp(rnp);\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask));\n\t\tempty_exp = sync_rcu_preempt_exp_done(rnp);\n\t\tsmp_mb(); /* ensure expedited fastpath sees end of RCU c-s. */\n\t\tnp = rcu_next_node_entry(t, rnp);\n\t\tlist_del_init(&t->rcu_node_entry);\n\t\tt->rcu_blocked_node = NULL;\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t\tif (&t->rcu_node_entry == rnp->gp_tasks)\n\t\t\trnp->gp_tasks = np;\n\t\tif (&t->rcu_node_entry == rnp->exp_tasks)\n\t\t\trnp->exp_tasks = np;\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST)) {\n\t\t\t/* Snapshot ->boost_mtx ownership w/rnp->lock held. */\n\t\t\tdrop_boost_mutex = rt_mutex_owner(&rnp->boost_mtx) == t;\n\t\t\tif (&t->rcu_node_entry == rnp->boost_tasks)\n\t\t\t\trnp->boost_tasks = np;\n\t\t}\n\n\t\t/*\n\t\t * If this was the last task on the current list, and if\n\t\t * we aren't waiting on any CPUs, report the quiescent state.\n\t\t * Note that rcu_report_unblock_qs_rnp() releases rnp->lock,\n\t\t * so we must take a snapshot of the expedited state.\n\t\t */\n\t\tempty_exp_now = sync_rcu_preempt_exp_done(rnp);\n\t\tif (!empty_norm && !rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\ttrace_rcu_quiescent_state_report(TPS(\"preempt_rcu\"),\n\t\t\t\t\t\t\t rnp->gp_seq,\n\t\t\t\t\t\t\t 0, rnp->qsmask,\n\t\t\t\t\t\t\t rnp->level,\n\t\t\t\t\t\t\t rnp->grplo,\n\t\t\t\t\t\t\t rnp->grphi,\n\t\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\t\trcu_report_unblock_qs_rnp(rnp, flags);\n\t\t} else {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\n\t\t/* Unboost if we were boosted. */\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST) && drop_boost_mutex)\n\t\t\trt_mutex_futex_unlock(&rnp->boost_mtx);\n\n\t\t/*\n\t\t * If this was the last task on the expedited lists,\n\t\t * then we need to report up the rcu_node hierarchy.\n\t\t */\n\t\tif (!empty_exp && empty_exp_now)\n\t\t\trcu_report_exp_rnp(rnp, true);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\nrcu_preempt_deferred_qs_irqrestore(struct task_struct *t, unsigned long flags)\n{\n\tbool empty_exp;\n\tbool empty_norm;\n\tbool empty_exp_now;\n\tstruct list_head *np;\n\tbool drop_boost_mutex = false;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunion rcu_special special;\n\n\t/*\n\t * If RCU core is waiting for this CPU to exit its critical section,\n\t * report the fact that it has exited.  Because irqs are disabled,\n\t * t->rcu_read_unlock_special cannot change.\n\t */\n\tspecial = t->rcu_read_unlock_special;\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!special.s && !rdp->deferred_qs) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tif (special.b.need_qs) {\n\t\trcu_qs();\n\t\tt->rcu_read_unlock_special.b.need_qs = false;\n\t\tif (!t->rcu_read_unlock_special.s && !rdp->deferred_qs) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Respond to a request by an expedited grace period for a\n\t * quiescent state from this CPU.  Note that requests from\n\t * tasks are handled when removing the task from the\n\t * blocked-tasks list below.\n\t */\n\tif (rdp->deferred_qs) {\n\t\trcu_report_exp_rdp(rdp);\n\t\tif (!t->rcu_read_unlock_special.s) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Clean up if blocked during RCU read-side critical section. */\n\tif (special.b.blocked) {\n\t\tt->rcu_read_unlock_special.b.blocked = false;\n\n\t\t/*\n\t\t * Remove this task from the list it blocked on.  The task\n\t\t * now remains queued on the rcu_node corresponding to the\n\t\t * CPU it first blocked on, so there is no longer any need\n\t\t * to loop.  Retain a WARN_ON_ONCE() out of sheer paranoia.\n\t\t */\n\t\trnp = t->rcu_blocked_node;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tWARN_ON_ONCE(rnp != t->rcu_blocked_node);\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t\tempty_norm = !rcu_preempt_blocked_readers_cgp(rnp);\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask));\n\t\tempty_exp = sync_rcu_preempt_exp_done(rnp);\n\t\tsmp_mb(); /* ensure expedited fastpath sees end of RCU c-s. */\n\t\tnp = rcu_next_node_entry(t, rnp);\n\t\tlist_del_init(&t->rcu_node_entry);\n\t\tt->rcu_blocked_node = NULL;\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t\tif (&t->rcu_node_entry == rnp->gp_tasks)\n\t\t\trnp->gp_tasks = np;\n\t\tif (&t->rcu_node_entry == rnp->exp_tasks)\n\t\t\trnp->exp_tasks = np;\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST)) {\n\t\t\t/* Snapshot ->boost_mtx ownership w/rnp->lock held. */\n\t\t\tdrop_boost_mutex = rt_mutex_owner(&rnp->boost_mtx) == t;\n\t\t\tif (&t->rcu_node_entry == rnp->boost_tasks)\n\t\t\t\trnp->boost_tasks = np;\n\t\t}\n\n\t\t/*\n\t\t * If this was the last task on the current list, and if\n\t\t * we aren't waiting on any CPUs, report the quiescent state.\n\t\t * Note that rcu_report_unblock_qs_rnp() releases rnp->lock,\n\t\t * so we must take a snapshot of the expedited state.\n\t\t */\n\t\tempty_exp_now = sync_rcu_preempt_exp_done(rnp);\n\t\tif (!empty_norm && !rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\ttrace_rcu_quiescent_state_report(TPS(\"preempt_rcu\"),\n\t\t\t\t\t\t\t rnp->gp_seq,\n\t\t\t\t\t\t\t 0, rnp->qsmask,\n\t\t\t\t\t\t\t rnp->level,\n\t\t\t\t\t\t\t rnp->grplo,\n\t\t\t\t\t\t\t rnp->grphi,\n\t\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\t\trcu_report_unblock_qs_rnp(rnp, flags);\n\t\t} else {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\n\t\t/* Unboost if we were boosted. */\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST) && drop_boost_mutex)\n\t\t\trt_mutex_futex_unlock(&rnp->boost_mtx);\n\n\t\t/*\n\t\t * If this was the last task on the expedited lists,\n\t\t * then we need to report up the rcu_node hierarchy.\n\t\t */\n\t\tif (!empty_exp && empty_exp_now)\n\t\t\trcu_report_exp_rnp(rnp, true);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_need_deferred_qs",
          "args": [
            "t"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_need_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1034-1037",
          "snippet": "static bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool couldrecurse = t->rcu_read_lock_nesting >= 0;\n\n\tif (!rcu_preempt_need_deferred_qs(t))\n\t\treturn;\n\tif (couldrecurse)\n\t\tt->rcu_read_lock_nesting -= INT_MIN;\n\tlocal_irq_save(flags);\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n\tif (couldrecurse)\n\t\tt->rcu_read_lock_nesting += INT_MIN;\n}"
  },
  {
    "function_name": "rcu_preempt_need_deferred_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "598-603",
    "snippet": "static bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn (this_cpu_ptr(&rcu_data)->deferred_qs ||\n\t\tREAD_ONCE(t->rcu_read_unlock_special.s)) &&\n\t       t->rcu_read_lock_nesting <= 0;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->rcu_read_unlock_special.s"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn (this_cpu_ptr(&rcu_data)->deferred_qs ||\n\t\tREAD_ONCE(t->rcu_read_unlock_special.s)) &&\n\t       t->rcu_read_lock_nesting <= 0;\n}"
  },
  {
    "function_name": "rcu_preempt_deferred_qs_irqrestore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "473-587",
    "snippet": "static void\nrcu_preempt_deferred_qs_irqrestore(struct task_struct *t, unsigned long flags)\n{\n\tbool empty_exp;\n\tbool empty_norm;\n\tbool empty_exp_now;\n\tstruct list_head *np;\n\tbool drop_boost_mutex = false;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunion rcu_special special;\n\n\t/*\n\t * If RCU core is waiting for this CPU to exit its critical section,\n\t * report the fact that it has exited.  Because irqs are disabled,\n\t * t->rcu_read_unlock_special cannot change.\n\t */\n\tspecial = t->rcu_read_unlock_special;\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!special.s && !rdp->deferred_qs) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tif (special.b.need_qs) {\n\t\trcu_qs();\n\t\tt->rcu_read_unlock_special.b.need_qs = false;\n\t\tif (!t->rcu_read_unlock_special.s && !rdp->deferred_qs) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Respond to a request by an expedited grace period for a\n\t * quiescent state from this CPU.  Note that requests from\n\t * tasks are handled when removing the task from the\n\t * blocked-tasks list below.\n\t */\n\tif (rdp->deferred_qs) {\n\t\trcu_report_exp_rdp(rdp);\n\t\tif (!t->rcu_read_unlock_special.s) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Clean up if blocked during RCU read-side critical section. */\n\tif (special.b.blocked) {\n\t\tt->rcu_read_unlock_special.b.blocked = false;\n\n\t\t/*\n\t\t * Remove this task from the list it blocked on.  The task\n\t\t * now remains queued on the rcu_node corresponding to the\n\t\t * CPU it first blocked on, so there is no longer any need\n\t\t * to loop.  Retain a WARN_ON_ONCE() out of sheer paranoia.\n\t\t */\n\t\trnp = t->rcu_blocked_node;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tWARN_ON_ONCE(rnp != t->rcu_blocked_node);\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t\tempty_norm = !rcu_preempt_blocked_readers_cgp(rnp);\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask));\n\t\tempty_exp = sync_rcu_preempt_exp_done(rnp);\n\t\tsmp_mb(); /* ensure expedited fastpath sees end of RCU c-s. */\n\t\tnp = rcu_next_node_entry(t, rnp);\n\t\tlist_del_init(&t->rcu_node_entry);\n\t\tt->rcu_blocked_node = NULL;\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t\tif (&t->rcu_node_entry == rnp->gp_tasks)\n\t\t\trnp->gp_tasks = np;\n\t\tif (&t->rcu_node_entry == rnp->exp_tasks)\n\t\t\trnp->exp_tasks = np;\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST)) {\n\t\t\t/* Snapshot ->boost_mtx ownership w/rnp->lock held. */\n\t\t\tdrop_boost_mutex = rt_mutex_owner(&rnp->boost_mtx) == t;\n\t\t\tif (&t->rcu_node_entry == rnp->boost_tasks)\n\t\t\t\trnp->boost_tasks = np;\n\t\t}\n\n\t\t/*\n\t\t * If this was the last task on the current list, and if\n\t\t * we aren't waiting on any CPUs, report the quiescent state.\n\t\t * Note that rcu_report_unblock_qs_rnp() releases rnp->lock,\n\t\t * so we must take a snapshot of the expedited state.\n\t\t */\n\t\tempty_exp_now = sync_rcu_preempt_exp_done(rnp);\n\t\tif (!empty_norm && !rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\ttrace_rcu_quiescent_state_report(TPS(\"preempt_rcu\"),\n\t\t\t\t\t\t\t rnp->gp_seq,\n\t\t\t\t\t\t\t 0, rnp->qsmask,\n\t\t\t\t\t\t\t rnp->level,\n\t\t\t\t\t\t\t rnp->grplo,\n\t\t\t\t\t\t\t rnp->grphi,\n\t\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\t\trcu_report_unblock_qs_rnp(rnp, flags);\n\t\t} else {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\n\t\t/* Unboost if we were boosted. */\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST) && drop_boost_mutex)\n\t\t\trt_mutex_futex_unlock(&rnp->boost_mtx);\n\n\t\t/*\n\t\t * If this was the last task on the expedited lists,\n\t\t * then we need to report up the rcu_node hierarchy.\n\t\t */\n\t\tif (!empty_exp && empty_exp_now)\n\t\t\trcu_report_exp_rnp(rnp, true);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rnp",
          "args": [
            "rnp",
            "true"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "232-238",
          "snippet": "static void __maybe_unused rcu_report_exp_rnp(struct rcu_node *rnp, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t__rcu_report_exp_rnp(rnp, wake, flags);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic void __maybe_unused rcu_report_exp_rnp(struct rcu_node *rnp, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t__rcu_report_exp_rnp(rnp, wake, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_futex_unlock",
          "args": [
            "&rnp->boost_mtx"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_futex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1636-1648",
          "snippet": "void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_futex_unlock(struct rt_mutex *lock)\n{\n\tDEFINE_WAKE_Q(wake_q);\n\tunsigned long flags;\n\tbool postunlock;\n\n\traw_spin_lock_irqsave(&lock->wait_lock, flags);\n\tpostunlock = __rt_mutex_futex_unlock(lock, &wake_q);\n\traw_spin_unlock_irqrestore(&lock->wait_lock, flags);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wake_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_unblock_qs_rnp",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_unblock_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2197-2230",
          "snippet": "static void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void __maybe_unused;\n\nstatic void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_quiescent_state_report",
          "args": [
            "TPS(\"preempt_rcu\")",
            "rnp->gp_seq",
            "0",
            "rnp->qsmask",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "!!rnp->gp_tasks"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"preempt_rcu\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_rcu_preempt_exp_done",
          "args": [
            "rnp"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_preempt_exp_done_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "174-184",
          "snippet": "static bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_rcu_preempt_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_preempt_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "&rnp->boost_mtx"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex_common.h",
          "lines": "108-113",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}",
          "includes": [
            "# include \"rtmutex.h\"",
            "# include \"rtmutex-debug.h\"",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>"
          ],
          "macros_used": [
            "#define RT_MUTEX_HAS_WAITERS\t1UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"rtmutex.h\"\n# include \"rtmutex-debug.h\"\n#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_unlock_preempted_task",
          "args": [
            "TPS(\"rcu_preempt\")",
            "rnp->gp_seq",
            "t->pid"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"rcu_preempt\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&t->rcu_node_entry"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_next_node_entry",
          "args": [
            "t",
            "rnp"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_next_node_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "448-457",
          "snippet": "static struct list_head *rcu_next_node_entry(struct task_struct *t,\n\t\t\t\t\t     struct rcu_node *rnp)\n{\n\tstruct list_head *np;\n\n\tnp = t->rcu_node_entry.next;\n\tif (np == &rnp->blkd_tasks)\n\t\tnp = NULL;\n\treturn np;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic struct list_head *rcu_next_node_entry(struct task_struct *t,\n\t\t\t\t\t     struct rcu_node *rnp)\n{\n\tstruct list_head *np;\n\n\tnp = t->rcu_node_entry.next;\n\tif (np == &rnp->blkd_tasks)\n\t\tnp = NULL;\n\treturn np;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_leaf_node(rnp)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp != t->rcu_blocked_node"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "rdp"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\nrcu_preempt_deferred_qs_irqrestore(struct task_struct *t, unsigned long flags)\n{\n\tbool empty_exp;\n\tbool empty_norm;\n\tbool empty_exp_now;\n\tstruct list_head *np;\n\tbool drop_boost_mutex = false;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tunion rcu_special special;\n\n\t/*\n\t * If RCU core is waiting for this CPU to exit its critical section,\n\t * report the fact that it has exited.  Because irqs are disabled,\n\t * t->rcu_read_unlock_special cannot change.\n\t */\n\tspecial = t->rcu_read_unlock_special;\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!special.s && !rdp->deferred_qs) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tif (special.b.need_qs) {\n\t\trcu_qs();\n\t\tt->rcu_read_unlock_special.b.need_qs = false;\n\t\tif (!t->rcu_read_unlock_special.s && !rdp->deferred_qs) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Respond to a request by an expedited grace period for a\n\t * quiescent state from this CPU.  Note that requests from\n\t * tasks are handled when removing the task from the\n\t * blocked-tasks list below.\n\t */\n\tif (rdp->deferred_qs) {\n\t\trcu_report_exp_rdp(rdp);\n\t\tif (!t->rcu_read_unlock_special.s) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Clean up if blocked during RCU read-side critical section. */\n\tif (special.b.blocked) {\n\t\tt->rcu_read_unlock_special.b.blocked = false;\n\n\t\t/*\n\t\t * Remove this task from the list it blocked on.  The task\n\t\t * now remains queued on the rcu_node corresponding to the\n\t\t * CPU it first blocked on, so there is no longer any need\n\t\t * to loop.  Retain a WARN_ON_ONCE() out of sheer paranoia.\n\t\t */\n\t\trnp = t->rcu_blocked_node;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tWARN_ON_ONCE(rnp != t->rcu_blocked_node);\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t\tempty_norm = !rcu_preempt_blocked_readers_cgp(rnp);\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq &&\n\t\t\t     (!empty_norm || rnp->qsmask));\n\t\tempty_exp = sync_rcu_preempt_exp_done(rnp);\n\t\tsmp_mb(); /* ensure expedited fastpath sees end of RCU c-s. */\n\t\tnp = rcu_next_node_entry(t, rnp);\n\t\tlist_del_init(&t->rcu_node_entry);\n\t\tt->rcu_blocked_node = NULL;\n\t\ttrace_rcu_unlock_preempted_task(TPS(\"rcu_preempt\"),\n\t\t\t\t\t\trnp->gp_seq, t->pid);\n\t\tif (&t->rcu_node_entry == rnp->gp_tasks)\n\t\t\trnp->gp_tasks = np;\n\t\tif (&t->rcu_node_entry == rnp->exp_tasks)\n\t\t\trnp->exp_tasks = np;\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST)) {\n\t\t\t/* Snapshot ->boost_mtx ownership w/rnp->lock held. */\n\t\t\tdrop_boost_mutex = rt_mutex_owner(&rnp->boost_mtx) == t;\n\t\t\tif (&t->rcu_node_entry == rnp->boost_tasks)\n\t\t\t\trnp->boost_tasks = np;\n\t\t}\n\n\t\t/*\n\t\t * If this was the last task on the current list, and if\n\t\t * we aren't waiting on any CPUs, report the quiescent state.\n\t\t * Note that rcu_report_unblock_qs_rnp() releases rnp->lock,\n\t\t * so we must take a snapshot of the expedited state.\n\t\t */\n\t\tempty_exp_now = sync_rcu_preempt_exp_done(rnp);\n\t\tif (!empty_norm && !rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\ttrace_rcu_quiescent_state_report(TPS(\"preempt_rcu\"),\n\t\t\t\t\t\t\t rnp->gp_seq,\n\t\t\t\t\t\t\t 0, rnp->qsmask,\n\t\t\t\t\t\t\t rnp->level,\n\t\t\t\t\t\t\t rnp->grplo,\n\t\t\t\t\t\t\t rnp->grphi,\n\t\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\t\trcu_report_unblock_qs_rnp(rnp, flags);\n\t\t} else {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\n\t\t/* Unboost if we were boosted. */\n\t\tif (IS_ENABLED(CONFIG_RCU_BOOST) && drop_boost_mutex)\n\t\t\trt_mutex_futex_unlock(&rnp->boost_mtx);\n\n\t\t/*\n\t\t * If this was the last task on the expedited lists,\n\t\t * then we need to report up the rcu_node hierarchy.\n\t\t */\n\t\tif (!empty_exp && empty_exp_now)\n\t\t\trcu_report_exp_rnp(rnp, true);\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "rcu_preempt_has_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "463-466",
    "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn !list_empty(&rnp->blkd_tasks);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rnp->blkd_tasks"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn !list_empty(&rnp->blkd_tasks);\n}"
  },
  {
    "function_name": "rcu_next_node_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "448-457",
    "snippet": "static struct list_head *rcu_next_node_entry(struct task_struct *t,\n\t\t\t\t\t     struct rcu_node *rnp)\n{\n\tstruct list_head *np;\n\n\tnp = t->rcu_node_entry.next;\n\tif (np == &rnp->blkd_tasks)\n\t\tnp = NULL;\n\treturn np;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic struct list_head *rcu_next_node_entry(struct task_struct *t,\n\t\t\t\t\t     struct rcu_node *rnp)\n{\n\tstruct list_head *np;\n\n\tnp = t->rcu_node_entry.next;\n\tif (np == &rnp->blkd_tasks)\n\t\tnp = NULL;\n\treturn np;\n}"
  },
  {
    "function_name": "__rcu_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "419-441",
    "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rrln < 0 && rrln > INT_MIN / 2"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->rcu_read_lock_nesting"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_special",
          "args": [
            "t"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "632-653",
          "snippet": "static void rcu_read_unlock_special(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool preempt_bh_were_disabled =\n\t\t\t!!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK));\n\tbool irqs_were_disabled;\n\n\t/* NMI handlers cannot block and cannot safely manipulate state. */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tirqs_were_disabled = irqs_disabled_flags(flags);\n\tif ((preempt_bh_were_disabled || irqs_were_disabled) &&\n\t    t->rcu_read_unlock_special.b.blocked) {\n\t\t/* Need to defer quiescent state until everything is enabled. */\n\t\traise_softirq_irqoff(RCU_SOFTIRQ);\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_read_unlock_special(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool preempt_bh_were_disabled =\n\t\t\t!!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK));\n\tbool irqs_were_disabled;\n\n\t/* NMI handlers cannot block and cannot safely manipulate state. */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tirqs_were_disabled = irqs_disabled_flags(flags);\n\tif ((preempt_bh_were_disabled || irqs_were_disabled) &&\n\t    t->rcu_read_unlock_special.b.blocked) {\n\t\t/* Need to defer quiescent state until everything is enabled. */\n\t\traise_softirq_irqoff(RCU_SOFTIRQ);\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(t->rcu_read_unlock_special.s)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->rcu_read_unlock_special.s"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
  },
  {
    "function_name": "__rcu_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "405-409",
    "snippet": "void __rcu_read_lock(void)\n{\n\tcurrent->rcu_read_lock_nesting++;\n\tbarrier();  /* critical section after entry code. */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_lock(void)\n{\n\tcurrent->rcu_read_lock_nesting++;\n\tbarrier();  /* critical section after entry code. */\n}"
  },
  {
    "function_name": "rcu_preempt_blocked_readers_cgp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "395-398",
    "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn rnp->gp_tasks != NULL;\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn rnp->gp_tasks != NULL;\n}"
  },
  {
    "function_name": "rcu_note_context_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "328-387",
    "snippet": "void rcu_note_context_switch(bool preempt)\n{\n\tstruct task_struct *t = current;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\ttrace_rcu_utilization(TPS(\"Start context switch\"));\n\tlockdep_assert_irqs_disabled();\n\tWARN_ON_ONCE(!preempt && t->rcu_read_lock_nesting > 0);\n\tif (t->rcu_read_lock_nesting > 0 &&\n\t    !t->rcu_read_unlock_special.b.blocked) {\n\n\t\t/* Possibly blocking in an RCU read-side critical section. */\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp);\n\t\tt->rcu_read_unlock_special.b.blocked = true;\n\t\tt->rcu_blocked_node = rnp;\n\n\t\t/*\n\t\t * Verify the CPU's sanity, trace the preemption, and\n\t\t * then queue the task as required based on the states\n\t\t * of any ongoing and expedited grace periods.\n\t\t */\n\t\tWARN_ON_ONCE((rdp->grpmask & rcu_rnp_online_cpus(rnp)) == 0);\n\t\tWARN_ON_ONCE(!list_empty(&t->rcu_node_entry));\n\t\ttrace_rcu_preempt_task(rcu_state.name,\n\t\t\t\t       t->pid,\n\t\t\t\t       (rnp->qsmask & rdp->grpmask)\n\t\t\t\t       ? rnp->gp_seq\n\t\t\t\t       : rcu_seq_snap(&rnp->gp_seq));\n\t\trcu_preempt_ctxt_queue(rnp, rdp);\n\t} else if (t->rcu_read_lock_nesting < 0 &&\n\t\t   t->rcu_read_unlock_special.s) {\n\n\t\t/*\n\t\t * Complete exit from RCU read-side critical section on\n\t\t * behalf of preempted instance of __rcu_read_unlock().\n\t\t */\n\t\trcu_read_unlock_special(t);\n\t\trcu_preempt_deferred_qs(t);\n\t} else {\n\t\trcu_preempt_deferred_qs(t);\n\t}\n\n\t/*\n\t * Either we were not in an RCU read-side critical section to\n\t * begin with, or we have now recorded that critical section\n\t * globally.  Either way, we can now note a quiescent state\n\t * for this CPU.  Again, if we were in an RCU read-side critical\n\t * section, and if that critical section was blocking the current\n\t * grace period, then the fact that the task has been enqueued\n\t * means that we continue to block the current grace period.\n\t */\n\trcu_qs();\n\tif (rdp->deferred_qs)\n\t\trcu_report_exp_rdp(rdp);\n\ttrace_rcu_utilization(TPS(\"End context switch\"));\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End context switch\")"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End context switch\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "rdp"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "t"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_special",
          "args": [
            "t"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "632-653",
          "snippet": "static void rcu_read_unlock_special(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool preempt_bh_were_disabled =\n\t\t\t!!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK));\n\tbool irqs_were_disabled;\n\n\t/* NMI handlers cannot block and cannot safely manipulate state. */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tirqs_were_disabled = irqs_disabled_flags(flags);\n\tif ((preempt_bh_were_disabled || irqs_were_disabled) &&\n\t    t->rcu_read_unlock_special.b.blocked) {\n\t\t/* Need to defer quiescent state until everything is enabled. */\n\t\traise_softirq_irqoff(RCU_SOFTIRQ);\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_read_unlock_special(struct task_struct *t)\n{\n\tunsigned long flags;\n\tbool preempt_bh_were_disabled =\n\t\t\t!!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK));\n\tbool irqs_were_disabled;\n\n\t/* NMI handlers cannot block and cannot safely manipulate state. */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tirqs_were_disabled = irqs_disabled_flags(flags);\n\tif ((preempt_bh_were_disabled || irqs_were_disabled) &&\n\t    t->rcu_read_unlock_special.b.blocked) {\n\t\t/* Need to defer quiescent state until everything is enabled. */\n\t\traise_softirq_irqoff(RCU_SOFTIRQ);\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\trcu_preempt_deferred_qs_irqrestore(t, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_ctxt_queue",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_ctxt_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "173-287",
          "snippet": "static void rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)\n\t__releases(rnp->lock) /* But leaves rrupts disabled. */\n{\n\tint blkd_state = (rnp->gp_tasks ? RCU_GP_TASKS : 0) +\n\t\t\t (rnp->exp_tasks ? RCU_EXP_TASKS : 0) +\n\t\t\t (rnp->qsmask & rdp->grpmask ? RCU_GP_BLKD : 0) +\n\t\t\t (rnp->expmask & rdp->grpmask ? RCU_EXP_BLKD : 0);\n\tstruct task_struct *t = current;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tWARN_ON_ONCE(rdp->mynode != rnp);\n\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t/* RCU better not be waiting on newly onlined CPUs! */\n\tWARN_ON_ONCE(rnp->qsmaskinitnext & ~rnp->qsmaskinit & rnp->qsmask &\n\t\t     rdp->grpmask);\n\n\t/*\n\t * Decide where to queue the newly blocked task.  In theory,\n\t * this could be an if-statement.  In practice, when I tried\n\t * that, it was quite messy.\n\t */\n\tswitch (blkd_state) {\n\tcase 0:\n\tcase                RCU_EXP_TASKS:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD:\n\tcase RCU_GP_TASKS:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS:\n\n\t\t/*\n\t\t * Blocking neither GP, or first task blocking the normal\n\t\t * GP but not blocking the already-waiting expedited GP.\n\t\t * Queue at the head of the list to avoid unnecessarily\n\t\t * blocking the already-waiting GPs.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                                              RCU_EXP_BLKD:\n\tcase                                RCU_GP_BLKD:\n\tcase                                RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                               RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * First task arriving that blocks either GP, or first task\n\t\t * arriving that blocks the expedited GP (with the normal\n\t\t * GP already waiting), or a task arriving that blocks\n\t\t * both GPs with both GPs already waiting.  Queue at the\n\t\t * tail of the list to avoid any GP waiting on any of the\n\t\t * already queued tasks that are not blocking it.\n\t\t */\n\t\tlist_add_tail(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the expedited GP.\n\t\t * The task either does not block the normal GP, or is the\n\t\t * first task blocking the normal GP.  Queue just after\n\t\t * the first task blocking the expedited GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->exp_tasks);\n\t\tbreak;\n\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the normal GP.\n\t\t * The task does not block the expedited GP. Queue just\n\t\t * after the first task blocking the normal GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->gp_tasks);\n\t\tbreak;\n\n\tdefault:\n\n\t\t/* Yet another exercise in excessive paranoia. */\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We have now queued the task.  If it was the first one to\n\t * block either grace period, update the ->gp_tasks and/or\n\t * ->exp_tasks pointers, respectively, to reference the newly\n\t * blocked tasks.\n\t */\n\tif (!rnp->gp_tasks && (blkd_state & RCU_GP_BLKD)) {\n\t\trnp->gp_tasks = &t->rcu_node_entry;\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq);\n\t}\n\tif (!rnp->exp_tasks && (blkd_state & RCU_EXP_BLKD))\n\t\trnp->exp_tasks = &t->rcu_node_entry;\n\tWARN_ON_ONCE(!(blkd_state & RCU_GP_BLKD) !=\n\t\t     !(rnp->qsmask & rdp->grpmask));\n\tWARN_ON_ONCE(!(blkd_state & RCU_EXP_BLKD) !=\n\t\t     !(rnp->expmask & rdp->grpmask));\n\traw_spin_unlock_rcu_node(rnp); /* interrupts remain disabled. */\n\n\t/*\n\t * Report the quiescent state for the expedited GP.  This expedited\n\t * GP should not be able to end until we report, so there should be\n\t * no need to check for a subsequent expedited GP.  (Though we are\n\t * still in a quiescent state in any case.)\n\t */\n\tif (blkd_state & RCU_EXP_BLKD && rdp->deferred_qs)\n\t\trcu_report_exp_rdp(rdp);\n\telse\n\t\tWARN_ON_ONCE(rdp->deferred_qs);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define RCU_EXP_BLKD\t0x1",
            "#define RCU_GP_BLKD\t0x2",
            "#define RCU_EXP_TASKS\t0x4",
            "#define RCU_GP_TASKS\t0x8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\n#define RCU_EXP_BLKD\t0x1\n#define RCU_GP_BLKD\t0x2\n#define RCU_EXP_TASKS\t0x4\n#define RCU_GP_TASKS\t0x8\n\nstatic void rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)\n\t__releases(rnp->lock) /* But leaves rrupts disabled. */\n{\n\tint blkd_state = (rnp->gp_tasks ? RCU_GP_TASKS : 0) +\n\t\t\t (rnp->exp_tasks ? RCU_EXP_TASKS : 0) +\n\t\t\t (rnp->qsmask & rdp->grpmask ? RCU_GP_BLKD : 0) +\n\t\t\t (rnp->expmask & rdp->grpmask ? RCU_EXP_BLKD : 0);\n\tstruct task_struct *t = current;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tWARN_ON_ONCE(rdp->mynode != rnp);\n\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t/* RCU better not be waiting on newly onlined CPUs! */\n\tWARN_ON_ONCE(rnp->qsmaskinitnext & ~rnp->qsmaskinit & rnp->qsmask &\n\t\t     rdp->grpmask);\n\n\t/*\n\t * Decide where to queue the newly blocked task.  In theory,\n\t * this could be an if-statement.  In practice, when I tried\n\t * that, it was quite messy.\n\t */\n\tswitch (blkd_state) {\n\tcase 0:\n\tcase                RCU_EXP_TASKS:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD:\n\tcase RCU_GP_TASKS:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS:\n\n\t\t/*\n\t\t * Blocking neither GP, or first task blocking the normal\n\t\t * GP but not blocking the already-waiting expedited GP.\n\t\t * Queue at the head of the list to avoid unnecessarily\n\t\t * blocking the already-waiting GPs.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                                              RCU_EXP_BLKD:\n\tcase                                RCU_GP_BLKD:\n\tcase                                RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                               RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * First task arriving that blocks either GP, or first task\n\t\t * arriving that blocks the expedited GP (with the normal\n\t\t * GP already waiting), or a task arriving that blocks\n\t\t * both GPs with both GPs already waiting.  Queue at the\n\t\t * tail of the list to avoid any GP waiting on any of the\n\t\t * already queued tasks that are not blocking it.\n\t\t */\n\t\tlist_add_tail(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the expedited GP.\n\t\t * The task either does not block the normal GP, or is the\n\t\t * first task blocking the normal GP.  Queue just after\n\t\t * the first task blocking the expedited GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->exp_tasks);\n\t\tbreak;\n\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the normal GP.\n\t\t * The task does not block the expedited GP. Queue just\n\t\t * after the first task blocking the normal GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->gp_tasks);\n\t\tbreak;\n\n\tdefault:\n\n\t\t/* Yet another exercise in excessive paranoia. */\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We have now queued the task.  If it was the first one to\n\t * block either grace period, update the ->gp_tasks and/or\n\t * ->exp_tasks pointers, respectively, to reference the newly\n\t * blocked tasks.\n\t */\n\tif (!rnp->gp_tasks && (blkd_state & RCU_GP_BLKD)) {\n\t\trnp->gp_tasks = &t->rcu_node_entry;\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq);\n\t}\n\tif (!rnp->exp_tasks && (blkd_state & RCU_EXP_BLKD))\n\t\trnp->exp_tasks = &t->rcu_node_entry;\n\tWARN_ON_ONCE(!(blkd_state & RCU_GP_BLKD) !=\n\t\t     !(rnp->qsmask & rdp->grpmask));\n\tWARN_ON_ONCE(!(blkd_state & RCU_EXP_BLKD) !=\n\t\t     !(rnp->expmask & rdp->grpmask));\n\traw_spin_unlock_rcu_node(rnp); /* interrupts remain disabled. */\n\n\t/*\n\t * Report the quiescent state for the expedited GP.  This expedited\n\t * GP should not be able to end until we report, so there should be\n\t * no need to check for a subsequent expedited GP.  (Though we are\n\t * still in a quiescent state in any case.)\n\t */\n\tif (blkd_state & RCU_EXP_BLKD && rdp->deferred_qs)\n\t\trcu_report_exp_rdp(rdp);\n\telse\n\t\tWARN_ON_ONCE(rdp->deferred_qs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_preempt_task",
          "args": [
            "rcu_state.name",
            "t->pid",
            "(rnp->qsmask & rdp->grpmask)\n\t\t\t\t       ? rnp->gp_seq\n\t\t\t\t       : rcu_seq_snap(&rnp->gp_seq)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&t->rcu_node_entry)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&t->rcu_node_entry"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(rdp->grpmask & rcu_rnp_online_cpus(rnp)) == 0"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "195-198",
          "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!preempt && t->rcu_read_lock_nesting > 0"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start context switch\")"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start context switch\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid rcu_note_context_switch(bool preempt)\n{\n\tstruct task_struct *t = current;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\ttrace_rcu_utilization(TPS(\"Start context switch\"));\n\tlockdep_assert_irqs_disabled();\n\tWARN_ON_ONCE(!preempt && t->rcu_read_lock_nesting > 0);\n\tif (t->rcu_read_lock_nesting > 0 &&\n\t    !t->rcu_read_unlock_special.b.blocked) {\n\n\t\t/* Possibly blocking in an RCU read-side critical section. */\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp);\n\t\tt->rcu_read_unlock_special.b.blocked = true;\n\t\tt->rcu_blocked_node = rnp;\n\n\t\t/*\n\t\t * Verify the CPU's sanity, trace the preemption, and\n\t\t * then queue the task as required based on the states\n\t\t * of any ongoing and expedited grace periods.\n\t\t */\n\t\tWARN_ON_ONCE((rdp->grpmask & rcu_rnp_online_cpus(rnp)) == 0);\n\t\tWARN_ON_ONCE(!list_empty(&t->rcu_node_entry));\n\t\ttrace_rcu_preempt_task(rcu_state.name,\n\t\t\t\t       t->pid,\n\t\t\t\t       (rnp->qsmask & rdp->grpmask)\n\t\t\t\t       ? rnp->gp_seq\n\t\t\t\t       : rcu_seq_snap(&rnp->gp_seq));\n\t\trcu_preempt_ctxt_queue(rnp, rdp);\n\t} else if (t->rcu_read_lock_nesting < 0 &&\n\t\t   t->rcu_read_unlock_special.s) {\n\n\t\t/*\n\t\t * Complete exit from RCU read-side critical section on\n\t\t * behalf of preempted instance of __rcu_read_unlock().\n\t\t */\n\t\trcu_read_unlock_special(t);\n\t\trcu_preempt_deferred_qs(t);\n\t} else {\n\t\trcu_preempt_deferred_qs(t);\n\t}\n\n\t/*\n\t * Either we were not in an RCU read-side critical section to\n\t * begin with, or we have now recorded that critical section\n\t * globally.  Either way, we can now note a quiescent state\n\t * for this CPU.  Again, if we were in an RCU read-side critical\n\t * section, and if that critical section was blocking the current\n\t * grace period, then the fact that the task has been enqueued\n\t * means that we continue to block the current grace period.\n\t */\n\trcu_qs();\n\tif (rdp->deferred_qs)\n\t\trcu_report_exp_rdp(rdp);\n\ttrace_rcu_utilization(TPS(\"End context switch\"));\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n}"
  },
  {
    "function_name": "rcu_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "302-313",
    "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\\n\");\n\tif (__this_cpu_read(rcu_data.cpu_no_qs.s)) {\n\t\ttrace_rcu_grace_period(TPS(\"rcu_preempt\"),\n\t\t\t\t       __this_cpu_read(rcu_data.gp_seq),\n\t\t\t\t       TPS(\"cpuqs\"));\n\t\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\t\tbarrier(); /* Coordinate with rcu_flavor_check_callbacks(). */\n\t\tcurrent->rcu_read_unlock_special.b.need_qs = false;\n\t}\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.cpu_no_qs.b.norm",
            "false"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "TPS(\"rcu_preempt\")",
            "__this_cpu_read(rcu_data.gp_seq)",
            "TPS(\"cpuqs\")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuqs\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.gp_seq"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"rcu_preempt\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.cpu_no_qs.s"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "preemptible()",
            "\"rcu_qs() invoked with preemption enabled!!!\\n\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\\n\");\n\tif (__this_cpu_read(rcu_data.cpu_no_qs.s)) {\n\t\ttrace_rcu_grace_period(TPS(\"rcu_preempt\"),\n\t\t\t\t       __this_cpu_read(rcu_data.gp_seq),\n\t\t\t\t       TPS(\"cpuqs\"));\n\t\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\t\tbarrier(); /* Coordinate with rcu_flavor_check_callbacks(). */\n\t\tcurrent->rcu_read_unlock_special.b.need_qs = false;\n\t}\n}"
  },
  {
    "function_name": "rcu_preempt_ctxt_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "173-287",
    "snippet": "static void rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)\n\t__releases(rnp->lock) /* But leaves rrupts disabled. */\n{\n\tint blkd_state = (rnp->gp_tasks ? RCU_GP_TASKS : 0) +\n\t\t\t (rnp->exp_tasks ? RCU_EXP_TASKS : 0) +\n\t\t\t (rnp->qsmask & rdp->grpmask ? RCU_GP_BLKD : 0) +\n\t\t\t (rnp->expmask & rdp->grpmask ? RCU_EXP_BLKD : 0);\n\tstruct task_struct *t = current;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tWARN_ON_ONCE(rdp->mynode != rnp);\n\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t/* RCU better not be waiting on newly onlined CPUs! */\n\tWARN_ON_ONCE(rnp->qsmaskinitnext & ~rnp->qsmaskinit & rnp->qsmask &\n\t\t     rdp->grpmask);\n\n\t/*\n\t * Decide where to queue the newly blocked task.  In theory,\n\t * this could be an if-statement.  In practice, when I tried\n\t * that, it was quite messy.\n\t */\n\tswitch (blkd_state) {\n\tcase 0:\n\tcase                RCU_EXP_TASKS:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD:\n\tcase RCU_GP_TASKS:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS:\n\n\t\t/*\n\t\t * Blocking neither GP, or first task blocking the normal\n\t\t * GP but not blocking the already-waiting expedited GP.\n\t\t * Queue at the head of the list to avoid unnecessarily\n\t\t * blocking the already-waiting GPs.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                                              RCU_EXP_BLKD:\n\tcase                                RCU_GP_BLKD:\n\tcase                                RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                               RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * First task arriving that blocks either GP, or first task\n\t\t * arriving that blocks the expedited GP (with the normal\n\t\t * GP already waiting), or a task arriving that blocks\n\t\t * both GPs with both GPs already waiting.  Queue at the\n\t\t * tail of the list to avoid any GP waiting on any of the\n\t\t * already queued tasks that are not blocking it.\n\t\t */\n\t\tlist_add_tail(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the expedited GP.\n\t\t * The task either does not block the normal GP, or is the\n\t\t * first task blocking the normal GP.  Queue just after\n\t\t * the first task blocking the expedited GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->exp_tasks);\n\t\tbreak;\n\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the normal GP.\n\t\t * The task does not block the expedited GP. Queue just\n\t\t * after the first task blocking the normal GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->gp_tasks);\n\t\tbreak;\n\n\tdefault:\n\n\t\t/* Yet another exercise in excessive paranoia. */\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We have now queued the task.  If it was the first one to\n\t * block either grace period, update the ->gp_tasks and/or\n\t * ->exp_tasks pointers, respectively, to reference the newly\n\t * blocked tasks.\n\t */\n\tif (!rnp->gp_tasks && (blkd_state & RCU_GP_BLKD)) {\n\t\trnp->gp_tasks = &t->rcu_node_entry;\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq);\n\t}\n\tif (!rnp->exp_tasks && (blkd_state & RCU_EXP_BLKD))\n\t\trnp->exp_tasks = &t->rcu_node_entry;\n\tWARN_ON_ONCE(!(blkd_state & RCU_GP_BLKD) !=\n\t\t     !(rnp->qsmask & rdp->grpmask));\n\tWARN_ON_ONCE(!(blkd_state & RCU_EXP_BLKD) !=\n\t\t     !(rnp->expmask & rdp->grpmask));\n\traw_spin_unlock_rcu_node(rnp); /* interrupts remain disabled. */\n\n\t/*\n\t * Report the quiescent state for the expedited GP.  This expedited\n\t * GP should not be able to end until we report, so there should be\n\t * no need to check for a subsequent expedited GP.  (Though we are\n\t * still in a quiescent state in any case.)\n\t */\n\tif (blkd_state & RCU_EXP_BLKD && rdp->deferred_qs)\n\t\trcu_report_exp_rdp(rdp);\n\telse\n\t\tWARN_ON_ONCE(rdp->deferred_qs);\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define RCU_EXP_BLKD\t0x1",
      "#define RCU_GP_BLKD\t0x2",
      "#define RCU_EXP_TASKS\t0x4",
      "#define RCU_GP_TASKS\t0x8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->deferred_qs"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "rdp"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(blkd_state & RCU_EXP_BLKD) !=\n\t\t     !(rnp->expmask & rdp->grpmask)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(blkd_state & RCU_GP_BLKD) !=\n\t\t     !(rnp->qsmask & rdp->grpmask)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->completedqs == rnp->gp_seq"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&t->rcu_node_entry",
            "rnp->gp_tasks"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&t->rcu_node_entry",
            "&rnp->blkd_tasks"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmaskinitnext & ~rnp->qsmaskinit & rnp->qsmask &\n\t\t     rdp->grpmask"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_leaf_node(rnp)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->mynode != rnp"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\n#define RCU_EXP_BLKD\t0x1\n#define RCU_GP_BLKD\t0x2\n#define RCU_EXP_TASKS\t0x4\n#define RCU_GP_TASKS\t0x8\n\nstatic void rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)\n\t__releases(rnp->lock) /* But leaves rrupts disabled. */\n{\n\tint blkd_state = (rnp->gp_tasks ? RCU_GP_TASKS : 0) +\n\t\t\t (rnp->exp_tasks ? RCU_EXP_TASKS : 0) +\n\t\t\t (rnp->qsmask & rdp->grpmask ? RCU_GP_BLKD : 0) +\n\t\t\t (rnp->expmask & rdp->grpmask ? RCU_EXP_BLKD : 0);\n\tstruct task_struct *t = current;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tWARN_ON_ONCE(rdp->mynode != rnp);\n\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp));\n\t/* RCU better not be waiting on newly onlined CPUs! */\n\tWARN_ON_ONCE(rnp->qsmaskinitnext & ~rnp->qsmaskinit & rnp->qsmask &\n\t\t     rdp->grpmask);\n\n\t/*\n\t * Decide where to queue the newly blocked task.  In theory,\n\t * this could be an if-statement.  In practice, when I tried\n\t * that, it was quite messy.\n\t */\n\tswitch (blkd_state) {\n\tcase 0:\n\tcase                RCU_EXP_TASKS:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD:\n\tcase RCU_GP_TASKS:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS:\n\n\t\t/*\n\t\t * Blocking neither GP, or first task blocking the normal\n\t\t * GP but not blocking the already-waiting expedited GP.\n\t\t * Queue at the head of the list to avoid unnecessarily\n\t\t * blocking the already-waiting GPs.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                                              RCU_EXP_BLKD:\n\tcase                                RCU_GP_BLKD:\n\tcase                                RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                               RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * First task arriving that blocks either GP, or first task\n\t\t * arriving that blocks the expedited GP (with the normal\n\t\t * GP already waiting), or a task arriving that blocks\n\t\t * both GPs with both GPs already waiting.  Queue at the\n\t\t * tail of the list to avoid any GP waiting on any of the\n\t\t * already queued tasks that are not blocking it.\n\t\t */\n\t\tlist_add_tail(&t->rcu_node_entry, &rnp->blkd_tasks);\n\t\tbreak;\n\n\tcase                RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\tcase                RCU_EXP_TASKS + RCU_GP_BLKD + RCU_EXP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS +               RCU_EXP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the expedited GP.\n\t\t * The task either does not block the normal GP, or is the\n\t\t * first task blocking the normal GP.  Queue just after\n\t\t * the first task blocking the expedited GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->exp_tasks);\n\t\tbreak;\n\n\tcase RCU_GP_TASKS +                 RCU_GP_BLKD:\n\tcase RCU_GP_TASKS + RCU_EXP_TASKS + RCU_GP_BLKD:\n\n\t\t/*\n\t\t * Second or subsequent task blocking the normal GP.\n\t\t * The task does not block the expedited GP. Queue just\n\t\t * after the first task blocking the normal GP.\n\t\t */\n\t\tlist_add(&t->rcu_node_entry, rnp->gp_tasks);\n\t\tbreak;\n\n\tdefault:\n\n\t\t/* Yet another exercise in excessive paranoia. */\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We have now queued the task.  If it was the first one to\n\t * block either grace period, update the ->gp_tasks and/or\n\t * ->exp_tasks pointers, respectively, to reference the newly\n\t * blocked tasks.\n\t */\n\tif (!rnp->gp_tasks && (blkd_state & RCU_GP_BLKD)) {\n\t\trnp->gp_tasks = &t->rcu_node_entry;\n\t\tWARN_ON_ONCE(rnp->completedqs == rnp->gp_seq);\n\t}\n\tif (!rnp->exp_tasks && (blkd_state & RCU_EXP_BLKD))\n\t\trnp->exp_tasks = &t->rcu_node_entry;\n\tWARN_ON_ONCE(!(blkd_state & RCU_GP_BLKD) !=\n\t\t     !(rnp->qsmask & rdp->grpmask));\n\tWARN_ON_ONCE(!(blkd_state & RCU_EXP_BLKD) !=\n\t\t     !(rnp->expmask & rdp->grpmask));\n\traw_spin_unlock_rcu_node(rnp); /* interrupts remain disabled. */\n\n\t/*\n\t * Report the quiescent state for the expedited GP.  This expedited\n\t * GP should not be able to end until we report, so there should be\n\t * no need to check for a subsequent expedited GP.  (Though we are\n\t * still in a quiescent state in any case.)\n\t */\n\tif (blkd_state & RCU_EXP_BLKD && rdp->deferred_qs)\n\t\trcu_report_exp_rdp(rdp);\n\telse\n\t\tWARN_ON_ONCE(rdp->deferred_qs);\n}"
  },
  {
    "function_name": "rcu_bootup_announce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "133-137",
    "snippet": "static void __init rcu_bootup_announce(void)\n{\n\tpr_info(\"Preemptible hierarchical RCU implementation.\\n\");\n\trcu_bootup_announce_oddness();\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_bootup_announce_oddness",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_bootup_announce_oddness",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "70-123",
          "snippet": "static void __init rcu_bootup_announce_oddness(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TRACE))\n\t\tpr_info(\"\\tRCU event tracing is enabled.\\n\");\n\tif ((IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 64) ||\n\t    (!IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 32))\n\t\tpr_info(\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\",\n\t\t\tRCU_FANOUT);\n\tif (rcu_fanout_exact)\n\t\tpr_info(\"\\tHierarchical RCU autobalancing is disabled.\\n\");\n\tif (IS_ENABLED(CONFIG_RCU_FAST_NO_HZ))\n\t\tpr_info(\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\");\n\tif (IS_ENABLED(CONFIG_PROVE_RCU))\n\t\tpr_info(\"\\tRCU lockdep checking is enabled.\\n\");\n\tif (RCU_NUM_LVLS >= 4)\n\t\tpr_info(\"\\tFour(or more)-level hierarchy is enabled.\\n\");\n\tif (RCU_FANOUT_LEAF != 16)\n\t\tpr_info(\"\\tBuild-time adjustment of leaf fanout to %d.\\n\",\n\t\t\tRCU_FANOUT_LEAF);\n\tif (rcu_fanout_leaf != RCU_FANOUT_LEAF)\n\t\tpr_info(\"\\tBoot-time adjustment of leaf fanout to %d.\\n\",\n\t\t\trcu_fanout_leaf);\n\tif (nr_cpu_ids != NR_CPUS)\n\t\tpr_info(\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\", NR_CPUS, nr_cpu_ids);\n#ifdef CONFIG_RCU_BOOST\n\tpr_info(\"\\tRCU priority boosting: priority %d delay %d ms.\\n\",\n\t\tkthread_prio, CONFIG_RCU_BOOST_DELAY);\n#endif\n\tif (blimit != DEFAULT_RCU_BLIMIT)\n\t\tpr_info(\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\", blimit);\n\tif (qhimark != DEFAULT_RCU_QHIMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\", qhimark);\n\tif (qlowmark != DEFAULT_RCU_QLOMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\", qlowmark);\n\tif (jiffies_till_first_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\", jiffies_till_first_fqs);\n\tif (jiffies_till_next_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\", jiffies_till_next_fqs);\n\tif (jiffies_till_sched_qs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\", jiffies_till_sched_qs);\n\tif (rcu_kick_kthreads)\n\t\tpr_info(\"\\tKick kthreads if too-long grace period.\\n\");\n\tif (IS_ENABLED(CONFIG_DEBUG_OBJECTS_RCU_HEAD))\n\t\tpr_info(\"\\tRCU callback double-/use-after-free debug enabled.\\n\");\n\tif (gp_preinit_delay)\n\t\tpr_info(\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\", gp_preinit_delay);\n\tif (gp_init_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_init_delay);\n\tif (gp_cleanup_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_cleanup_delay);\n\tif (IS_ENABLED(CONFIG_RCU_EQS_DEBUG))\n\t\tpr_info(\"\\tRCU debug extended QS entry/exit.\\n\");\n\trcupdate_announce_bootup_oddness();\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_bootup_announce_oddness(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TRACE))\n\t\tpr_info(\"\\tRCU event tracing is enabled.\\n\");\n\tif ((IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 64) ||\n\t    (!IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 32))\n\t\tpr_info(\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\",\n\t\t\tRCU_FANOUT);\n\tif (rcu_fanout_exact)\n\t\tpr_info(\"\\tHierarchical RCU autobalancing is disabled.\\n\");\n\tif (IS_ENABLED(CONFIG_RCU_FAST_NO_HZ))\n\t\tpr_info(\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\");\n\tif (IS_ENABLED(CONFIG_PROVE_RCU))\n\t\tpr_info(\"\\tRCU lockdep checking is enabled.\\n\");\n\tif (RCU_NUM_LVLS >= 4)\n\t\tpr_info(\"\\tFour(or more)-level hierarchy is enabled.\\n\");\n\tif (RCU_FANOUT_LEAF != 16)\n\t\tpr_info(\"\\tBuild-time adjustment of leaf fanout to %d.\\n\",\n\t\t\tRCU_FANOUT_LEAF);\n\tif (rcu_fanout_leaf != RCU_FANOUT_LEAF)\n\t\tpr_info(\"\\tBoot-time adjustment of leaf fanout to %d.\\n\",\n\t\t\trcu_fanout_leaf);\n\tif (nr_cpu_ids != NR_CPUS)\n\t\tpr_info(\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\", NR_CPUS, nr_cpu_ids);\n#ifdef CONFIG_RCU_BOOST\n\tpr_info(\"\\tRCU priority boosting: priority %d delay %d ms.\\n\",\n\t\tkthread_prio, CONFIG_RCU_BOOST_DELAY);\n#endif\n\tif (blimit != DEFAULT_RCU_BLIMIT)\n\t\tpr_info(\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\", blimit);\n\tif (qhimark != DEFAULT_RCU_QHIMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\", qhimark);\n\tif (qlowmark != DEFAULT_RCU_QLOMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\", qlowmark);\n\tif (jiffies_till_first_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\", jiffies_till_first_fqs);\n\tif (jiffies_till_next_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\", jiffies_till_next_fqs);\n\tif (jiffies_till_sched_qs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\", jiffies_till_sched_qs);\n\tif (rcu_kick_kthreads)\n\t\tpr_info(\"\\tKick kthreads if too-long grace period.\\n\");\n\tif (IS_ENABLED(CONFIG_DEBUG_OBJECTS_RCU_HEAD))\n\t\tpr_info(\"\\tRCU callback double-/use-after-free debug enabled.\\n\");\n\tif (gp_preinit_delay)\n\t\tpr_info(\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\", gp_preinit_delay);\n\tif (gp_init_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_init_delay);\n\tif (gp_cleanup_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_cleanup_delay);\n\tif (IS_ENABLED(CONFIG_RCU_EQS_DEBUG))\n\t\tpr_info(\"\\tRCU debug extended QS entry/exit.\\n\");\n\trcupdate_announce_bootup_oddness();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Preemptible hierarchical RCU implementation.\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_bootup_announce(void)\n{\n\tpr_info(\"Preemptible hierarchical RCU implementation.\\n\");\n\trcu_bootup_announce_oddness();\n}"
  },
  {
    "function_name": "rcu_bootup_announce_oddness",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
    "lines": "70-123",
    "snippet": "static void __init rcu_bootup_announce_oddness(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TRACE))\n\t\tpr_info(\"\\tRCU event tracing is enabled.\\n\");\n\tif ((IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 64) ||\n\t    (!IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 32))\n\t\tpr_info(\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\",\n\t\t\tRCU_FANOUT);\n\tif (rcu_fanout_exact)\n\t\tpr_info(\"\\tHierarchical RCU autobalancing is disabled.\\n\");\n\tif (IS_ENABLED(CONFIG_RCU_FAST_NO_HZ))\n\t\tpr_info(\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\");\n\tif (IS_ENABLED(CONFIG_PROVE_RCU))\n\t\tpr_info(\"\\tRCU lockdep checking is enabled.\\n\");\n\tif (RCU_NUM_LVLS >= 4)\n\t\tpr_info(\"\\tFour(or more)-level hierarchy is enabled.\\n\");\n\tif (RCU_FANOUT_LEAF != 16)\n\t\tpr_info(\"\\tBuild-time adjustment of leaf fanout to %d.\\n\",\n\t\t\tRCU_FANOUT_LEAF);\n\tif (rcu_fanout_leaf != RCU_FANOUT_LEAF)\n\t\tpr_info(\"\\tBoot-time adjustment of leaf fanout to %d.\\n\",\n\t\t\trcu_fanout_leaf);\n\tif (nr_cpu_ids != NR_CPUS)\n\t\tpr_info(\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\", NR_CPUS, nr_cpu_ids);\n#ifdef CONFIG_RCU_BOOST\n\tpr_info(\"\\tRCU priority boosting: priority %d delay %d ms.\\n\",\n\t\tkthread_prio, CONFIG_RCU_BOOST_DELAY);\n#endif\n\tif (blimit != DEFAULT_RCU_BLIMIT)\n\t\tpr_info(\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\", blimit);\n\tif (qhimark != DEFAULT_RCU_QHIMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\", qhimark);\n\tif (qlowmark != DEFAULT_RCU_QLOMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\", qlowmark);\n\tif (jiffies_till_first_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\", jiffies_till_first_fqs);\n\tif (jiffies_till_next_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\", jiffies_till_next_fqs);\n\tif (jiffies_till_sched_qs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\", jiffies_till_sched_qs);\n\tif (rcu_kick_kthreads)\n\t\tpr_info(\"\\tKick kthreads if too-long grace period.\\n\");\n\tif (IS_ENABLED(CONFIG_DEBUG_OBJECTS_RCU_HEAD))\n\t\tpr_info(\"\\tRCU callback double-/use-after-free debug enabled.\\n\");\n\tif (gp_preinit_delay)\n\t\tpr_info(\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\", gp_preinit_delay);\n\tif (gp_init_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_init_delay);\n\tif (gp_cleanup_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_cleanup_delay);\n\tif (IS_ENABLED(CONFIG_RCU_EQS_DEBUG))\n\t\tpr_info(\"\\tRCU debug extended QS entry/exit.\\n\");\n\trcupdate_announce_bootup_oddness();\n}",
    "includes": [
      "#include \"../locking/rtmutex_common.h\"",
      "#include \"../time/tick-internal.h\"",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/oom.h>",
      "#include <linux/gfp.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcupdate_announce_bootup_oddness",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "rcupdate_announce_bootup_oddness",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "934-947",
          "snippet": "void __init rcupdate_announce_bootup_oddness(void)\n{\n\tif (rcu_normal)\n\t\tpr_info(\"\\tNo expedited grace period (rcu_normal).\\n\");\n\telse if (rcu_normal_after_boot)\n\t\tpr_info(\"\\tNo expedited grace period (rcu_normal_after_boot).\\n\");\n\telse if (rcu_expedited)\n\t\tpr_info(\"\\tAll grace periods are expedited (rcu_expedited).\\n\");\n\tif (rcu_cpu_stall_suppress)\n\t\tpr_info(\"\\tRCU CPU stall warnings suppressed (rcu_cpu_stall_suppress).\\n\");\n\tif (rcu_cpu_stall_timeout != CONFIG_RCU_CPU_STALL_TIMEOUT)\n\t\tpr_info(\"\\tRCU CPU stall warnings timeout set to %d (rcu_cpu_stall_timeout).\\n\", rcu_cpu_stall_timeout);\n\trcu_tasks_bootup_oddness();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid __init rcupdate_announce_bootup_oddness(void)\n{\n\tif (rcu_normal)\n\t\tpr_info(\"\\tNo expedited grace period (rcu_normal).\\n\");\n\telse if (rcu_normal_after_boot)\n\t\tpr_info(\"\\tNo expedited grace period (rcu_normal_after_boot).\\n\");\n\telse if (rcu_expedited)\n\t\tpr_info(\"\\tAll grace periods are expedited (rcu_expedited).\\n\");\n\tif (rcu_cpu_stall_suppress)\n\t\tpr_info(\"\\tRCU CPU stall warnings suppressed (rcu_cpu_stall_suppress).\\n\");\n\tif (rcu_cpu_stall_timeout != CONFIG_RCU_CPU_STALL_TIMEOUT)\n\t\tpr_info(\"\\tRCU CPU stall warnings timeout set to %d (rcu_cpu_stall_timeout).\\n\", rcu_cpu_stall_timeout);\n\trcu_tasks_bootup_oddness();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU debug extended QS entry/exit.\\n\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU debug GP init slowdown %d jiffies.\\n\"",
            "gp_cleanup_delay"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU debug GP init slowdown %d jiffies.\\n\"",
            "gp_init_delay"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\"",
            "gp_preinit_delay"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU callback double-/use-after-free debug enabled.\\n\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_OBJECTS_RCU_HEAD"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tKick kthreads if too-long grace period.\\n\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\"",
            "jiffies_till_sched_qs"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\"",
            "jiffies_till_next_fqs"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\"",
            "jiffies_till_first_fqs"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\"",
            "qlowmark"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\"",
            "qhimark"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\"",
            "blimit"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU priority boosting: priority %d delay %d ms.\\n\"",
            "kthread_prio",
            "CONFIG_RCU_BOOST_DELAY"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\"",
            "NR_CPUS",
            "nr_cpu_ids"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBoot-time adjustment of leaf fanout to %d.\\n\"",
            "rcu_fanout_leaf"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tBuild-time adjustment of leaf fanout to %d.\\n\"",
            "RCU_FANOUT_LEAF"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tFour(or more)-level hierarchy is enabled.\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU lockdep checking is enabled.\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PROVE_RCU"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_FAST_NO_HZ"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tHierarchical RCU autobalancing is disabled.\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\"",
            "RCU_FANOUT"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_64BIT"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_64BIT"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tRCU event tracing is enabled.\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_TRACE"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_bootup_announce_oddness(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TRACE))\n\t\tpr_info(\"\\tRCU event tracing is enabled.\\n\");\n\tif ((IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 64) ||\n\t    (!IS_ENABLED(CONFIG_64BIT) && RCU_FANOUT != 32))\n\t\tpr_info(\"\\tCONFIG_RCU_FANOUT set to non-default value of %d.\\n\",\n\t\t\tRCU_FANOUT);\n\tif (rcu_fanout_exact)\n\t\tpr_info(\"\\tHierarchical RCU autobalancing is disabled.\\n\");\n\tif (IS_ENABLED(CONFIG_RCU_FAST_NO_HZ))\n\t\tpr_info(\"\\tRCU dyntick-idle grace-period acceleration is enabled.\\n\");\n\tif (IS_ENABLED(CONFIG_PROVE_RCU))\n\t\tpr_info(\"\\tRCU lockdep checking is enabled.\\n\");\n\tif (RCU_NUM_LVLS >= 4)\n\t\tpr_info(\"\\tFour(or more)-level hierarchy is enabled.\\n\");\n\tif (RCU_FANOUT_LEAF != 16)\n\t\tpr_info(\"\\tBuild-time adjustment of leaf fanout to %d.\\n\",\n\t\t\tRCU_FANOUT_LEAF);\n\tif (rcu_fanout_leaf != RCU_FANOUT_LEAF)\n\t\tpr_info(\"\\tBoot-time adjustment of leaf fanout to %d.\\n\",\n\t\t\trcu_fanout_leaf);\n\tif (nr_cpu_ids != NR_CPUS)\n\t\tpr_info(\"\\tRCU restricting CPUs from NR_CPUS=%d to nr_cpu_ids=%u.\\n\", NR_CPUS, nr_cpu_ids);\n#ifdef CONFIG_RCU_BOOST\n\tpr_info(\"\\tRCU priority boosting: priority %d delay %d ms.\\n\",\n\t\tkthread_prio, CONFIG_RCU_BOOST_DELAY);\n#endif\n\tif (blimit != DEFAULT_RCU_BLIMIT)\n\t\tpr_info(\"\\tBoot-time adjustment of callback invocation limit to %ld.\\n\", blimit);\n\tif (qhimark != DEFAULT_RCU_QHIMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback high-water mark to %ld.\\n\", qhimark);\n\tif (qlowmark != DEFAULT_RCU_QLOMARK)\n\t\tpr_info(\"\\tBoot-time adjustment of callback low-water mark to %ld.\\n\", qlowmark);\n\tif (jiffies_till_first_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of first FQS scan delay to %ld jiffies.\\n\", jiffies_till_first_fqs);\n\tif (jiffies_till_next_fqs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of subsequent FQS scan delay to %ld jiffies.\\n\", jiffies_till_next_fqs);\n\tif (jiffies_till_sched_qs != ULONG_MAX)\n\t\tpr_info(\"\\tBoot-time adjustment of scheduler-enlistment delay to %ld jiffies.\\n\", jiffies_till_sched_qs);\n\tif (rcu_kick_kthreads)\n\t\tpr_info(\"\\tKick kthreads if too-long grace period.\\n\");\n\tif (IS_ENABLED(CONFIG_DEBUG_OBJECTS_RCU_HEAD))\n\t\tpr_info(\"\\tRCU callback double-/use-after-free debug enabled.\\n\");\n\tif (gp_preinit_delay)\n\t\tpr_info(\"\\tRCU debug GP pre-init slowdown %d jiffies.\\n\", gp_preinit_delay);\n\tif (gp_init_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_init_delay);\n\tif (gp_cleanup_delay)\n\t\tpr_info(\"\\tRCU debug GP init slowdown %d jiffies.\\n\", gp_cleanup_delay);\n\tif (IS_ENABLED(CONFIG_RCU_EQS_DEBUG))\n\t\tpr_info(\"\\tRCU debug extended QS entry/exit.\\n\");\n\trcupdate_announce_bootup_oddness();\n}"
  }
]