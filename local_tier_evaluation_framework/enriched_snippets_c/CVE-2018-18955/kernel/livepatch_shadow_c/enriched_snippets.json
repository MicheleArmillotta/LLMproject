[
  {
    "function_name": "klp_shadow_free_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "295-310",
    "snippet": "void klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete all <*, id> from hash */\n\thash_for_each(klp_shadow_hash, i, shadow, node) {\n\t\tif (klp_shadow_match(shadow, shadow->obj, id))\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
      "static DEFINE_SPINLOCK(klp_shadow_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_free_struct",
          "args": [
            "shadow",
            "dtor"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_free_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "246-253",
          "snippet": "static void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_match",
          "args": [
            "shadow",
            "shadow->obj",
            "id"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "82-86",
          "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "klp_shadow_hash",
            "i",
            "shadow",
            "node"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nvoid klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete all <*, id> from hash */\n\thash_for_each(klp_shadow_hash, i, shadow, node) {\n\t\tif (klp_shadow_match(shadow, shadow->obj, id))\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}"
  },
  {
    "function_name": "klp_shadow_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "265-283",
    "snippet": "void klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete <obj, id> from hash */\n\thash_for_each_possible(klp_shadow_hash, shadow, node,\n\t\t\t       (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
      "static DEFINE_SPINLOCK(klp_shadow_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_free_struct",
          "args": [
            "shadow",
            "dtor"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_free_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "246-253",
          "snippet": "static void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_match",
          "args": [
            "shadow",
            "obj",
            "id"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "82-86",
          "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "klp_shadow_hash",
            "shadow",
            "node",
            "(unsigned long)obj"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nvoid klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete <obj, id> from hash */\n\thash_for_each_possible(klp_shadow_hash, shadow, node,\n\t\t\t       (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}"
  },
  {
    "function_name": "klp_shadow_free_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "246-253",
    "snippet": "static void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "shadow",
            "rcu_head"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtor",
          "args": [
            "shadow->obj",
            "shadow->data"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del_rcu",
          "args": [
            "&shadow->node"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}"
  },
  {
    "function_name": "klp_shadow_get_or_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "237-243",
    "snippet": "void *klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t      size_t size, gfp_t gfp_flags,\n\t\t\t      klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, false);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_shadow_get_or_alloc",
          "args": [
            "obj",
            "id",
            "size",
            "gfp_flags",
            "ctor",
            "ctor_data",
            "false"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_shadow_get_or_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "116-182",
          "snippet": "static void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
            "static DEFINE_SPINLOCK(klp_shadow_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nvoid *klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t      size_t size, gfp_t gfp_flags,\n\t\t\t      klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, false);\n}"
  },
  {
    "function_name": "klp_shadow_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "208-214",
    "snippet": "void *klp_shadow_alloc(void *obj, unsigned long id,\n\t\t       size_t size, gfp_t gfp_flags,\n\t\t       klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, true);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_shadow_get_or_alloc",
          "args": [
            "obj",
            "id",
            "size",
            "gfp_flags",
            "ctor",
            "ctor_data",
            "true"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_shadow_get_or_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "116-182",
          "snippet": "static void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
            "static DEFINE_SPINLOCK(klp_shadow_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nvoid *klp_shadow_alloc(void *obj, unsigned long id,\n\t\t       size_t size, gfp_t gfp_flags,\n\t\t       klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, true);\n}"
  },
  {
    "function_name": "__klp_shadow_get_or_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "116-182",
    "snippet": "static void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
      "static DEFINE_SPINLOCK(klp_shadow_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Duplicate shadow variable <%p, %lx>\\n\"",
            "obj",
            "id"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add_rcu",
          "args": [
            "klp_shadow_hash",
            "&new_shadow->node",
            "(unsigned long)new_shadow->obj"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to construct shadow variable <%p, %lx> (%d)\\n\"",
            "obj",
            "id",
            "err"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_shadow"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctor",
          "args": [
            "obj",
            "new_shadow->data",
            "ctor_data"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "irq_calc_affinity_vectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "257-270",
          "snippet": "int irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd)\n{\n\tint resv = affd->pre_vectors + affd->post_vectors;\n\tint vecs = maxvec - resv;\n\tint ret;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tget_online_cpus();\n\tret = min_t(int, cpumask_weight(cpu_possible_mask), vecs) + resv;\n\tput_online_cpus();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd)\n{\n\tint resv = affd->pre_vectors + affd->post_vectors;\n\tint vecs = maxvec - resv;\n\tint ret;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tget_online_cpus();\n\tret = min_t(int, cpumask_weight(cpu_possible_mask), vecs) + resv;\n\tput_online_cpus();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "shadow_data"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_shadow_get",
          "args": [
            "obj",
            "id"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "95-113",
          "snippet": "void *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(klp_shadow_hash, 12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\n\nvoid *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + sizeof(*new_shadow)",
            "gfp_flags"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}"
  },
  {
    "function_name": "klp_shadow_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "95-113",
    "snippet": "void *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_match",
          "args": [
            "shadow",
            "obj",
            "id"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
          "lines": "82-86",
          "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible_rcu",
          "args": [
            "klp_shadow_hash",
            "shadow",
            "node",
            "(unsigned long)obj"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\n\nvoid *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "klp_shadow_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/shadow.c",
    "lines": "82-86",
    "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
  }
]