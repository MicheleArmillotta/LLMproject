[
  {
    "function_name": "thread_cpu_timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1416-1420",
    "snippet": "static int thread_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = THREAD_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_timer_create",
          "args": [
            "timer"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "323-363",
          "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int thread_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = THREAD_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}"
  },
  {
    "function_name": "thread_cpu_clock_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1411-1415",
    "snippet": "static int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_get",
          "args": [
            "THREAD_CLOCK",
            "tp"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "291-316",
          "snippet": "static int posix_cpu_clock_get(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint err = -EINVAL;\n\n\tif (pid == 0) {\n\t\t/*\n\t\t * Special case constant value for our own clocks.\n\t\t * We don't have to do any lookup to find ourselves.\n\t\t */\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t/*\n\t\t * Find the given PID, and validate that the caller\n\t\t * should be able to see it.\n\t\t */\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int posix_cpu_clock_get(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint err = -EINVAL;\n\n\tif (pid == 0) {\n\t\t/*\n\t\t * Special case constant value for our own clocks.\n\t\t * We don't have to do any lookup to find ourselves.\n\t\t */\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t/*\n\t\t * Find the given PID, and validate that the caller\n\t\t * should be able to see it.\n\t\t */\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}"
  },
  {
    "function_name": "thread_cpu_clock_getres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1406-1410",
    "snippet": "static int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(THREAD_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_getres",
          "args": [
            "THREAD_CLOCK",
            "tp"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_getres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "125-142",
          "snippet": "static int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(THREAD_CLOCK, tp);\n}"
  },
  {
    "function_name": "process_cpu_nsleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1401-1405",
    "snippet": "static int process_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *rqtp)\n{\n\treturn posix_cpu_nsleep(PROCESS_CLOCK, flags, rqtp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_nsleep",
          "args": [
            "PROCESS_CLOCK",
            "flags",
            "rqtp"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_nsleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1346-1371",
          "snippet": "static int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->fn = posix_cpu_nsleep_restart;\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->fn = posix_cpu_nsleep_restart;\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int process_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *rqtp)\n{\n\treturn posix_cpu_nsleep(PROCESS_CLOCK, flags, rqtp);\n}"
  },
  {
    "function_name": "process_cpu_timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1396-1400",
    "snippet": "static int process_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = PROCESS_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_timer_create",
          "args": [
            "timer"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "323-363",
          "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int process_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = PROCESS_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}"
  },
  {
    "function_name": "process_cpu_clock_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1391-1395",
    "snippet": "static int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_get",
          "args": [
            "PROCESS_CLOCK",
            "tp"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "291-316",
          "snippet": "static int posix_cpu_clock_get(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint err = -EINVAL;\n\n\tif (pid == 0) {\n\t\t/*\n\t\t * Special case constant value for our own clocks.\n\t\t * We don't have to do any lookup to find ourselves.\n\t\t */\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t/*\n\t\t * Find the given PID, and validate that the caller\n\t\t * should be able to see it.\n\t\t */\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int posix_cpu_clock_get(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint err = -EINVAL;\n\n\tif (pid == 0) {\n\t\t/*\n\t\t * Special case constant value for our own clocks.\n\t\t * We don't have to do any lookup to find ourselves.\n\t\t */\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t/*\n\t\t * Find the given PID, and validate that the caller\n\t\t * should be able to see it.\n\t\t */\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}"
  },
  {
    "function_name": "process_cpu_clock_getres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1386-1390",
    "snippet": "static int process_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(PROCESS_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_getres",
          "args": [
            "PROCESS_CLOCK",
            "tp"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_getres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "125-142",
          "snippet": "static int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int process_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(PROCESS_CLOCK, tp);\n}"
  },
  {
    "function_name": "posix_cpu_nsleep_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1373-1381",
    "snippet": "static long posix_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\tclockid_t which_clock = restart_block->nanosleep.clockid;\n\tstruct timespec64 t;\n\n\tt = ns_to_timespec64(restart_block->nanosleep.expires);\n\n\treturn do_cpu_nanosleep(which_clock, TIMER_ABSTIME, &t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cpu_nanosleep",
          "args": [
            "which_clock",
            "TIMER_ABSTIME",
            "&t"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_nanosleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1249-1342",
          "snippet": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = timer.it.cpu.expires;\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = timer.it.cpu.expires;\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "restart_block->nanosleep.expires"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "522-538",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\tclockid_t which_clock = restart_block->nanosleep.clockid;\n\tstruct timespec64 t;\n\n\tt = ns_to_timespec64(restart_block->nanosleep.expires);\n\n\treturn do_cpu_nanosleep(which_clock, TIMER_ABSTIME, &t);\n}"
  },
  {
    "function_name": "posix_cpu_nsleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1346-1371",
    "snippet": "static int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->fn = posix_cpu_nsleep_restart;\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cpu_nanosleep",
          "args": [
            "which_clock",
            "flags",
            "rqtp"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_nanosleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1249-1342",
          "snippet": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = timer.it.cpu.expires;\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = timer.it.cpu.expires;\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "which_clock"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "which_clock"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "which_clock"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->fn = posix_cpu_nsleep_restart;\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "do_cpu_nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1249-1342",
    "snippet": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = timer.it.cpu.expires;\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nanosleep_copyout",
          "args": [
            "restart",
            "&it.it_value"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "nanosleep_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1658-1675",
          "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&timer.it_lock"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timer_del",
          "args": [
            "&timer"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "371-404",
          "snippet": "static int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * We raced with the reaping of the task.\n\t\t * The deletion should have cleared us off the list.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&timer->it.cpu.entry));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tlist_del(&timer->it.cpu.entry);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tif (!ret)\n\t\tput_task_struct(p);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * We raced with the reaping of the task.\n\t\t * The deletion should have cleared us off the list.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&timer->it.cpu.entry));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tlist_del(&timer->it.cpu.entry);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tif (!ret)\n\t\tput_task_struct(p);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&timer.it_lock"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timer_set",
          "args": [
            "&timer",
            "0",
            "&zero_it",
            "&it"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "574-714",
          "snippet": "static int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 old_expires, new_expires, old_incr, val;\n\tint ret;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\n\tret = 0;\n\told_incr = timer->it.cpu.incr;\n\told_expires = timer->it.cpu.expires;\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else\n\t\tlist_del_init(&timer->it.cpu.entry);\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &val);\n\t} else {\n\t\tcpu_timer_sample_group(timer->it_clock, p, &val);\n\t}\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has\n\t\t\t * overrun already.  If it has,\n\t\t\t * we'll report it as having overrun\n\t\t\t * and with the next reloaded timer\n\t\t\t * already ticking, though we are\n\t\t\t * swallowing that pending\n\t\t\t * notification here to install the\n\t\t\t * new setting.\n\t\t\t */\n\t\t\tbump_cpu_timer(timer, val);\n\t\t\tif (val < timer->it.cpu.expires) {\n\t\t\t\told_expires = timer->it.cpu.expires - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\ttimer->it.cpu.expires = new_expires;\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it.cpu.incr = timespec64_to_ns(&new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (new_expires != 0 && !(val < new_expires)) {\n\t\t/*\n\t\t * The designated time already passed, so we notify\n\t\t * immediately, even if the thread never runs to\n\t\t * accumulate more time on this clock.\n\t\t */\n\t\tcpu_timer_fire(timer);\n\t}\n\n\tret = 0;\n out:\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 old_expires, new_expires, old_incr, val;\n\tint ret;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\n\tret = 0;\n\told_incr = timer->it.cpu.incr;\n\told_expires = timer->it.cpu.expires;\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else\n\t\tlist_del_init(&timer->it.cpu.entry);\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &val);\n\t} else {\n\t\tcpu_timer_sample_group(timer->it_clock, p, &val);\n\t}\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has\n\t\t\t * overrun already.  If it has,\n\t\t\t * we'll report it as having overrun\n\t\t\t * and with the next reloaded timer\n\t\t\t * already ticking, though we are\n\t\t\t * swallowing that pending\n\t\t\t * notification here to install the\n\t\t\t * new setting.\n\t\t\t */\n\t\t\tbump_cpu_timer(timer, val);\n\t\t\tif (val < timer->it.cpu.expires) {\n\t\t\t\told_expires = timer->it.cpu.expires - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\ttimer->it.cpu.expires = new_expires;\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it.cpu.incr = timespec64_to_ns(&new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (new_expires != 0 && !(val < new_expires)) {\n\t\t/*\n\t\t * The designated time already passed, so we notify\n\t\t * immediately, even if the thread never runs to\n\t\t * accumulate more time on this clock.\n\t\t */\n\t\tcpu_timer_fire(timer);\n\t}\n\n\tret = 0;\n out:\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&it",
            "0",
            "sizeof(it)"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_cpu_timer_create",
          "args": [
            "&timer"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "323-363",
          "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&timer.it_lock"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&timer",
            "0",
            "sizeof timer"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = timer.it.cpu.expires;\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "set_process_cpu_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1202-1247",
    "snippet": "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now;\n\tint ret;\n\n\tWARN_ON_ONCE(clock_idx == CPUCLOCK_SCHED);\n\tret = cpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval && ret != -EINVAL) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\treturn;\n\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if we are the earliest timer, or eventually\n\t * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.\n\t */\n\tswitch (clock_idx) {\n\tcase CPUCLOCK_PROF:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\n\n\ttick_dep_set_signal(tsk->signal, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_set_signal",
          "args": [
            "tsk->signal",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expires_gt",
          "args": [
            "tsk->signal->cputime_expires.virt_exp",
            "*newval"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "expires_gt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "441-444",
          "snippet": "static inline int expires_gt(u64 expires, u64 new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int expires_gt(u64 expires, u64 new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_sample_group",
          "args": [
            "clock_idx",
            "tsk",
            "&now"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "546-566",
          "snippet": "static int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "clock_idx == CPUCLOCK_SCHED"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now;\n\tint ret;\n\n\tWARN_ON_ONCE(clock_idx == CPUCLOCK_SCHED);\n\tret = cpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval && ret != -EINVAL) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\treturn;\n\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if we are the earliest timer, or eventually\n\t * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.\n\t */\n\tswitch (clock_idx) {\n\tcase CPUCLOCK_PROF:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\n\n\ttick_dep_set_signal(tsk->signal, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "run_posix_cpu_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1138-1196",
    "snippet": "void run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tLIST_HEAD(firing);\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * The fast path checks that there are no expired thread or thread\n\t * group timers.  If that's so, just return.\n\t */\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\t/*\n\t * Here we take off tsk->signal->cpu_timers[N] and\n\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t * put them on the firing list.\n\t */\n\tcheck_thread_timers(tsk, &firing);\n\n\tcheck_process_timers(tsk, &firing);\n\n\t/*\n\t * We must release these locks before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint cpu_firing;\n\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&timer->it_lock"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_fire",
          "args": [
            "timer"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_fire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "509-539",
          "snippet": "static void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cpu_firing >= 0"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&timer->it.cpu.entry"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&timer->it_lock"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "timer",
            "next",
            "&firing",
            "it.cpu.entry"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "tsk",
            "&flags"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_process_timers",
          "args": [
            "tsk",
            "&firing"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "check_process_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "910-998",
          "snippet": "static void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tu64 utime, ptime, virt_expires, prof_expires;\n\tu64 sum_sched_runtime, sched_expires;\n\tstruct list_head *timers = sig->cpu_timers;\n\tstruct task_cputime cputime;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputimer is not running, then there are no active\n\t * process wide timers (POSIX 1.b, itimers, RLIMIT_CPU).\n\t */\n\tif (!READ_ONCE(tsk->signal->cputimer.running))\n\t\treturn;\n\n        /*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tsig->cputimer.checking_timer = true;\n\n\t/*\n\t * Collect the current process totals.\n\t */\n\tthread_group_cputimer(tsk, &cputime);\n\tutime = cputime.utime;\n\tptime = utime + cputime.stime;\n\tsum_sched_runtime = cputime.sum_exec_runtime;\n\n\tprof_expires = check_timers_list(timers, firing, ptime);\n\tvirt_expires = check_timers_list(++timers, firing, utime);\n\tsched_expires = check_timers_list(++timers, firing, sum_sched_runtime);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF], &prof_expires, ptime,\n\t\t\t SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT], &virt_expires, utime,\n\t\t\t SIGVTALRM);\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long psecs = div_u64(ptime, NSEC_PER_SEC);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 x;\n\t\tif (psecs >= hard) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (psecs >= soft) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft++;\n\t\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft;\n\t\t\t}\n\t\t}\n\t\tx = soft * NSEC_PER_SEC;\n\t\tif (!prof_expires || x < prof_expires)\n\t\t\tprof_expires = x;\n\t}\n\n\tsig->cputime_expires.prof_exp = prof_expires;\n\tsig->cputime_expires.virt_exp = virt_expires;\n\tsig->cputime_expires.sched_exp = sched_expires;\n\tif (task_cputime_zero(&sig->cputime_expires))\n\t\tstop_process_timers(sig);\n\n\tsig->cputimer.checking_timer = false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tu64 utime, ptime, virt_expires, prof_expires;\n\tu64 sum_sched_runtime, sched_expires;\n\tstruct list_head *timers = sig->cpu_timers;\n\tstruct task_cputime cputime;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputimer is not running, then there are no active\n\t * process wide timers (POSIX 1.b, itimers, RLIMIT_CPU).\n\t */\n\tif (!READ_ONCE(tsk->signal->cputimer.running))\n\t\treturn;\n\n        /*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tsig->cputimer.checking_timer = true;\n\n\t/*\n\t * Collect the current process totals.\n\t */\n\tthread_group_cputimer(tsk, &cputime);\n\tutime = cputime.utime;\n\tptime = utime + cputime.stime;\n\tsum_sched_runtime = cputime.sum_exec_runtime;\n\n\tprof_expires = check_timers_list(timers, firing, ptime);\n\tvirt_expires = check_timers_list(++timers, firing, utime);\n\tsched_expires = check_timers_list(++timers, firing, sum_sched_runtime);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF], &prof_expires, ptime,\n\t\t\t SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT], &virt_expires, utime,\n\t\t\t SIGVTALRM);\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long psecs = div_u64(ptime, NSEC_PER_SEC);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 x;\n\t\tif (psecs >= hard) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (psecs >= soft) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft++;\n\t\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft;\n\t\t\t}\n\t\t}\n\t\tx = soft * NSEC_PER_SEC;\n\t\tif (!prof_expires || x < prof_expires)\n\t\t\tprof_expires = x;\n\t}\n\n\tsig->cputime_expires.prof_exp = prof_expires;\n\tsig->cputime_expires.virt_exp = virt_expires;\n\tsig->cputime_expires.sched_exp = sched_expires;\n\tif (task_cputime_zero(&sig->cputime_expires))\n\t\tstop_process_timers(sig);\n\n\tsig->cputimer.checking_timer = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_thread_timers",
          "args": [
            "tsk",
            "&firing"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "check_thread_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "807-872",
          "snippet": "static void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct list_head *timers = tsk->cpu_timers;\n\tstruct task_cputime *tsk_expires = &tsk->cputime_expires;\n\tu64 expires;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputime_expires is zero, then there are no active\n\t * per thread CPU timers.\n\t */\n\tif (task_cputime_zero(&tsk->cputime_expires))\n\t\treturn;\n\n\texpires = check_timers_list(timers, firing, prof_ticks(tsk));\n\ttsk_expires->prof_exp = expires;\n\n\texpires = check_timers_list(++timers, firing, virt_ticks(tsk));\n\ttsk_expires->virt_exp = expires;\n\n\ttsk_expires->sched_exp = check_timers_list(++timers, firing,\n\t\t\t\t\t\t   tsk->se.sum_exec_runtime);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    tsk->rt.timeout > DIV_ROUND_UP(hard, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (tsk->rt.timeout > DIV_ROUND_UP(soft, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft += USEC_PER_SEC;\n\t\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur =\n\t\t\t\t\tsoft;\n\t\t\t}\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t}\n\t}\n\tif (task_cputime_zero(tsk_expires))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct list_head *timers = tsk->cpu_timers;\n\tstruct task_cputime *tsk_expires = &tsk->cputime_expires;\n\tu64 expires;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputime_expires is zero, then there are no active\n\t * per thread CPU timers.\n\t */\n\tif (task_cputime_zero(&tsk->cputime_expires))\n\t\treturn;\n\n\texpires = check_timers_list(timers, firing, prof_ticks(tsk));\n\ttsk_expires->prof_exp = expires;\n\n\texpires = check_timers_list(++timers, firing, virt_ticks(tsk));\n\ttsk_expires->virt_exp = expires;\n\n\ttsk_expires->sched_exp = check_timers_list(++timers, firing,\n\t\t\t\t\t\t   tsk->se.sum_exec_runtime);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    tsk->rt.timeout > DIV_ROUND_UP(hard, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (tsk->rt.timeout > DIV_ROUND_UP(soft, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft += USEC_PER_SEC;\n\t\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur =\n\t\t\t\t\tsoft;\n\t\t\t}\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t}\n\t}\n\tif (task_cputime_zero(tsk_expires))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "tsk",
            "&flags"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fastpath_timer_check",
          "args": [
            "tsk"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "fastpath_timer_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1089-1131",
          "snippet": "static inline int fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (!task_cputime_zero(&tsk->cputime_expires)) {\n\t\tstruct task_cputime task_sample;\n\n\t\ttask_cputime(tsk, &task_sample.utime, &task_sample.stime);\n\t\ttask_sample.sum_exec_runtime = tsk->se.sum_exec_runtime;\n\t\tif (task_cputime_expired(&task_sample, &tsk->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tsig = tsk->signal;\n\t/*\n\t * Check if thread group timers expired when the cputimer is\n\t * running and no other thread in the group is already checking\n\t * for thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to\n\t * be a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to check/handle timers.\n\t *\n\t * In the worst case scenario, if 'running' or 'checking_timer' gets\n\t * set but the current thread doesn't see the change yet, we'll wait\n\t * until the next thread in the group gets a scheduler interrupt to\n\t * handle the timer. This isn't an issue in practice because these\n\t * types of delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(sig->cputimer.running) &&\n\t    !READ_ONCE(sig->cputimer.checking_timer)) {\n\t\tstruct task_cputime group_sample;\n\n\t\tsample_cputime_atomic(&group_sample, &sig->cputimer.cputime_atomic);\n\n\t\tif (task_cputime_expired(&group_sample, &sig->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline int fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (!task_cputime_zero(&tsk->cputime_expires)) {\n\t\tstruct task_cputime task_sample;\n\n\t\ttask_cputime(tsk, &task_sample.utime, &task_sample.stime);\n\t\ttask_sample.sum_exec_runtime = tsk->se.sum_exec_runtime;\n\t\tif (task_cputime_expired(&task_sample, &tsk->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tsig = tsk->signal;\n\t/*\n\t * Check if thread group timers expired when the cputimer is\n\t * running and no other thread in the group is already checking\n\t * for thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to\n\t * be a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to check/handle timers.\n\t *\n\t * In the worst case scenario, if 'running' or 'checking_timer' gets\n\t * set but the current thread doesn't see the change yet, we'll wait\n\t * until the next thread in the group gets a scheduler interrupt to\n\t * handle the timer. This isn't an issue in practice because these\n\t * types of delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(sig->cputimer.running) &&\n\t    !READ_ONCE(sig->cputimer.checking_timer)) {\n\t\tstruct task_cputime group_sample;\n\n\t\tsample_cputime_atomic(&group_sample, &sig->cputimer.cputime_atomic);\n\n\t\tif (task_cputime_expired(&group_sample, &sig->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "firing"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tLIST_HEAD(firing);\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * The fast path checks that there are no expired thread or thread\n\t * group timers.  If that's so, just return.\n\t */\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\t/*\n\t * Here we take off tsk->signal->cpu_timers[N] and\n\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t * put them on the firing list.\n\t */\n\tcheck_thread_timers(tsk, &firing);\n\n\tcheck_process_timers(tsk, &firing);\n\n\t/*\n\t * We must release these locks before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint cpu_firing;\n\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}"
  },
  {
    "function_name": "fastpath_timer_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1089-1131",
    "snippet": "static inline int fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (!task_cputime_zero(&tsk->cputime_expires)) {\n\t\tstruct task_cputime task_sample;\n\n\t\ttask_cputime(tsk, &task_sample.utime, &task_sample.stime);\n\t\ttask_sample.sum_exec_runtime = tsk->se.sum_exec_runtime;\n\t\tif (task_cputime_expired(&task_sample, &tsk->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tsig = tsk->signal;\n\t/*\n\t * Check if thread group timers expired when the cputimer is\n\t * running and no other thread in the group is already checking\n\t * for thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to\n\t * be a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to check/handle timers.\n\t *\n\t * In the worst case scenario, if 'running' or 'checking_timer' gets\n\t * set but the current thread doesn't see the change yet, we'll wait\n\t * until the next thread in the group gets a scheduler interrupt to\n\t * handle the timer. This isn't an issue in practice because these\n\t * types of delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(sig->cputimer.running) &&\n\t    !READ_ONCE(sig->cputimer.checking_timer)) {\n\t\tstruct task_cputime group_sample;\n\n\t\tsample_cputime_atomic(&group_sample, &sig->cputimer.cputime_atomic);\n\n\t\tif (task_cputime_expired(&group_sample, &sig->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "tsk"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime_expired",
          "args": [
            "&group_sample",
            "&sig->cputime_expires"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1066-1077",
          "snippet": "static inline int task_cputime_expired(const struct task_cputime *sample,\n\t\t\t\t\tconst struct task_cputime *expires)\n{\n\tif (expires->utime && sample->utime >= expires->utime)\n\t\treturn 1;\n\tif (expires->stime && sample->utime + sample->stime >= expires->stime)\n\t\treturn 1;\n\tif (expires->sum_exec_runtime != 0 &&\n\t    sample->sum_exec_runtime >= expires->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int task_cputime_expired(const struct task_cputime *sample,\n\t\t\t\t\tconst struct task_cputime *expires)\n{\n\tif (expires->utime && sample->utime >= expires->utime)\n\t\treturn 1;\n\tif (expires->stime && sample->utime + sample->stime >= expires->stime)\n\t\treturn 1;\n\tif (expires->sum_exec_runtime != 0 &&\n\t    sample->sum_exec_runtime >= expires->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sample_cputime_atomic",
          "args": [
            "&group_sample",
            "&sig->cputimer.cputime_atomic"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "sample_cputime_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "204-210",
          "snippet": "static inline void sample_cputime_atomic(struct task_cputime *times,\n\t\t\t\t\t struct task_cputime_atomic *atomic_times)\n{\n\ttimes->utime = atomic64_read(&atomic_times->utime);\n\ttimes->stime = atomic64_read(&atomic_times->stime);\n\ttimes->sum_exec_runtime = atomic64_read(&atomic_times->sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void sample_cputime_atomic(struct task_cputime *times,\n\t\t\t\t\t struct task_cputime_atomic *atomic_times)\n{\n\ttimes->utime = atomic64_read(&atomic_times->utime);\n\ttimes->stime = atomic64_read(&atomic_times->stime);\n\ttimes->sum_exec_runtime = atomic64_read(&atomic_times->sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sig->cputimer.checking_timer"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sig->cputimer.running"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&task_sample.utime",
            "&task_sample.stime"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime_zero",
          "args": [
            "&tsk->cputime_expires"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "101-106",
          "snippet": "static inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline int fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (!task_cputime_zero(&tsk->cputime_expires)) {\n\t\tstruct task_cputime task_sample;\n\n\t\ttask_cputime(tsk, &task_sample.utime, &task_sample.stime);\n\t\ttask_sample.sum_exec_runtime = tsk->se.sum_exec_runtime;\n\t\tif (task_cputime_expired(&task_sample, &tsk->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tsig = tsk->signal;\n\t/*\n\t * Check if thread group timers expired when the cputimer is\n\t * running and no other thread in the group is already checking\n\t * for thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to\n\t * be a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to check/handle timers.\n\t *\n\t * In the worst case scenario, if 'running' or 'checking_timer' gets\n\t * set but the current thread doesn't see the change yet, we'll wait\n\t * until the next thread in the group gets a scheduler interrupt to\n\t * handle the timer. This isn't an issue in practice because these\n\t * types of delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(sig->cputimer.running) &&\n\t    !READ_ONCE(sig->cputimer.checking_timer)) {\n\t\tstruct task_cputime group_sample;\n\n\t\tsample_cputime_atomic(&group_sample, &sig->cputimer.cputime_atomic);\n\n\t\tif (task_cputime_expired(&group_sample, &sig->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "task_cputime_expired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1066-1077",
    "snippet": "static inline int task_cputime_expired(const struct task_cputime *sample,\n\t\t\t\t\tconst struct task_cputime *expires)\n{\n\tif (expires->utime && sample->utime >= expires->utime)\n\t\treturn 1;\n\tif (expires->stime && sample->utime + sample->stime >= expires->stime)\n\t\treturn 1;\n\tif (expires->sum_exec_runtime != 0 &&\n\t    sample->sum_exec_runtime >= expires->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int task_cputime_expired(const struct task_cputime *sample,\n\t\t\t\t\tconst struct task_cputime *expires)\n{\n\tif (expires->utime && sample->utime >= expires->utime)\n\t\treturn 1;\n\tif (expires->stime && sample->utime + sample->stime >= expires->stime)\n\t\treturn 1;\n\tif (expires->sum_exec_runtime != 0 &&\n\t    sample->sum_exec_runtime >= expires->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_cpu_timer_rearm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1004-1054",
    "snippet": "static void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 now;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\tif (unlikely(p->exit_state))\n\t\t\treturn;\n\n\t\t/* Protect timer list r/w in arm_timer() */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Protect arm_timer() and timer sampling in case of call to\n\t\t * thread_group_cputime().\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\t/*\n\t\t\t * The process has been reaped.\n\t\t\t * We can't even collect a sample any more.\n\t\t\t */\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\treturn;\n\t\t} else if (unlikely(p->exit_state) && thread_group_empty(p)) {\n\t\t\t/* If the process is dying, no need to rearm */\n\t\t\tgoto unlock;\n\t\t}\n\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\t/* Leave the sighand locked for the call below.  */\n\t}\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer);\nunlock:\n\tunlock_task_sighand(p, &flags);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_timer",
          "args": [
            "timer"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "arm_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "450-504",
          "snippet": "static void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += CPUCLOCK_WHICH(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tu64 exp = nt->expires;\n\n\t\t/*\n\t\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t\t * need to update expiration cache. Take into account that\n\t\t * for process timers we share expiration cache with itimers\n\t\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t\t */\n\n\t\tswitch (CPUCLOCK_WHICH(timer->it_clock)) {\n\t\tcase CPUCLOCK_PROF:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, exp))\n\t\t\t\tcputime_expires->prof_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_VIRT:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, exp))\n\t\t\t\tcputime_expires->virt_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_SCHED:\n\t\t\tif (expires_gt(cputime_expires->sched_exp, exp))\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\t\telse\n\t\t\ttick_dep_set_signal(p->signal, TICK_DEP_BIT_POSIX_TIMER);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += CPUCLOCK_WHICH(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tu64 exp = nt->expires;\n\n\t\t/*\n\t\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t\t * need to update expiration cache. Take into account that\n\t\t * for process timers we share expiration cache with itimers\n\t\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t\t */\n\n\t\tswitch (CPUCLOCK_WHICH(timer->it_clock)) {\n\t\tcase CPUCLOCK_PROF:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, exp))\n\t\t\t\tcputime_expires->prof_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_VIRT:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, exp))\n\t\t\t\tcputime_expires->virt_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_SCHED:\n\t\t\tif (expires_gt(cputime_expires->sched_exp, exp))\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\t\telse\n\t\t\ttick_dep_set_signal(p->signal, TICK_DEP_BIT_POSIX_TIMER);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bump_cpu_timer",
          "args": [
            "timer",
            "now"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "bump_cpu_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "65-91",
          "snippet": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_sample_group",
          "args": [
            "timer->it_clock",
            "p",
            "&now"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "546-566",
          "snippet": "static int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->exit_state"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->exit_state"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "timer->it_clock",
            "p",
            "&now"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "244-267",
          "snippet": "static int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p == NULL"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 now;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\tif (unlikely(p->exit_state))\n\t\t\treturn;\n\n\t\t/* Protect timer list r/w in arm_timer() */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Protect arm_timer() and timer sampling in case of call to\n\t\t * thread_group_cputime().\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\t/*\n\t\t\t * The process has been reaped.\n\t\t\t * We can't even collect a sample any more.\n\t\t\t */\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\treturn;\n\t\t} else if (unlikely(p->exit_state) && thread_group_empty(p)) {\n\t\t\t/* If the process is dying, no need to rearm */\n\t\t\tgoto unlock;\n\t\t}\n\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\t/* Leave the sighand locked for the call below.  */\n\t}\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer);\nunlock:\n\tunlock_task_sighand(p, &flags);\n}"
  },
  {
    "function_name": "check_process_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "910-998",
    "snippet": "static void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tu64 utime, ptime, virt_expires, prof_expires;\n\tu64 sum_sched_runtime, sched_expires;\n\tstruct list_head *timers = sig->cpu_timers;\n\tstruct task_cputime cputime;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputimer is not running, then there are no active\n\t * process wide timers (POSIX 1.b, itimers, RLIMIT_CPU).\n\t */\n\tif (!READ_ONCE(tsk->signal->cputimer.running))\n\t\treturn;\n\n        /*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tsig->cputimer.checking_timer = true;\n\n\t/*\n\t * Collect the current process totals.\n\t */\n\tthread_group_cputimer(tsk, &cputime);\n\tutime = cputime.utime;\n\tptime = utime + cputime.stime;\n\tsum_sched_runtime = cputime.sum_exec_runtime;\n\n\tprof_expires = check_timers_list(timers, firing, ptime);\n\tvirt_expires = check_timers_list(++timers, firing, utime);\n\tsched_expires = check_timers_list(++timers, firing, sum_sched_runtime);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF], &prof_expires, ptime,\n\t\t\t SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT], &virt_expires, utime,\n\t\t\t SIGVTALRM);\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long psecs = div_u64(ptime, NSEC_PER_SEC);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 x;\n\t\tif (psecs >= hard) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (psecs >= soft) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft++;\n\t\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft;\n\t\t\t}\n\t\t}\n\t\tx = soft * NSEC_PER_SEC;\n\t\tif (!prof_expires || x < prof_expires)\n\t\t\tprof_expires = x;\n\t}\n\n\tsig->cputime_expires.prof_exp = prof_expires;\n\tsig->cputime_expires.virt_exp = virt_expires;\n\tsig->cputime_expires.sched_exp = sched_expires;\n\tif (task_cputime_zero(&sig->cputime_expires))\n\t\tstop_process_timers(sig);\n\n\tsig->cputimer.checking_timer = false;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_process_timers",
          "args": [
            "sig"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "stop_process_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "874-881",
          "snippet": "static inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\n\t/* Turn off cputimer->running. This is done without locking. */\n\tWRITE_ONCE(cputimer->running, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\n\t/* Turn off cputimer->running. This is done without locking. */\n\tWRITE_ONCE(cputimer->running, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime_zero",
          "args": [
            "&sig->cputime_expires"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "101-106",
          "snippet": "static inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "SIGXCPU",
            "SEND_SIG_PRIV",
            "tsk"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1199-1203",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"CPU Watchdog Timeout (soft): %s[%d]\\n\"",
            "tsk->comm",
            "task_pid_nr(tsk)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"RT Watchdog Timeout (hard): %s[%d]\\n\"",
            "tsk->comm",
            "task_pid_nr(tsk)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit_max",
          "args": [
            "tsk",
            "RLIMIT_CPU"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "ptime",
            "NSEC_PER_SEC"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "tsk",
            "RLIMIT_CPU"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cpu_itimer",
          "args": [
            "tsk",
            "&sig->it[CPUCLOCK_VIRT]",
            "&virt_expires",
            "utime",
            "SIGVTALRM"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_itimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "883-903",
          "snippet": "static void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && (!*expires || it->expires < *expires))\n\t\t*expires = it->expires;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && (!*expires || it->expires < *expires))\n\t\t*expires = it->expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_timers_list",
          "args": [
            "++timers",
            "firing",
            "sum_sched_runtime"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "check_timers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "772-792",
          "snippet": "static unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputimer",
          "args": [
            "tsk",
            "&cputime"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "212-237",
          "snippet": "void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tsk->signal->cputimer.running"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_dl_overrun",
          "args": [
            "tsk"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "check_dl_overrun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "794-800",
          "snippet": "static inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "tsk"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tu64 utime, ptime, virt_expires, prof_expires;\n\tu64 sum_sched_runtime, sched_expires;\n\tstruct list_head *timers = sig->cpu_timers;\n\tstruct task_cputime cputime;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputimer is not running, then there are no active\n\t * process wide timers (POSIX 1.b, itimers, RLIMIT_CPU).\n\t */\n\tif (!READ_ONCE(tsk->signal->cputimer.running))\n\t\treturn;\n\n        /*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tsig->cputimer.checking_timer = true;\n\n\t/*\n\t * Collect the current process totals.\n\t */\n\tthread_group_cputimer(tsk, &cputime);\n\tutime = cputime.utime;\n\tptime = utime + cputime.stime;\n\tsum_sched_runtime = cputime.sum_exec_runtime;\n\n\tprof_expires = check_timers_list(timers, firing, ptime);\n\tvirt_expires = check_timers_list(++timers, firing, utime);\n\tsched_expires = check_timers_list(++timers, firing, sum_sched_runtime);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF], &prof_expires, ptime,\n\t\t\t SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT], &virt_expires, utime,\n\t\t\t SIGVTALRM);\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long psecs = div_u64(ptime, NSEC_PER_SEC);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 x;\n\t\tif (psecs >= hard) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (psecs >= soft) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft++;\n\t\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft;\n\t\t\t}\n\t\t}\n\t\tx = soft * NSEC_PER_SEC;\n\t\tif (!prof_expires || x < prof_expires)\n\t\t\tprof_expires = x;\n\t}\n\n\tsig->cputime_expires.prof_exp = prof_expires;\n\tsig->cputime_expires.virt_exp = virt_expires;\n\tsig->cputime_expires.sched_exp = sched_expires;\n\tif (task_cputime_zero(&sig->cputime_expires))\n\t\tstop_process_timers(sig);\n\n\tsig->cputimer.checking_timer = false;\n}"
  },
  {
    "function_name": "check_cpu_itimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "883-903",
    "snippet": "static void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && (!*expires || it->expires < *expires))\n\t\t*expires = it->expires;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "signo",
            "SEND_SIG_PRIV",
            "tsk"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1199-1203",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_expire",
          "args": [
            "signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL",
            "task_tgid(tsk)",
            "cur_time"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "tsk"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && (!*expires || it->expires < *expires))\n\t\t*expires = it->expires;\n}"
  },
  {
    "function_name": "stop_process_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "874-881",
    "snippet": "static inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\n\t/* Turn off cputimer->running. This is done without locking. */\n\tWRITE_ONCE(cputimer->running, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear_signal",
          "args": [
            "sig",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "cputimer->running",
            "false"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\n\t/* Turn off cputimer->running. This is done without locking. */\n\tWRITE_ONCE(cputimer->running, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "check_thread_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "807-872",
    "snippet": "static void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct list_head *timers = tsk->cpu_timers;\n\tstruct task_cputime *tsk_expires = &tsk->cputime_expires;\n\tu64 expires;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputime_expires is zero, then there are no active\n\t * per thread CPU timers.\n\t */\n\tif (task_cputime_zero(&tsk->cputime_expires))\n\t\treturn;\n\n\texpires = check_timers_list(timers, firing, prof_ticks(tsk));\n\ttsk_expires->prof_exp = expires;\n\n\texpires = check_timers_list(++timers, firing, virt_ticks(tsk));\n\ttsk_expires->virt_exp = expires;\n\n\ttsk_expires->sched_exp = check_timers_list(++timers, firing,\n\t\t\t\t\t\t   tsk->se.sum_exec_runtime);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    tsk->rt.timeout > DIV_ROUND_UP(hard, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (tsk->rt.timeout > DIV_ROUND_UP(soft, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft += USEC_PER_SEC;\n\t\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur =\n\t\t\t\t\tsoft;\n\t\t\t}\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t}\n\t}\n\tif (task_cputime_zero(tsk_expires))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear_task",
          "args": [
            "tsk",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime_zero",
          "args": [
            "tsk_expires"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "101-106",
          "snippet": "static inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "SIGXCPU",
            "SEND_SIG_PRIV",
            "tsk"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1199-1203",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"RT Watchdog Timeout (soft): %s[%d]\\n\"",
            "tsk->comm",
            "task_pid_nr(tsk)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "soft",
            "USEC_PER_SEC/HZ"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"CPU Watchdog Timeout (hard): %s[%d]\\n\"",
            "tsk->comm",
            "task_pid_nr(tsk)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "hard",
            "USEC_PER_SEC/HZ"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit_max",
          "args": [
            "tsk",
            "RLIMIT_RTTIME"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "tsk",
            "RLIMIT_RTTIME"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_timers_list",
          "args": [
            "++timers",
            "firing",
            "tsk->se.sum_exec_runtime"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "check_timers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "772-792",
          "snippet": "static unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_ticks",
          "args": [
            "tsk"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "virt_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "116-123",
          "snippet": "static inline u64 virt_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline u64 virt_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prof_ticks",
          "args": [
            "tsk"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "prof_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "108-115",
          "snippet": "static inline u64 prof_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime + stime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline u64 prof_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime + stime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_dl_overrun",
          "args": [
            "tsk"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "check_dl_overrun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "794-800",
          "snippet": "static inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "tsk"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct list_head *timers = tsk->cpu_timers;\n\tstruct task_cputime *tsk_expires = &tsk->cputime_expires;\n\tu64 expires;\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\t/*\n\t * If cputime_expires is zero, then there are no active\n\t * per thread CPU timers.\n\t */\n\tif (task_cputime_zero(&tsk->cputime_expires))\n\t\treturn;\n\n\texpires = check_timers_list(timers, firing, prof_ticks(tsk));\n\ttsk_expires->prof_exp = expires;\n\n\texpires = check_timers_list(++timers, firing, virt_ticks(tsk));\n\ttsk_expires->virt_exp = expires;\n\n\ttsk_expires->sched_exp = check_timers_list(++timers, firing,\n\t\t\t\t\t\t   tsk->se.sum_exec_runtime);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    tsk->rt.timeout > DIV_ROUND_UP(hard, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the hard limit, we just die.\n\t\t\t * No need to calculate anything else now.\n\t\t\t */\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"CPU Watchdog Timeout (hard): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (tsk->rt.timeout > DIV_ROUND_UP(soft, USEC_PER_SEC/HZ)) {\n\t\t\t/*\n\t\t\t * At the soft limit, send a SIGXCPU every second.\n\t\t\t */\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft += USEC_PER_SEC;\n\t\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur =\n\t\t\t\t\tsoft;\n\t\t\t}\n\t\t\tif (print_fatal_signals) {\n\t\t\t\tpr_info(\"RT Watchdog Timeout (soft): %s[%d]\\n\",\n\t\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t}\n\t\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t\t}\n\t}\n\tif (task_cputime_zero(tsk_expires))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "check_dl_overrun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "794-800",
    "snippet": "static inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "SIGXCPU",
            "SEND_SIG_PRIV",
            "tsk"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1199-1203",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}"
  },
  {
    "function_name": "check_timers_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "772-792",
    "snippet": "static unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&t->entry",
            "firing"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "timers",
            "structcpu_timer_list",
            "entry"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "timers"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_cpu_timer_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "716-770",
    "snippet": "static void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec64 *itp)\n{\n\tu64 now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Easy part: convert the reload time.\n\t */\n\titp->it_interval = ns_to_timespec64(timer->it.cpu.incr);\n\n\tif (!timer->it.cpu.expires)\n\t\treturn;\n\n\t/*\n\t * Sample the clock to take the difference with the expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t} else {\n\t\tstruct sighand_struct *sighand;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Protect against sighand release/switch in exit/exec and\n\t\t * also make timer sampling safe if it ends up calling\n\t\t * thread_group_cputime().\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\t/*\n\t\t\t * The process has been reaped.\n\t\t\t * We can't even collect a sample any more.\n\t\t\t * Call the timer disarmed, nothing else to do.\n\t\t\t */\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\treturn;\n\t\t} else {\n\t\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t}\n\t}\n\n\tif (now < timer->it.cpu.expires) {\n\t\titp->it_value = ns_to_timespec64(timer->it.cpu.expires - now);\n\t} else {\n\t\t/*\n\t\t * The timer should have expired already, but the firing\n\t\t * hasn't taken place yet.  Say it's just about to expire.\n\t\t */\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "timer->it.cpu.expires - now"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "522-538",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_sample_group",
          "args": [
            "timer->it_clock",
            "p",
            "&now"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "546-566",
          "snippet": "static int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "timer->it_clock",
            "p",
            "&now"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "244-267",
          "snippet": "static int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p == NULL"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec64 *itp)\n{\n\tu64 now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Easy part: convert the reload time.\n\t */\n\titp->it_interval = ns_to_timespec64(timer->it.cpu.incr);\n\n\tif (!timer->it.cpu.expires)\n\t\treturn;\n\n\t/*\n\t * Sample the clock to take the difference with the expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t} else {\n\t\tstruct sighand_struct *sighand;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Protect against sighand release/switch in exit/exec and\n\t\t * also make timer sampling safe if it ends up calling\n\t\t * thread_group_cputime().\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\t/*\n\t\t\t * The process has been reaped.\n\t\t\t * We can't even collect a sample any more.\n\t\t\t * Call the timer disarmed, nothing else to do.\n\t\t\t */\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\treturn;\n\t\t} else {\n\t\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t}\n\t}\n\n\tif (now < timer->it.cpu.expires) {\n\t\titp->it_value = ns_to_timespec64(timer->it.cpu.expires - now);\n\t} else {\n\t\t/*\n\t\t * The timer should have expired already, but the firing\n\t\t * hasn't taken place yet.  Say it's just about to expire.\n\t\t */\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}"
  },
  {
    "function_name": "posix_cpu_timer_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "574-714",
    "snippet": "static int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 old_expires, new_expires, old_incr, val;\n\tint ret;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\n\tret = 0;\n\told_incr = timer->it.cpu.incr;\n\told_expires = timer->it.cpu.expires;\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else\n\t\tlist_del_init(&timer->it.cpu.entry);\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &val);\n\t} else {\n\t\tcpu_timer_sample_group(timer->it_clock, p, &val);\n\t}\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has\n\t\t\t * overrun already.  If it has,\n\t\t\t * we'll report it as having overrun\n\t\t\t * and with the next reloaded timer\n\t\t\t * already ticking, though we are\n\t\t\t * swallowing that pending\n\t\t\t * notification here to install the\n\t\t\t * new setting.\n\t\t\t */\n\t\t\tbump_cpu_timer(timer, val);\n\t\t\tif (val < timer->it.cpu.expires) {\n\t\t\t\told_expires = timer->it.cpu.expires - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\ttimer->it.cpu.expires = new_expires;\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it.cpu.incr = timespec64_to_ns(&new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (new_expires != 0 && !(val < new_expires)) {\n\t\t/*\n\t\t * The designated time already passed, so we notify\n\t\t * immediately, even if the thread never runs to\n\t\t * accumulate more time on this clock.\n\t\t */\n\t\tcpu_timer_fire(timer);\n\t}\n\n\tret = 0;\n out:\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "old_incr"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "522-538",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_fire",
          "args": [
            "timer"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_fire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "509-539",
          "snippet": "static void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&new->it_interval"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_timer",
          "args": [
            "timer"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "arm_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "450-504",
          "snippet": "static void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += CPUCLOCK_WHICH(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tu64 exp = nt->expires;\n\n\t\t/*\n\t\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t\t * need to update expiration cache. Take into account that\n\t\t * for process timers we share expiration cache with itimers\n\t\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t\t */\n\n\t\tswitch (CPUCLOCK_WHICH(timer->it_clock)) {\n\t\tcase CPUCLOCK_PROF:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, exp))\n\t\t\t\tcputime_expires->prof_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_VIRT:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, exp))\n\t\t\t\tcputime_expires->virt_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_SCHED:\n\t\t\tif (expires_gt(cputime_expires->sched_exp, exp))\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\t\telse\n\t\t\ttick_dep_set_signal(p->signal, TICK_DEP_BIT_POSIX_TIMER);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += CPUCLOCK_WHICH(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tu64 exp = nt->expires;\n\n\t\t/*\n\t\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t\t * need to update expiration cache. Take into account that\n\t\t * for process timers we share expiration cache with itimers\n\t\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t\t */\n\n\t\tswitch (CPUCLOCK_WHICH(timer->it_clock)) {\n\t\tcase CPUCLOCK_PROF:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, exp))\n\t\t\t\tcputime_expires->prof_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_VIRT:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, exp))\n\t\t\t\tcputime_expires->virt_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_SCHED:\n\t\t\tif (expires_gt(cputime_expires->sched_exp, exp))\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\t\telse\n\t\t\ttick_dep_set_signal(p->signal, TICK_DEP_BIT_POSIX_TIMER);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bump_cpu_timer",
          "args": [
            "timer",
            "val"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "bump_cpu_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "65-91",
          "snippet": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_sample_group",
          "args": [
            "timer->it_clock",
            "p",
            "&val"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "546-566",
          "snippet": "static int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "timer->it_clock",
            "p",
            "&val"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "244-267",
          "snippet": "static int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&timer->it.cpu.entry"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timer->it.cpu.firing"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "timespec64_to_ktime(new->it_value)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new->it_value"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p == NULL"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 old_expires, new_expires, old_incr, val;\n\tint ret;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\n\tret = 0;\n\told_incr = timer->it.cpu.incr;\n\told_expires = timer->it.cpu.expires;\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else\n\t\tlist_del_init(&timer->it.cpu.entry);\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &val);\n\t} else {\n\t\tcpu_timer_sample_group(timer->it_clock, p, &val);\n\t}\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has\n\t\t\t * overrun already.  If it has,\n\t\t\t * we'll report it as having overrun\n\t\t\t * and with the next reloaded timer\n\t\t\t * already ticking, though we are\n\t\t\t * swallowing that pending\n\t\t\t * notification here to install the\n\t\t\t * new setting.\n\t\t\t */\n\t\t\tbump_cpu_timer(timer, val);\n\t\t\tif (val < timer->it.cpu.expires) {\n\t\t\t\told_expires = timer->it.cpu.expires - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\ttimer->it.cpu.expires = new_expires;\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it.cpu.incr = timespec64_to_ns(&new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (new_expires != 0 && !(val < new_expires)) {\n\t\t/*\n\t\t * The designated time already passed, so we notify\n\t\t * immediately, even if the thread never runs to\n\t\t * accumulate more time on this clock.\n\t\t */\n\t\tcpu_timer_fire(timer);\n\t}\n\n\tret = 0;\n out:\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpu_timer_sample_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "546-566",
    "snippet": "static int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "which_clock"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_cputimer",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "212-237",
          "snippet": "void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p, u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_timer_fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "509-539",
    "snippet": "static void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_timer_rearm",
          "args": [
            "timer"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_rearm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1004-1054",
          "snippet": "static void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 now;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\tif (unlikely(p->exit_state))\n\t\t\treturn;\n\n\t\t/* Protect timer list r/w in arm_timer() */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Protect arm_timer() and timer sampling in case of call to\n\t\t * thread_group_cputime().\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\t/*\n\t\t\t * The process has been reaped.\n\t\t\t * We can't even collect a sample any more.\n\t\t\t */\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\treturn;\n\t\t} else if (unlikely(p->exit_state) && thread_group_empty(p)) {\n\t\t\t/* If the process is dying, no need to rearm */\n\t\t\tgoto unlock;\n\t\t}\n\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\t/* Leave the sighand locked for the call below.  */\n\t}\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer);\nunlock:\n\tunlock_task_sighand(p, &flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tu64 now;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\tif (unlikely(p->exit_state))\n\t\t\treturn;\n\n\t\t/* Protect timer list r/w in arm_timer() */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * Protect arm_timer() and timer sampling in case of call to\n\t\t * thread_group_cputime().\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\t/*\n\t\t\t * The process has been reaped.\n\t\t\t * We can't even collect a sample any more.\n\t\t\t */\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\treturn;\n\t\t} else if (unlikely(p->exit_state) && thread_group_empty(p)) {\n\t\t\t/* If the process is dying, no need to rearm */\n\t\t\tgoto unlock;\n\t\t}\n\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\t/* Leave the sighand locked for the call below.  */\n\t}\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer);\nunlock:\n\tunlock_task_sighand(p, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_event",
          "args": [
            "timer",
            "++timer->it_requeue_pending"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "334-355",
          "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "timer->it_process"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timer->sigq == NULL"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}"
  },
  {
    "function_name": "arm_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "450-504",
    "snippet": "static void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += CPUCLOCK_WHICH(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tu64 exp = nt->expires;\n\n\t\t/*\n\t\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t\t * need to update expiration cache. Take into account that\n\t\t * for process timers we share expiration cache with itimers\n\t\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t\t */\n\n\t\tswitch (CPUCLOCK_WHICH(timer->it_clock)) {\n\t\tcase CPUCLOCK_PROF:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, exp))\n\t\t\t\tcputime_expires->prof_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_VIRT:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, exp))\n\t\t\t\tcputime_expires->virt_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_SCHED:\n\t\t\tif (expires_gt(cputime_expires->sched_exp, exp))\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\t\telse\n\t\t\ttick_dep_set_signal(p->signal, TICK_DEP_BIT_POSIX_TIMER);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_set_signal",
          "args": [
            "p->signal",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set_task",
          "args": [
            "p",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expires_gt",
          "args": [
            "cputime_expires->sched_exp",
            "exp"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "expires_gt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "441-444",
          "snippet": "static inline int expires_gt(u64 expires, u64 new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int expires_gt(u64 expires, u64 new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "timer->it_clock"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nt->entry",
            "listpos"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "next",
            "head",
            "entry"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "timer->it_clock"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += CPUCLOCK_WHICH(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tu64 exp = nt->expires;\n\n\t\t/*\n\t\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t\t * need to update expiration cache. Take into account that\n\t\t * for process timers we share expiration cache with itimers\n\t\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t\t */\n\n\t\tswitch (CPUCLOCK_WHICH(timer->it_clock)) {\n\t\tcase CPUCLOCK_PROF:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, exp))\n\t\t\t\tcputime_expires->prof_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_VIRT:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, exp))\n\t\t\t\tcputime_expires->virt_exp = exp;\n\t\t\tbreak;\n\t\tcase CPUCLOCK_SCHED:\n\t\t\tif (expires_gt(cputime_expires->sched_exp, exp))\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\t\telse\n\t\t\ttick_dep_set_signal(p->signal, TICK_DEP_BIT_POSIX_TIMER);\n\t}\n}"
  },
  {
    "function_name": "expires_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "441-444",
    "snippet": "static inline int expires_gt(u64 expires, u64 new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int expires_gt(u64 expires, u64 new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}"
  },
  {
    "function_name": "posix_cpu_timers_exit_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "436-439",
    "snippet": "void posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_timers",
          "args": [
            "tsk->signal->cpu_timers"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "420-425",
          "snippet": "static void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers);\n}"
  },
  {
    "function_name": "posix_cpu_timers_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "432-435",
    "snippet": "void posix_cpu_timers_exit(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->cpu_timers);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_timers",
          "args": [
            "tsk->cpu_timers"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "420-425",
          "snippet": "static void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid posix_cpu_timers_exit(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->cpu_timers);\n}"
  },
  {
    "function_name": "cleanup_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "420-425",
    "snippet": "static void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_timers_list",
          "args": [
            "++head"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_timers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "406-412",
          "snippet": "static void cleanup_timers_list(struct list_head *head)\n{\n\tstruct cpu_timer_list *timer, *next;\n\n\tlist_for_each_entry_safe(timer, next, head, entry)\n\t\tlist_del_init(&timer->entry);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cleanup_timers_list(struct list_head *head)\n{\n\tstruct cpu_timer_list *timer, *next;\n\n\tlist_for_each_entry_safe(timer, next, head, entry)\n\t\tlist_del_init(&timer->entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}"
  },
  {
    "function_name": "cleanup_timers_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "406-412",
    "snippet": "static void cleanup_timers_list(struct list_head *head)\n{\n\tstruct cpu_timer_list *timer, *next;\n\n\tlist_for_each_entry_safe(timer, next, head, entry)\n\t\tlist_del_init(&timer->entry);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&timer->entry"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "timer",
            "next",
            "head",
            "entry"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cleanup_timers_list(struct list_head *head)\n{\n\tstruct cpu_timer_list *timer, *next;\n\n\tlist_for_each_entry_safe(timer, next, head, entry)\n\t\tlist_del_init(&timer->entry);\n}"
  },
  {
    "function_name": "posix_cpu_timer_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "371-404",
    "snippet": "static int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * We raced with the reaping of the task.\n\t\t * The deletion should have cleared us off the list.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&timer->it.cpu.entry));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tlist_del(&timer->it.cpu.entry);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tif (!ret)\n\t\tput_task_struct(p);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&timer->it.cpu.entry"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&timer->it.cpu.entry)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&timer->it.cpu.entry"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p == NULL"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\tWARN_ON_ONCE(p == NULL);\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * We raced with the reaping of the task.\n\t\t * The deletion should have cleared us off the list.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&timer->it.cpu.entry));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tlist_del(&timer->it.cpu.entry);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tif (!ret)\n\t\tput_task_struct(p);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_cpu_timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "323-363",
    "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_group_leader_pid",
          "args": [
            "p"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "p",
            "current"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "new_timer->it_clock"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new_timer->it.cpu.entry"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "new_timer->it_clock"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "new_timer->it_clock"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n\t.timer_rearm\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_cpu_clock_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "291-316",
    "snippet": "static int posix_cpu_clock_get(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint err = -EINVAL;\n\n\tif (pid == 0) {\n\t\t/*\n\t\t * Special case constant value for our own clocks.\n\t\t * We don't have to do any lookup to find ourselves.\n\t\t */\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t/*\n\t\t * Find the given PID, and validate that the caller\n\t\t * should be able to see it.\n\t\t */\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_clock_get_task",
          "args": [
            "p",
            "which_clock",
            "tp"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_get_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "269-288",
          "snippet": "static int posix_cpu_clock_get_task(struct task_struct *tsk,\n\t\t\t\t    const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\tint err = -EINVAL;\n\tu64 rtn;\n\n\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\tif (same_thread_group(tsk, current))\n\t\t\terr = cpu_clock_sample(which_clock, tsk, &rtn);\n\t} else {\n\t\tif (tsk == current || thread_group_leader(tsk))\n\t\t\terr = cpu_clock_sample_group(which_clock, tsk, &rtn);\n\t}\n\n\tif (!err)\n\t\t*tp = ns_to_timespec64(rtn);\n\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int posix_cpu_clock_get_task(struct task_struct *tsk,\n\t\t\t\t    const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\tint err = -EINVAL;\n\tu64 rtn;\n\n\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\tif (same_thread_group(tsk, current))\n\t\t\terr = cpu_clock_sample(which_clock, tsk, &rtn);\n\t} else {\n\t\tif (tsk == current || thread_group_leader(tsk))\n\t\t\terr = cpu_clock_sample_group(which_clock, tsk, &rtn);\n\t}\n\n\tif (!err)\n\t\t*tp = ns_to_timespec64(rtn);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "which_clock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int posix_cpu_clock_get(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint err = -EINVAL;\n\n\tif (pid == 0) {\n\t\t/*\n\t\t * Special case constant value for our own clocks.\n\t\t * We don't have to do any lookup to find ourselves.\n\t\t */\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t/*\n\t\t * Find the given PID, and validate that the caller\n\t\t * should be able to see it.\n\t\t */\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "posix_cpu_clock_get_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "269-288",
    "snippet": "static int posix_cpu_clock_get_task(struct task_struct *tsk,\n\t\t\t\t    const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\tint err = -EINVAL;\n\tu64 rtn;\n\n\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\tif (same_thread_group(tsk, current))\n\t\t\terr = cpu_clock_sample(which_clock, tsk, &rtn);\n\t} else {\n\t\tif (tsk == current || thread_group_leader(tsk))\n\t\t\terr = cpu_clock_sample_group(which_clock, tsk, &rtn);\n\t}\n\n\tif (!err)\n\t\t*tp = ns_to_timespec64(rtn);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "rtn"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "522-538",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample_group",
          "args": [
            "which_clock",
            "tsk",
            "&rtn"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "244-267",
          "snippet": "static int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "tsk",
            "current"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "which_clock"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int posix_cpu_clock_get_task(struct task_struct *tsk,\n\t\t\t\t    const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\tint err = -EINVAL;\n\tu64 rtn;\n\n\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\tif (same_thread_group(tsk, current))\n\t\t\terr = cpu_clock_sample(which_clock, tsk, &rtn);\n\t} else {\n\t\tif (tsk == current || thread_group_leader(tsk))\n\t\t\terr = cpu_clock_sample_group(which_clock, tsk, &rtn);\n\t}\n\n\tif (!err)\n\t\t*tp = ns_to_timespec64(rtn);\n\n\treturn err;\n}"
  },
  {
    "function_name": "cpu_clock_sample_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "244-267",
    "snippet": "static int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "212-237",
          "snippet": "void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "which_clock"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  u64 *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime + cputime.stime;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.utime;\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "thread_group_cputimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "212-237",
    "snippet": "void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sample_cputime_atomic",
          "args": [
            "times",
            "&cputimer->cputime_atomic"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sample_cputime_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "204-210",
          "snippet": "static inline void sample_cputime_atomic(struct task_cputime *times,\n\t\t\t\t\t struct task_cputime_atomic *atomic_times)\n{\n\ttimes->utime = atomic64_read(&atomic_times->utime);\n\ttimes->stime = atomic64_read(&atomic_times->stime);\n\ttimes->sum_exec_runtime = atomic64_read(&atomic_times->sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void sample_cputime_atomic(struct task_cputime *times,\n\t\t\t\t\t struct task_cputime_atomic *atomic_times)\n{\n\ttimes->utime = atomic64_read(&atomic_times->utime);\n\ttimes->stime = atomic64_read(&atomic_times->stime);\n\ttimes->sum_exec_runtime = atomic64_read(&atomic_times->sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "cputimer->running",
            "true"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_gt_cputime",
          "args": [
            "&cputimer->cputime_atomic",
            "&sum"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "update_gt_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "196-201",
          "snippet": "static void update_gt_cputime(struct task_cputime_atomic *cputime_atomic, struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void update_gt_cputime(struct task_cputime_atomic *cputime_atomic, struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "tsk",
            "&sum"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "212-237",
          "snippet": "void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cputimer->running"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}"
  },
  {
    "function_name": "sample_cputime_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "204-210",
    "snippet": "static inline void sample_cputime_atomic(struct task_cputime *times,\n\t\t\t\t\t struct task_cputime_atomic *atomic_times)\n{\n\ttimes->utime = atomic64_read(&atomic_times->utime);\n\ttimes->stime = atomic64_read(&atomic_times->stime);\n\ttimes->sum_exec_runtime = atomic64_read(&atomic_times->sum_exec_runtime);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&atomic_times->sum_exec_runtime"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&atomic_times->stime"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&atomic_times->utime"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void sample_cputime_atomic(struct task_cputime *times,\n\t\t\t\t\t struct task_cputime_atomic *atomic_times)\n{\n\ttimes->utime = atomic64_read(&atomic_times->utime);\n\ttimes->stime = atomic64_read(&atomic_times->stime);\n\ttimes->sum_exec_runtime = atomic64_read(&atomic_times->sum_exec_runtime);\n}"
  },
  {
    "function_name": "update_gt_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "196-201",
    "snippet": "static void update_gt_cputime(struct task_cputime_atomic *cputime_atomic, struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_gt_cputime",
          "args": [
            "&cputime_atomic->sum_exec_runtime",
            "sum->sum_exec_runtime"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__update_gt_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "185-194",
          "snippet": "static inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void update_gt_cputime(struct task_cputime_atomic *cputime_atomic, struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}"
  },
  {
    "function_name": "__update_gt_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "185-194",
    "snippet": "static inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_cmpxchg",
          "args": [
            "cputime",
            "curr_cputime",
            "sum_cputime"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "cputime"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}"
  },
  {
    "function_name": "cpu_clock_sample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "162-179",
    "snippet": "static int cpu_clock_sample(const clockid_t which_clock,\n\t\t\t    struct task_struct *p, u64 *sample)\n{\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = prof_ticks(p);\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = virt_ticks(p);\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = task_sched_runtime(p);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_sched_runtime",
          "args": [
            "p"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_ticks",
          "args": [
            "p"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virt_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "116-123",
          "snippet": "static inline u64 virt_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline u64 virt_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prof_ticks",
          "args": [
            "p"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "prof_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "108-115",
          "snippet": "static inline u64 prof_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime + stime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline u64 prof_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime + stime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "which_clock"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int cpu_clock_sample(const clockid_t which_clock,\n\t\t\t    struct task_struct *p, u64 *sample)\n{\n\tswitch (CPUCLOCK_WHICH(which_clock)) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase CPUCLOCK_PROF:\n\t\t*sample = prof_ticks(p);\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\t*sample = virt_ticks(p);\n\t\tbreak;\n\tcase CPUCLOCK_SCHED:\n\t\t*sample = task_sched_runtime(p);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_cpu_clock_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "144-156",
    "snippet": "static int\nposix_cpu_clock_set(const clockid_t which_clock, const struct timespec64 *tp)\n{\n\t/*\n\t * You can never reset a CPU clock, but we check for other errors\n\t * in the call before failing with EPERM.\n\t */\n\tint error = check_clock(which_clock);\n\tif (error == 0) {\n\t\terror = -EPERM;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_clock",
          "args": [
            "which_clock"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "check_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "38-59",
          "snippet": "static int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_set(const clockid_t which_clock, const struct timespec64 *tp)\n{\n\t/*\n\t * You can never reset a CPU clock, but we check for other errors\n\t * in the call before failing with EPERM.\n\t */\n\tint error = check_clock(which_clock);\n\tif (error == 0) {\n\t\terror = -EPERM;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "posix_cpu_clock_getres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "125-142",
    "snippet": "static int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "which_clock"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_clock",
          "args": [
            "which_clock"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "check_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "38-59",
          "snippet": "static int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "virt_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "116-123",
    "snippet": "static inline u64 virt_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline u64 virt_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime;\n}"
  },
  {
    "function_name": "prof_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "108-115",
    "snippet": "static inline u64 prof_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime + stime;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline u64 prof_ticks(struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn utime + stime;\n}"
  },
  {
    "function_name": "task_cputime_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "101-106",
    "snippet": "static inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "bump_cpu_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "65-91",
    "snippet": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}"
  },
  {
    "function_name": "check_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "38-59",
    "snippet": "static int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_group_leader_pid",
          "args": [
            "p"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "p",
            "current"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "which_clock"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "which_clock"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "which_clock"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
  },
  {
    "function_name": "update_rlimit_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
    "lines": "29-36",
    "snippet": "void update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)\n{\n\tu64 nsecs = rlim_new * NSEC_PER_SEC;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tset_process_cpu_timer(task, CPUCLOCK_PROF, &nsecs, NULL);\n\tspin_unlock_irq(&task->sighand->siglock);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_process_cpu_timer",
          "args": [
            "task",
            "CPUCLOCK_PROF",
            "&nsecs",
            "NULL"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "set_process_cpu_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1202-1247",
          "snippet": "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now;\n\tint ret;\n\n\tWARN_ON_ONCE(clock_idx == CPUCLOCK_SCHED);\n\tret = cpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval && ret != -EINVAL) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\treturn;\n\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if we are the earliest timer, or eventually\n\t * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.\n\t */\n\tswitch (clock_idx) {\n\tcase CPUCLOCK_PROF:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\n\n\ttick_dep_set_signal(tsk->signal, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now;\n\tint ret;\n\n\tWARN_ON_ONCE(clock_idx == CPUCLOCK_SCHED);\n\tret = cpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval && ret != -EINVAL) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\treturn;\n\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if we are the earliest timer, or eventually\n\t * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.\n\t */\n\tswitch (clock_idx) {\n\tcase CPUCLOCK_PROF:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\n\n\ttick_dep_set_signal(tsk->signal, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)\n{\n\tu64 nsecs = rlim_new * NSEC_PER_SEC;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tset_process_cpu_timer(task, CPUCLOCK_PROF, &nsecs, NULL);\n\tspin_unlock_irq(&task->sighand->siglock);\n}"
  }
]