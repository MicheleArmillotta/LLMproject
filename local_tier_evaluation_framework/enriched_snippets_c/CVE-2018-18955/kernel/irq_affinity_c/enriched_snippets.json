[
  {
    "function_name": "irq_calc_affinity_vectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "257-270",
    "snippet": "int irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd)\n{\n\tint resv = affd->pre_vectors + affd->post_vectors;\n\tint vecs = maxvec - resv;\n\tint ret;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tget_online_cpus();\n\tret = min_t(int, cpumask_weight(cpu_possible_mask), vecs) + resv;\n\tput_online_cpus();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "cpumask_weight(cpu_possible_mask)",
            "vecs"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cpu_possible_mask"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd)\n{\n\tint resv = affd->pre_vectors + affd->post_vectors;\n\tint vecs = maxvec - resv;\n\tint ret;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tget_online_cpus();\n\tret = min_t(int, cpumask_weight(cpu_possible_mask), vecs) + resv;\n\tput_online_cpus();\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_create_affinity_masks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "176-249",
    "snippet": "struct cpumask *\nirq_create_affinity_masks(int nvecs, const struct irq_affinity *affd)\n{\n\tint affvecs = nvecs - affd->pre_vectors - affd->post_vectors;\n\tint curvec, usedvecs;\n\tcpumask_var_t nmsk, npresmsk, *node_to_cpumask;\n\tstruct cpumask *masks = NULL;\n\n\t/*\n\t * If there aren't any vectors left after applying the pre/post\n\t * vectors don't bother with assigning affinity.\n\t */\n\tif (nvecs == affd->pre_vectors + affd->post_vectors)\n\t\treturn NULL;\n\n\tif (!zalloc_cpumask_var(&nmsk, GFP_KERNEL))\n\t\treturn NULL;\n\n\tif (!zalloc_cpumask_var(&npresmsk, GFP_KERNEL))\n\t\tgoto outcpumsk;\n\n\tnode_to_cpumask = alloc_node_to_cpumask();\n\tif (!node_to_cpumask)\n\t\tgoto outnpresmsk;\n\n\tmasks = kcalloc(nvecs, sizeof(*masks), GFP_KERNEL);\n\tif (!masks)\n\t\tgoto outnodemsk;\n\n\t/* Fill out vectors at the beginning that don't need affinity */\n\tfor (curvec = 0; curvec < affd->pre_vectors; curvec++)\n\t\tcpumask_copy(masks + curvec, irq_default_affinity);\n\n\t/* Stabilize the cpumasks */\n\tget_online_cpus();\n\tbuild_node_to_cpumask(node_to_cpumask);\n\n\t/* Spread on present CPUs starting from affd->pre_vectors */\n\tusedvecs = irq_build_affinity_masks(affd, curvec, affvecs,\n\t\t\t\t\t    node_to_cpumask, cpu_present_mask,\n\t\t\t\t\t    nmsk, masks);\n\n\t/*\n\t * Spread on non present CPUs starting from the next vector to be\n\t * handled. If the spreading of present CPUs already exhausted the\n\t * vector space, assign the non present CPUs to the already spread\n\t * out vectors.\n\t */\n\tif (usedvecs >= affvecs)\n\t\tcurvec = affd->pre_vectors;\n\telse\n\t\tcurvec = affd->pre_vectors + usedvecs;\n\tcpumask_andnot(npresmsk, cpu_possible_mask, cpu_present_mask);\n\tusedvecs += irq_build_affinity_masks(affd, curvec, affvecs,\n\t\t\t\t\t     node_to_cpumask, npresmsk,\n\t\t\t\t\t     nmsk, masks);\n\tput_online_cpus();\n\n\t/* Fill out vectors at the end that don't need affinity */\n\tif (usedvecs >= affvecs)\n\t\tcurvec = affd->pre_vectors + affvecs;\n\telse\n\t\tcurvec = affd->pre_vectors + usedvecs;\n\tfor (; curvec < nvecs; curvec++)\n\t\tcpumask_copy(masks + curvec, irq_default_affinity);\n\noutnodemsk:\n\tfree_node_to_cpumask(node_to_cpumask);\noutnpresmsk:\n\tfree_cpumask_var(npresmsk);\noutcpumsk:\n\tfree_cpumask_var(nmsk);\n\treturn masks;\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "nmsk"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "npresmsk"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_node_to_cpumask",
          "args": [
            "node_to_cpumask"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "free_node_to_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "65-72",
          "snippet": "static void free_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint node;\n\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void free_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint node;\n\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "masks + curvec",
            "irq_default_affinity"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_build_affinity_masks",
          "args": [
            "affd",
            "curvec",
            "affvecs",
            "node_to_cpumask",
            "npresmsk",
            "nmsk",
            "masks"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "irq_build_affinity_masks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "97-167",
          "snippet": "static int irq_build_affinity_masks(const struct irq_affinity *affd,\n\t\t\t\t    int startvec, int numvecs,\n\t\t\t\t    cpumask_var_t *node_to_cpumask,\n\t\t\t\t    const struct cpumask *cpu_mask,\n\t\t\t\t    struct cpumask *nmsk,\n\t\t\t\t    struct cpumask *masks)\n{\n\tint n, nodes, cpus_per_vec, extra_vecs, done = 0;\n\tint last_affv = affd->pre_vectors + numvecs;\n\tint curvec = startvec;\n\tnodemask_t nodemsk = NODE_MASK_NONE;\n\n\tif (!cpumask_weight(cpu_mask))\n\t\treturn 0;\n\n\tnodes = get_nodes_in_cpumask(node_to_cpumask, cpu_mask, &nodemsk);\n\n\t/*\n\t * If the number of nodes in the mask is greater than or equal the\n\t * number of vectors we just spread the vectors across the nodes.\n\t */\n\tif (numvecs <= nodes) {\n\t\tfor_each_node_mask(n, nodemsk) {\n\t\t\tcpumask_copy(masks + curvec, node_to_cpumask[n]);\n\t\t\tif (++done == numvecs)\n\t\t\t\tbreak;\n\t\t\tif (++curvec == last_affv)\n\t\t\t\tcurvec = affd->pre_vectors;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor_each_node_mask(n, nodemsk) {\n\t\tint ncpus, v, vecs_to_assign, vecs_per_node;\n\n\t\t/* Spread the vectors per node */\n\t\tvecs_per_node = (numvecs - (curvec - affd->pre_vectors)) / nodes;\n\n\t\t/* Get the cpus on this node which are in the mask */\n\t\tcpumask_and(nmsk, cpu_mask, node_to_cpumask[n]);\n\n\t\t/* Calculate the number of cpus per vector */\n\t\tncpus = cpumask_weight(nmsk);\n\t\tvecs_to_assign = min(vecs_per_node, ncpus);\n\n\t\t/* Account for rounding errors */\n\t\textra_vecs = ncpus - vecs_to_assign * (ncpus / vecs_to_assign);\n\n\t\tfor (v = 0; curvec < last_affv && v < vecs_to_assign;\n\t\t     curvec++, v++) {\n\t\t\tcpus_per_vec = ncpus / vecs_to_assign;\n\n\t\t\t/* Account for extra vectors to compensate rounding errors */\n\t\t\tif (extra_vecs) {\n\t\t\t\tcpus_per_vec++;\n\t\t\t\t--extra_vecs;\n\t\t\t}\n\t\t\tirq_spread_init_one(masks + curvec, nmsk, cpus_per_vec);\n\t\t}\n\n\t\tdone += v;\n\t\tif (done >= numvecs)\n\t\t\tbreak;\n\t\tif (curvec >= last_affv)\n\t\t\tcurvec = affd->pre_vectors;\n\t\t--nodes;\n\t}\n\nout:\n\treturn done;\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic int irq_build_affinity_masks(const struct irq_affinity *affd,\n\t\t\t\t    int startvec, int numvecs,\n\t\t\t\t    cpumask_var_t *node_to_cpumask,\n\t\t\t\t    const struct cpumask *cpu_mask,\n\t\t\t\t    struct cpumask *nmsk,\n\t\t\t\t    struct cpumask *masks)\n{\n\tint n, nodes, cpus_per_vec, extra_vecs, done = 0;\n\tint last_affv = affd->pre_vectors + numvecs;\n\tint curvec = startvec;\n\tnodemask_t nodemsk = NODE_MASK_NONE;\n\n\tif (!cpumask_weight(cpu_mask))\n\t\treturn 0;\n\n\tnodes = get_nodes_in_cpumask(node_to_cpumask, cpu_mask, &nodemsk);\n\n\t/*\n\t * If the number of nodes in the mask is greater than or equal the\n\t * number of vectors we just spread the vectors across the nodes.\n\t */\n\tif (numvecs <= nodes) {\n\t\tfor_each_node_mask(n, nodemsk) {\n\t\t\tcpumask_copy(masks + curvec, node_to_cpumask[n]);\n\t\t\tif (++done == numvecs)\n\t\t\t\tbreak;\n\t\t\tif (++curvec == last_affv)\n\t\t\t\tcurvec = affd->pre_vectors;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor_each_node_mask(n, nodemsk) {\n\t\tint ncpus, v, vecs_to_assign, vecs_per_node;\n\n\t\t/* Spread the vectors per node */\n\t\tvecs_per_node = (numvecs - (curvec - affd->pre_vectors)) / nodes;\n\n\t\t/* Get the cpus on this node which are in the mask */\n\t\tcpumask_and(nmsk, cpu_mask, node_to_cpumask[n]);\n\n\t\t/* Calculate the number of cpus per vector */\n\t\tncpus = cpumask_weight(nmsk);\n\t\tvecs_to_assign = min(vecs_per_node, ncpus);\n\n\t\t/* Account for rounding errors */\n\t\textra_vecs = ncpus - vecs_to_assign * (ncpus / vecs_to_assign);\n\n\t\tfor (v = 0; curvec < last_affv && v < vecs_to_assign;\n\t\t     curvec++, v++) {\n\t\t\tcpus_per_vec = ncpus / vecs_to_assign;\n\n\t\t\t/* Account for extra vectors to compensate rounding errors */\n\t\t\tif (extra_vecs) {\n\t\t\t\tcpus_per_vec++;\n\t\t\t\t--extra_vecs;\n\t\t\t}\n\t\t\tirq_spread_init_one(masks + curvec, nmsk, cpus_per_vec);\n\t\t}\n\n\t\tdone += v;\n\t\tif (done >= numvecs)\n\t\t\tbreak;\n\t\tif (curvec >= last_affv)\n\t\t\tcurvec = affd->pre_vectors;\n\t\t--nodes;\n\t}\n\nout:\n\treturn done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "npresmsk",
            "cpu_possible_mask",
            "cpu_present_mask"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_node_to_cpumask",
          "args": [
            "node_to_cpumask"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "build_node_to_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "74-80",
          "snippet": "static void build_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void build_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "masks + curvec",
            "irq_default_affinity"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nvecs",
            "sizeof(*masks)",
            "GFP_KERNEL"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_node_to_cpumask",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_node_to_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "42-63",
          "snippet": "static cpumask_var_t *alloc_node_to_cpumask(void)\n{\n\tcpumask_var_t *masks;\n\tint node;\n\n\tmasks = kcalloc(nr_node_ids, sizeof(cpumask_var_t), GFP_KERNEL);\n\tif (!masks)\n\t\treturn NULL;\n\n\tfor (node = 0; node < nr_node_ids; node++) {\n\t\tif (!zalloc_cpumask_var(&masks[node], GFP_KERNEL))\n\t\t\tgoto out_unwind;\n\t}\n\n\treturn masks;\n\nout_unwind:\n\twhile (--node >= 0)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic cpumask_var_t *alloc_node_to_cpumask(void)\n{\n\tcpumask_var_t *masks;\n\tint node;\n\n\tmasks = kcalloc(nr_node_ids, sizeof(cpumask_var_t), GFP_KERNEL);\n\tif (!masks)\n\t\treturn NULL;\n\n\tfor (node = 0; node < nr_node_ids; node++) {\n\t\tif (!zalloc_cpumask_var(&masks[node], GFP_KERNEL))\n\t\t\tgoto out_unwind;\n\t}\n\n\treturn masks;\n\nout_unwind:\n\twhile (--node >= 0)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&npresmsk",
            "GFP_KERNEL"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&nmsk",
            "GFP_KERNEL"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstruct cpumask *\nirq_create_affinity_masks(int nvecs, const struct irq_affinity *affd)\n{\n\tint affvecs = nvecs - affd->pre_vectors - affd->post_vectors;\n\tint curvec, usedvecs;\n\tcpumask_var_t nmsk, npresmsk, *node_to_cpumask;\n\tstruct cpumask *masks = NULL;\n\n\t/*\n\t * If there aren't any vectors left after applying the pre/post\n\t * vectors don't bother with assigning affinity.\n\t */\n\tif (nvecs == affd->pre_vectors + affd->post_vectors)\n\t\treturn NULL;\n\n\tif (!zalloc_cpumask_var(&nmsk, GFP_KERNEL))\n\t\treturn NULL;\n\n\tif (!zalloc_cpumask_var(&npresmsk, GFP_KERNEL))\n\t\tgoto outcpumsk;\n\n\tnode_to_cpumask = alloc_node_to_cpumask();\n\tif (!node_to_cpumask)\n\t\tgoto outnpresmsk;\n\n\tmasks = kcalloc(nvecs, sizeof(*masks), GFP_KERNEL);\n\tif (!masks)\n\t\tgoto outnodemsk;\n\n\t/* Fill out vectors at the beginning that don't need affinity */\n\tfor (curvec = 0; curvec < affd->pre_vectors; curvec++)\n\t\tcpumask_copy(masks + curvec, irq_default_affinity);\n\n\t/* Stabilize the cpumasks */\n\tget_online_cpus();\n\tbuild_node_to_cpumask(node_to_cpumask);\n\n\t/* Spread on present CPUs starting from affd->pre_vectors */\n\tusedvecs = irq_build_affinity_masks(affd, curvec, affvecs,\n\t\t\t\t\t    node_to_cpumask, cpu_present_mask,\n\t\t\t\t\t    nmsk, masks);\n\n\t/*\n\t * Spread on non present CPUs starting from the next vector to be\n\t * handled. If the spreading of present CPUs already exhausted the\n\t * vector space, assign the non present CPUs to the already spread\n\t * out vectors.\n\t */\n\tif (usedvecs >= affvecs)\n\t\tcurvec = affd->pre_vectors;\n\telse\n\t\tcurvec = affd->pre_vectors + usedvecs;\n\tcpumask_andnot(npresmsk, cpu_possible_mask, cpu_present_mask);\n\tusedvecs += irq_build_affinity_masks(affd, curvec, affvecs,\n\t\t\t\t\t     node_to_cpumask, npresmsk,\n\t\t\t\t\t     nmsk, masks);\n\tput_online_cpus();\n\n\t/* Fill out vectors at the end that don't need affinity */\n\tif (usedvecs >= affvecs)\n\t\tcurvec = affd->pre_vectors + affvecs;\n\telse\n\t\tcurvec = affd->pre_vectors + usedvecs;\n\tfor (; curvec < nvecs; curvec++)\n\t\tcpumask_copy(masks + curvec, irq_default_affinity);\n\noutnodemsk:\n\tfree_node_to_cpumask(node_to_cpumask);\noutnpresmsk:\n\tfree_cpumask_var(npresmsk);\noutcpumsk:\n\tfree_cpumask_var(nmsk);\n\treturn masks;\n}"
  },
  {
    "function_name": "irq_build_affinity_masks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "97-167",
    "snippet": "static int irq_build_affinity_masks(const struct irq_affinity *affd,\n\t\t\t\t    int startvec, int numvecs,\n\t\t\t\t    cpumask_var_t *node_to_cpumask,\n\t\t\t\t    const struct cpumask *cpu_mask,\n\t\t\t\t    struct cpumask *nmsk,\n\t\t\t\t    struct cpumask *masks)\n{\n\tint n, nodes, cpus_per_vec, extra_vecs, done = 0;\n\tint last_affv = affd->pre_vectors + numvecs;\n\tint curvec = startvec;\n\tnodemask_t nodemsk = NODE_MASK_NONE;\n\n\tif (!cpumask_weight(cpu_mask))\n\t\treturn 0;\n\n\tnodes = get_nodes_in_cpumask(node_to_cpumask, cpu_mask, &nodemsk);\n\n\t/*\n\t * If the number of nodes in the mask is greater than or equal the\n\t * number of vectors we just spread the vectors across the nodes.\n\t */\n\tif (numvecs <= nodes) {\n\t\tfor_each_node_mask(n, nodemsk) {\n\t\t\tcpumask_copy(masks + curvec, node_to_cpumask[n]);\n\t\t\tif (++done == numvecs)\n\t\t\t\tbreak;\n\t\t\tif (++curvec == last_affv)\n\t\t\t\tcurvec = affd->pre_vectors;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor_each_node_mask(n, nodemsk) {\n\t\tint ncpus, v, vecs_to_assign, vecs_per_node;\n\n\t\t/* Spread the vectors per node */\n\t\tvecs_per_node = (numvecs - (curvec - affd->pre_vectors)) / nodes;\n\n\t\t/* Get the cpus on this node which are in the mask */\n\t\tcpumask_and(nmsk, cpu_mask, node_to_cpumask[n]);\n\n\t\t/* Calculate the number of cpus per vector */\n\t\tncpus = cpumask_weight(nmsk);\n\t\tvecs_to_assign = min(vecs_per_node, ncpus);\n\n\t\t/* Account for rounding errors */\n\t\textra_vecs = ncpus - vecs_to_assign * (ncpus / vecs_to_assign);\n\n\t\tfor (v = 0; curvec < last_affv && v < vecs_to_assign;\n\t\t     curvec++, v++) {\n\t\t\tcpus_per_vec = ncpus / vecs_to_assign;\n\n\t\t\t/* Account for extra vectors to compensate rounding errors */\n\t\t\tif (extra_vecs) {\n\t\t\t\tcpus_per_vec++;\n\t\t\t\t--extra_vecs;\n\t\t\t}\n\t\t\tirq_spread_init_one(masks + curvec, nmsk, cpus_per_vec);\n\t\t}\n\n\t\tdone += v;\n\t\tif (done >= numvecs)\n\t\t\tbreak;\n\t\tif (curvec >= last_affv)\n\t\t\tcurvec = affd->pre_vectors;\n\t\t--nodes;\n\t}\n\nout:\n\treturn done;\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_spread_init_one",
          "args": [
            "masks + curvec",
            "nmsk",
            "cpus_per_vec"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "irq_spread_init_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "11-40",
          "snippet": "static void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,\n\t\t\t\tint cpus_per_vec)\n{\n\tconst struct cpumask *siblmsk;\n\tint cpu, sibl;\n\n\tfor ( ; cpus_per_vec > 0; ) {\n\t\tcpu = cpumask_first(nmsk);\n\n\t\t/* Should not happen, but I'm too lazy to think about it */\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\treturn;\n\n\t\tcpumask_clear_cpu(cpu, nmsk);\n\t\tcpumask_set_cpu(cpu, irqmsk);\n\t\tcpus_per_vec--;\n\n\t\t/* If the cpu has siblings, use them first */\n\t\tsiblmsk = topology_sibling_cpumask(cpu);\n\t\tfor (sibl = -1; cpus_per_vec > 0; ) {\n\t\t\tsibl = cpumask_next(sibl, siblmsk);\n\t\t\tif (sibl >= nr_cpu_ids)\n\t\t\t\tbreak;\n\t\t\tif (!cpumask_test_and_clear_cpu(sibl, nmsk))\n\t\t\t\tcontinue;\n\t\t\tcpumask_set_cpu(sibl, irqmsk);\n\t\t\tcpus_per_vec--;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,\n\t\t\t\tint cpus_per_vec)\n{\n\tconst struct cpumask *siblmsk;\n\tint cpu, sibl;\n\n\tfor ( ; cpus_per_vec > 0; ) {\n\t\tcpu = cpumask_first(nmsk);\n\n\t\t/* Should not happen, but I'm too lazy to think about it */\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\treturn;\n\n\t\tcpumask_clear_cpu(cpu, nmsk);\n\t\tcpumask_set_cpu(cpu, irqmsk);\n\t\tcpus_per_vec--;\n\n\t\t/* If the cpu has siblings, use them first */\n\t\tsiblmsk = topology_sibling_cpumask(cpu);\n\t\tfor (sibl = -1; cpus_per_vec > 0; ) {\n\t\t\tsibl = cpumask_next(sibl, siblmsk);\n\t\t\tif (sibl >= nr_cpu_ids)\n\t\t\t\tbreak;\n\t\t\tif (!cpumask_test_and_clear_cpu(sibl, nmsk))\n\t\t\t\tcontinue;\n\t\t\tcpumask_set_cpu(sibl, irqmsk);\n\t\t\tcpus_per_vec--;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vecs_per_node",
            "ncpus"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "nmsk"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "nmsk",
            "cpu_mask",
            "node_to_cpumask[n]"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "n",
            "nodemsk"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "masks + curvec",
            "node_to_cpumask[n]"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "n",
            "nodemsk"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nodes_in_cpumask",
          "args": [
            "node_to_cpumask",
            "cpu_mask",
            "&nodemsk"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_nodes_in_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
          "lines": "82-95",
          "snippet": "static int get_nodes_in_cpumask(cpumask_var_t *node_to_cpumask,\n\t\t\t\tconst struct cpumask *mask, nodemask_t *nodemsk)\n{\n\tint n, nodes = 0;\n\n\t/* Calculate the number of nodes in the supplied affinity mask */\n\tfor_each_node(n) {\n\t\tif (cpumask_intersects(mask, node_to_cpumask[n])) {\n\t\t\tnode_set(n, *nodemsk);\n\t\t\tnodes++;\n\t\t}\n\t}\n\treturn nodes;\n}",
          "includes": [
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic int get_nodes_in_cpumask(cpumask_var_t *node_to_cpumask,\n\t\t\t\tconst struct cpumask *mask, nodemask_t *nodemsk)\n{\n\tint n, nodes = 0;\n\n\t/* Calculate the number of nodes in the supplied affinity mask */\n\tfor_each_node(n) {\n\t\tif (cpumask_intersects(mask, node_to_cpumask[n])) {\n\t\t\tnode_set(n, *nodemsk);\n\t\t\tnodes++;\n\t\t}\n\t}\n\treturn nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cpu_mask"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic int irq_build_affinity_masks(const struct irq_affinity *affd,\n\t\t\t\t    int startvec, int numvecs,\n\t\t\t\t    cpumask_var_t *node_to_cpumask,\n\t\t\t\t    const struct cpumask *cpu_mask,\n\t\t\t\t    struct cpumask *nmsk,\n\t\t\t\t    struct cpumask *masks)\n{\n\tint n, nodes, cpus_per_vec, extra_vecs, done = 0;\n\tint last_affv = affd->pre_vectors + numvecs;\n\tint curvec = startvec;\n\tnodemask_t nodemsk = NODE_MASK_NONE;\n\n\tif (!cpumask_weight(cpu_mask))\n\t\treturn 0;\n\n\tnodes = get_nodes_in_cpumask(node_to_cpumask, cpu_mask, &nodemsk);\n\n\t/*\n\t * If the number of nodes in the mask is greater than or equal the\n\t * number of vectors we just spread the vectors across the nodes.\n\t */\n\tif (numvecs <= nodes) {\n\t\tfor_each_node_mask(n, nodemsk) {\n\t\t\tcpumask_copy(masks + curvec, node_to_cpumask[n]);\n\t\t\tif (++done == numvecs)\n\t\t\t\tbreak;\n\t\t\tif (++curvec == last_affv)\n\t\t\t\tcurvec = affd->pre_vectors;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor_each_node_mask(n, nodemsk) {\n\t\tint ncpus, v, vecs_to_assign, vecs_per_node;\n\n\t\t/* Spread the vectors per node */\n\t\tvecs_per_node = (numvecs - (curvec - affd->pre_vectors)) / nodes;\n\n\t\t/* Get the cpus on this node which are in the mask */\n\t\tcpumask_and(nmsk, cpu_mask, node_to_cpumask[n]);\n\n\t\t/* Calculate the number of cpus per vector */\n\t\tncpus = cpumask_weight(nmsk);\n\t\tvecs_to_assign = min(vecs_per_node, ncpus);\n\n\t\t/* Account for rounding errors */\n\t\textra_vecs = ncpus - vecs_to_assign * (ncpus / vecs_to_assign);\n\n\t\tfor (v = 0; curvec < last_affv && v < vecs_to_assign;\n\t\t     curvec++, v++) {\n\t\t\tcpus_per_vec = ncpus / vecs_to_assign;\n\n\t\t\t/* Account for extra vectors to compensate rounding errors */\n\t\t\tif (extra_vecs) {\n\t\t\t\tcpus_per_vec++;\n\t\t\t\t--extra_vecs;\n\t\t\t}\n\t\t\tirq_spread_init_one(masks + curvec, nmsk, cpus_per_vec);\n\t\t}\n\n\t\tdone += v;\n\t\tif (done >= numvecs)\n\t\t\tbreak;\n\t\tif (curvec >= last_affv)\n\t\t\tcurvec = affd->pre_vectors;\n\t\t--nodes;\n\t}\n\nout:\n\treturn done;\n}"
  },
  {
    "function_name": "get_nodes_in_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "82-95",
    "snippet": "static int get_nodes_in_cpumask(cpumask_var_t *node_to_cpumask,\n\t\t\t\tconst struct cpumask *mask, nodemask_t *nodemsk)\n{\n\tint n, nodes = 0;\n\n\t/* Calculate the number of nodes in the supplied affinity mask */\n\tfor_each_node(n) {\n\t\tif (cpumask_intersects(mask, node_to_cpumask[n])) {\n\t\t\tnode_set(n, *nodemsk);\n\t\t\tnodes++;\n\t\t}\n\t}\n\treturn nodes;\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "n",
            "*nodemsk"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "mask",
            "node_to_cpumask[n]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic int get_nodes_in_cpumask(cpumask_var_t *node_to_cpumask,\n\t\t\t\tconst struct cpumask *mask, nodemask_t *nodemsk)\n{\n\tint n, nodes = 0;\n\n\t/* Calculate the number of nodes in the supplied affinity mask */\n\tfor_each_node(n) {\n\t\tif (cpumask_intersects(mask, node_to_cpumask[n])) {\n\t\t\tnode_set(n, *nodemsk);\n\t\t\tnodes++;\n\t\t}\n\t}\n\treturn nodes;\n}"
  },
  {
    "function_name": "build_node_to_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "74-80",
    "snippet": "static void build_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void build_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);\n}"
  },
  {
    "function_name": "free_node_to_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "65-72",
    "snippet": "static void free_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint node;\n\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "masks"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "masks[node]"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void free_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint node;\n\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n}"
  },
  {
    "function_name": "alloc_node_to_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "42-63",
    "snippet": "static cpumask_var_t *alloc_node_to_cpumask(void)\n{\n\tcpumask_var_t *masks;\n\tint node;\n\n\tmasks = kcalloc(nr_node_ids, sizeof(cpumask_var_t), GFP_KERNEL);\n\tif (!masks)\n\t\treturn NULL;\n\n\tfor (node = 0; node < nr_node_ids; node++) {\n\t\tif (!zalloc_cpumask_var(&masks[node], GFP_KERNEL))\n\t\t\tgoto out_unwind;\n\t}\n\n\treturn masks;\n\nout_unwind:\n\twhile (--node >= 0)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "masks"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "masks[node]"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&masks[node]",
            "GFP_KERNEL"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_node_ids",
            "sizeof(cpumask_var_t)",
            "GFP_KERNEL"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic cpumask_var_t *alloc_node_to_cpumask(void)\n{\n\tcpumask_var_t *masks;\n\tint node;\n\n\tmasks = kcalloc(nr_node_ids, sizeof(cpumask_var_t), GFP_KERNEL);\n\tif (!masks)\n\t\treturn NULL;\n\n\tfor (node = 0; node < nr_node_ids; node++) {\n\t\tif (!zalloc_cpumask_var(&masks[node], GFP_KERNEL))\n\t\t\tgoto out_unwind;\n\t}\n\n\treturn masks;\n\nout_unwind:\n\twhile (--node >= 0)\n\t\tfree_cpumask_var(masks[node]);\n\tkfree(masks);\n\treturn NULL;\n}"
  },
  {
    "function_name": "irq_spread_init_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/affinity.c",
    "lines": "11-40",
    "snippet": "static void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,\n\t\t\t\tint cpus_per_vec)\n{\n\tconst struct cpumask *siblmsk;\n\tint cpu, sibl;\n\n\tfor ( ; cpus_per_vec > 0; ) {\n\t\tcpu = cpumask_first(nmsk);\n\n\t\t/* Should not happen, but I'm too lazy to think about it */\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\treturn;\n\n\t\tcpumask_clear_cpu(cpu, nmsk);\n\t\tcpumask_set_cpu(cpu, irqmsk);\n\t\tcpus_per_vec--;\n\n\t\t/* If the cpu has siblings, use them first */\n\t\tsiblmsk = topology_sibling_cpumask(cpu);\n\t\tfor (sibl = -1; cpus_per_vec > 0; ) {\n\t\t\tsibl = cpumask_next(sibl, siblmsk);\n\t\t\tif (sibl >= nr_cpu_ids)\n\t\t\t\tbreak;\n\t\t\tif (!cpumask_test_and_clear_cpu(sibl, nmsk))\n\t\t\t\tcontinue;\n\t\t\tcpumask_set_cpu(sibl, irqmsk);\n\t\t\tcpus_per_vec--;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "sibl",
            "irqmsk"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "sibl",
            "nmsk"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "sibl",
            "siblmsk"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "topology_sibling_cpumask",
          "args": [
            "cpu"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "irqmsk"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "nmsk"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "nmsk"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,\n\t\t\t\tint cpus_per_vec)\n{\n\tconst struct cpumask *siblmsk;\n\tint cpu, sibl;\n\n\tfor ( ; cpus_per_vec > 0; ) {\n\t\tcpu = cpumask_first(nmsk);\n\n\t\t/* Should not happen, but I'm too lazy to think about it */\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\treturn;\n\n\t\tcpumask_clear_cpu(cpu, nmsk);\n\t\tcpumask_set_cpu(cpu, irqmsk);\n\t\tcpus_per_vec--;\n\n\t\t/* If the cpu has siblings, use them first */\n\t\tsiblmsk = topology_sibling_cpumask(cpu);\n\t\tfor (sibl = -1; cpus_per_vec > 0; ) {\n\t\t\tsibl = cpumask_next(sibl, siblmsk);\n\t\t\tif (sibl >= nr_cpu_ids)\n\t\t\t\tbreak;\n\t\t\tif (!cpumask_test_and_clear_cpu(sibl, nmsk))\n\t\t\t\tcontinue;\n\t\t\tcpumask_set_cpu(sibl, irqmsk);\n\t\t\tcpus_per_vec--;\n\t\t}\n\t}\n}"
  }
]