[
  {
    "function_name": "swsusp_header_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1596-1602",
    "snippet": "static int swsusp_header_init(void)\n{\n\tswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\n\tif (!swsusp_header)\n\t\tpanic(\"Could not allocate memory for swsusp_header\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Could not allocate memory for swsusp_header\\n\""
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int swsusp_header_init(void)\n{\n\tswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\n\tif (!swsusp_header)\n\t\tpanic(\"Could not allocate memory for swsusp_header\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "swsusp_unmark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1571-1593",
    "snippet": "int swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIBERNATE_SIG\t\"S1SUSPEND\""
    ],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;",
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "root_swap"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "198-213",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot find swsusp signature!\\n\""
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "swsusp_resume_block",
            "swsusp_header",
            "NULL"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "265-295",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "swsusp_header->sig",
            "swsusp_header->orig_sig",
            "10"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "HIBERNATE_SIG",
            "swsusp_header->sig",
            "10"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic unsigned short root_swap = 0xffff;\n\nint swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}"
  },
  {
    "function_name": "swsusp_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1556-1564",
    "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "hib_resume_bdev",
            "mode"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image device not initialised\\n\""
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
  },
  {
    "function_name": "swsusp_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1512-1550",
    "snippet": "int swsusp_check(void)\n{\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIBERNATE_SIG\t\"S1SUSPEND\""
    ],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;",
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image not found (code %d)\\n\"",
            "error"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image signature found, resuming\\n\""
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "hib_resume_bdev",
            "FMODE_READ"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "swsusp_resume_block",
            "swsusp_header",
            "NULL"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "265-295",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "swsusp_header->sig",
            "swsusp_header->orig_sig",
            "10"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "HIBERNATE_SIG",
            "swsusp_header->sig",
            "10"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "swsusp_header"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "hib_resume_bdev",
            "PAGE_SIZE"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hib_resume_bdev"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "swsusp_resume_device",
            "FMODE_READ",
            "NULL"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic struct block_device *hib_resume_bdev;\n\nint swsusp_check(void)\n{\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "swsusp_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1477-1506",
    "snippet": "int swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Error %d resuming\\n\"",
            "error"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Image successfully loaded\\n\""
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_reader_finish",
          "args": [
            "&handle"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "swap_reader_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1039-1044",
          "snippet": "static int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_image_lzo",
          "args": [
            "&handle",
            "&snapshot",
            "header->pages - 1"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "load_image_lzo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1157-1469",
          "snippet": "static int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct dec_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LZO_MAX_RD_PAGES\t8192",
            "#define LZO_MIN_RD_PAGES\t1024",
            "#define LZO_THREADS\t3",
            "#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)",
            "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
            "#define LZO_HEADER\tsizeof(size_t)"
          ],
          "globals_used": [
            "static bool clean_pages_on_decompress;",
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_MAX_RD_PAGES\t8192\n#define LZO_MIN_RD_PAGES\t1024\n#define LZO_THREADS\t3\n#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\nstatic struct swsusp_header *swsusp_header;\n\nstatic int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct dec_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_read_page",
          "args": [
            "&handle",
            "header",
            "NULL"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "swap_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1010-1037",
          "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_swap_reader",
          "args": [
            "&handle",
            "flags_p"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "963-1008",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "snapshot"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "&snapshot"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2577-2645",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&snapshot",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}"
  },
  {
    "function_name": "load_image_lzo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1157-1469",
    "snippet": "static int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct dec_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_MAX_RD_PAGES\t8192",
      "#define LZO_MIN_RD_PAGES\t1024",
      "#define LZO_THREADS\t3",
      "#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)",
      "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [
      "static bool clean_pages_on_decompress;",
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "page"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "data[thr].thr"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "538-556",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "crc"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page[i]"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_read",
            "\"Read\""
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "240-259",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid image CRC32!\\n\""
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_image_loaded",
          "args": [
            "snapshot"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_image_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2669-2673",
          "snippet": "int snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nint snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_write_finalize",
          "args": [
            "snapshot"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2655-2667",
          "snippet": "void snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\t/* Restore page key for data page (s390 only). */\n\tpage_key_write(handle->buffer);\n\tpage_key_free();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\n\nvoid snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\t/* Restore page key for data page (s390 only). */\n\tpage_key_write(handle->buffer);\n\tpage_key_free();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading done\\n\""
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->stop",
            "0"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "crc->done",
            "atomic_read(&crc->stop)"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&crc->stop"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&crc->go"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->ready",
            "1"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->ready",
            "1"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "snapshot"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2577-2645",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data_of(*snapshot)",
            "data[thr].unc + off",
            "PAGE_SIZE"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid LZO uncompressed length\\n\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"LZO decompression failed\\n\""
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].stop",
            "0"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "data[thr].done",
            "atomic_read(&data[thr].stop)"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data[thr].stop"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "297-301",
          "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].ready",
            "1"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "data[thr].cmp_len + LZO_HEADER",
            "PAGE_SIZE"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid LZO compressed length\\n\""
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "LZO_UNC_SIZE"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->stop",
            "0"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "crc->done",
            "atomic_read(&crc->stop)"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&crc->stop"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_read_page",
          "args": [
            "handle",
            "page[ring]",
            "&hb"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "swap_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1010-1037",
          "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Loading and decompressing image data (%u pages)...\\n\"",
            "nr_to_read"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Using %u thread(s) for decompression\\n\"",
            "nr_threads"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO pages\\n\""
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "read_pages",
            "LZO_MIN_RD_PAGES",
            "LZO_MAX_RD_PAGES"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_get_image_size",
          "args": [],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_get_image_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2028-2031",
          "snippet": "unsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nunsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "low_free_pages",
          "args": [],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "low_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start CRC32 thread\\n\""
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "crc->thr"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "crc32_threadfn",
            "crc",
            "\"image_crc32\""
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->done"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->go"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start decompression threads\\n\""
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data[thr].thr"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "lzo_decompress_threadfn",
            "&data[thr]",
            "\"image_decompress/%u\"",
            "thr"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].done"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].go"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "crc",
            "0",
            "offsetof(struct crc_data, go)"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate crc\\n\""
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*crc)",
            "GFP_KERNEL"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data[thr]",
            "0",
            "offsetof(struct dec_data, go)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO data\\n\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(nr_threads, sizeof(*data))"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "nr_threads",
            "sizeof(*data)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO page\\n\""
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(LZO_MAX_RD_PAGES, sizeof(*page))"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "LZO_MAX_RD_PAGES",
            "sizeof(*page)"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "nr_threads",
            "1",
            "LZO_THREADS"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "233-238",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_MAX_RD_PAGES\t8192\n#define LZO_MIN_RD_PAGES\t1024\n#define LZO_THREADS\t3\n#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\nstatic struct swsusp_header *swsusp_header;\n\nstatic int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for decompression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct dec_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\tclean_pages_on_decompress = true;\n\n\t/*\n\t * Start the decompression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Set the number of pages for read buffering.\n\t * This is complete guesswork, because we'll only know the real\n\t * picture once prepare_image() is called, which is much later on\n\t * during the image load phase. We'll assume the worst case and\n\t * say that none of the image pages are from high memory.\n\t */\n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t/*\n\t\t\t\t * On real read error, finish. On end of data,\n\t\t\t\t * set EOF flag and just exit the read loop.\n\t\t\t\t */\n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t/*\n\t\t * We are out of data, wait for some more.\n\t\t */\n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t/*\n\t\t * Wait for more data while we are decompressing.\n\t\t */\n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lzo_decompress_threadfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1122-1149",
    "snippet": "static int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [
      "static bool clean_pages_on_decompress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&d->done"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)d->unc",
            "(unsigned long)d->unc + d->unc_len"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_decompress_safe",
          "args": [
            "d->cmp + LZO_HEADER",
            "d->cmp_len",
            "d->unc",
            "&d->unc_len"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ready",
            "0"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "d->go",
            "atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop()"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ready"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic bool clean_pages_on_decompress;\n\nstatic int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "load_image",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1052-1101",
    "snippet": "static int load_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tktime_t start;\n\tktime_t stop;\n\tstruct hib_bio_batch hb;\n\tint err2;\n\tunsigned nr_pages;\n\n\thib_init_batch(&hb);\n\n\tclean_pages_on_read = true;\n\tpr_info(\"Loading image data pages (%u pages)...\\n\", nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor ( ; ; ) {\n\t\tret = snapshot_write_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->sync_read)\n\t\t\tret = hib_wait_io(&hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clean_pages_on_read;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_read",
            "\"Read\""
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "240-259",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_image_loaded",
          "args": [
            "snapshot"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_image_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2669-2673",
          "snippet": "int snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nint snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_write_finalize",
          "args": [
            "snapshot"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2655-2667",
          "snippet": "void snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\t/* Restore page key for data page (s390 only). */\n\tpage_key_write(handle->buffer);\n\tpage_key_free();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\n\nvoid snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\t/* Restore page key for data page (s390 only). */\n\tpage_key_write(handle->buffer);\n\tpage_key_free();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading done\\n\""
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "297-301",
          "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image loading progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_read_page",
          "args": [
            "handle",
            "data_of(*snapshot)",
            "&hb"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "swap_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1010-1037",
          "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "snapshot"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2577-2645",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Loading image data pages (%u pages)...\\n\"",
            "nr_to_read"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "233-238",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic bool clean_pages_on_read;\n\nstatic int load_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tktime_t start;\n\tktime_t stop;\n\tstruct hib_bio_batch hb;\n\tint err2;\n\tunsigned nr_pages;\n\n\thib_init_batch(&hb);\n\n\tclean_pages_on_read = true;\n\tpr_info(\"Loading image data pages (%u pages)...\\n\", nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor ( ; ; ) {\n\t\tret = snapshot_write_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->sync_read)\n\t\t\tret = hib_wait_io(&hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\n\treturn ret;\n}"
  },
  {
    "function_name": "swap_reader_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1039-1044",
    "snippet": "static int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_swap_reader",
          "args": [
            "handle"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "949-961",
          "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "1010-1037",
    "snippet": "static int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_swap_reader",
          "args": [
            "handle"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "949-961",
          "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)handle->maps->map"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_READ",
            "0",
            "offset",
            "buf",
            "hb"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "265-295",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, 0, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "get_swap_reader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "963-1008",
    "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_swap_reader",
          "args": [
            "handle"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "949-961",
          "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_READ",
            "0",
            "offset",
            "tmp->map",
            "NULL"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "265-295",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO | __GFP_HIGH"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "sizeof(*tmp)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*handle->maps)",
            "GFP_KERNEL"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
  },
  {
    "function_name": "release_swap_reader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "949-961",
    "snippet": "static void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)handle->maps->map"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}"
  },
  {
    "function_name": "swsusp_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "903-942",
    "snippet": "int swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_writer_finish",
          "args": [
            "&handle",
            "flags",
            "error"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "swap_writer_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "490-506",
          "snippet": "static int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tflush_swap_writer(handle);\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tflush_swap_writer(handle);\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_image_lzo",
          "args": [
            "&handle",
            "&snapshot",
            "pages - 1"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "save_image_lzo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "668-873",
          "snippet": "static int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct cmp_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LZO_THREADS\t3",
            "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
            "#define LZO_HEADER\tsizeof(size_t)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_THREADS\t3\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct cmp_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_write_page",
          "args": [
            "&handle",
            "header",
            "NULL"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "442-480",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "snapshot"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "&snapshot"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2081-2126",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&snapshot",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not enough free swap\\n\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enough_swap",
          "args": [
            "pages"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "enough_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "882-891",
          "snippet": "static int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot get swap writer\\n\""
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_swap_writer",
          "args": [
            "&handle"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "411-440",
          "snippet": "static int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_get_image_size",
          "args": [],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_get_image_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2028-2031",
          "snippet": "unsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nunsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}"
  },
  {
    "function_name": "enough_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "882-891",
    "snippet": "static int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Free swap pages: %u\\n\"",
            "free_swap"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_swap_pages",
          "args": [
            "root_swap",
            "1"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}"
  },
  {
    "function_name": "save_image_lzo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "668-873",
    "snippet": "static int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct cmp_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_THREADS\t3",
      "#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)",
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "data[thr].thr"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "538-556",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "crc"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_write",
            "\"Wrote\""
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "240-259",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving done\\n\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "297-301",
          "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->stop",
            "0"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "crc->done",
            "atomic_read(&crc->stop)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&crc->stop"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_write_page",
          "args": [
            "handle",
            "page",
            "&hb"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "442-480",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page",
            "data[thr].cmp + off",
            "PAGE_SIZE"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid LZO compressed length\\n\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "data[thr].unc_len"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"LZO compression failed\\n\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].stop",
            "0"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "data[thr].done",
            "atomic_read(&data[thr].stop)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data[thr].stop"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&crc->go"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&crc->ready",
            "1"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data[thr].ready",
            "1"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "snapshot"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2081-2126",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Compressing and saving image data (%u pages)...\\n\"",
            "nr_to_write"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Using %u thread(s) for compression\\n\"",
            "nr_threads"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqd_free_pages",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "reqd_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "77-80",
          "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start CRC32 thread\\n\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "crc->thr"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "crc32_threadfn",
            "crc",
            "\"image_crc32\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->done"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&crc->go"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot start compression threads\\n\""
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data[thr].thr"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "lzo_compress_threadfn",
            "&data[thr]",
            "\"image_compress/%u\"",
            "thr"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].done"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&data[thr].go"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "crc",
            "0",
            "offsetof(struct crc_data, go)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate crc\\n\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*crc)",
            "GFP_KERNEL"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data[thr]",
            "0",
            "offsetof(struct cmp_data, go)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO data\\n\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(nr_threads, sizeof(*data))"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "nr_threads",
            "sizeof(*data)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate LZO page\\n\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO | __GFP_HIGH"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "nr_threads",
            "1",
            "LZO_THREADS"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "233-238",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_THREADS\t3\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t/*\n\t * We'll limit the number of threads for compression to limit memory\n\t * footprint.\n\t */\n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vmalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tfor (thr = 0; thr < nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct cmp_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t/*\n\t * Start the compression threads.\n\t */\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t/*\n\t * Start the CRC32 thread.\n\t */\n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t/*\n\t * Adjust the number of required free pages after all allocations have\n\t * been done. We don't want to run out of pages when writing.\n\t */\n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t/*\n\t\t\t * Given we are writing one page at a time to disk, we\n\t\t\t * copy that much from the buffer, although the last\n\t\t\t * bit will likely be smaller than full page. This is\n\t\t\t * OK - we saved the length of the compressed data, so\n\t\t\t * any garbage at the end will be discarded when we\n\t\t\t * read it.\n\t\t\t */\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lzo_compress_threadfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "637-660",
    "snippet": "static int lzo_compress_threadfn(void *data)\n{\n\tstruct cmp_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->ret = lzo1x_1_compress(d->unc, d->unc_len,\n\t\t                          d->cmp + LZO_HEADER, &d->cmp_len,\n\t\t                          d->wrk);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LZO_HEADER\tsizeof(size_t)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&d->done"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_1_compress",
          "args": [
            "d->unc",
            "d->unc_len",
            "d->cmp + LZO_HEADER",
            "&d->cmp_len",
            "d->wrk"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ready",
            "0"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "d->go",
            "atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop()"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ready"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define LZO_HEADER\tsizeof(size_t)\n\nstatic int lzo_compress_threadfn(void *data)\n{\n\tstruct cmp_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->ret = lzo1x_1_compress(d->unc, d->unc_len,\n\t\t                          d->cmp + LZO_HEADER, &d->cmp_len,\n\t\t                          d->wrk);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "crc32_threadfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "593-616",
    "snippet": "static int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\tfor (i = 0; i < d->run_threads; i++)\n\t\t\t*d->crc32 = crc32_le(*d->crc32,\n\t\t\t                     d->unc[i], *d->unc_len[i]);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&d->done"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "*d->crc32",
            "d->unc[i]",
            "*d->unc_len[i]"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ready",
            "0"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->stop",
            "1"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "d->go",
            "atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop()"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ready"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\tfor (i = 0; i < d->run_threads; i++)\n\t\t\t*d->crc32 = crc32_le(*d->crc32,\n\t\t\t                     d->unc[i], *d->unc_len[i]);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "save_image",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "532-573",
    "snippet": "static int save_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\n\thib_init_batch(&hb);\n\n\tpr_info(\"Saving image data pages (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\twhile (1) {\n\t\tret = snapshot_read_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_show_speed",
          "args": [
            "start",
            "stop",
            "nr_to_write",
            "\"Wrote\""
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_show_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "240-259",
          "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving done\\n\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "&hb"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "297-301",
          "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Image saving progress: %3d%%\\n\"",
            "nr_pages / m * 10"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_write_page",
          "args": [
            "handle",
            "data_of(*snapshot)",
            "&hb"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "442-480",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "*snapshot"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "snapshot"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2081-2126",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Saving image data pages (%u pages)...\\n\"",
            "nr_to_write"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_init_batch",
          "args": [
            "&hb"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "hib_init_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "233-238",
          "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int save_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\n\thib_init_batch(&hb);\n\n\tpr_info(\"Saving image data pages (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\twhile (1) {\n\t\tret = snapshot_read_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\n\treturn ret;\n}"
  },
  {
    "function_name": "swap_writer_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "490-506",
    "snippet": "static int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tflush_swap_writer(handle);\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_WRITE"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1556-1564",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_swap_writer",
          "args": [
            "handle"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "404-409",
          "snippet": "static void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "root_swap"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "198-213",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"|\\n\""
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_swapfiles",
          "args": [
            "handle",
            "flags"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "mark_swapfiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "307-328",
          "snippet": "static int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"S\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_swap_writer",
          "args": [
            "handle"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "flush_swap_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "482-488",
          "snippet": "static int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tflush_swap_writer(handle);\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(FMODE_WRITE);\n\n\treturn error;\n}"
  },
  {
    "function_name": "flush_swap_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "482-488",
    "snippet": "static int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_page",
          "args": [
            "handle->cur",
            "handle->cur_swap",
            "NULL"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "442-480",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
          ],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "swap_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "442-480",
    "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)"
    ],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reqd_free_pages",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "reqd_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "77-80",
          "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "hb"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "297-301",
          "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "low_free_pages",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "low_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "handle->cur"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_page",
          "args": [
            "handle->cur",
            "handle->cur_swap",
            "hb"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "swap_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "442-480",
          "snippet": "static int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "alloc_swapdev_block",
          "args": [
            "root_swap"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_swapdev_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "178-190",
          "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Recalculate the number of required free pages, to\n\t\t\t * make sure we never take more than half.\n\t\t\t */\n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "get_swap_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "411-440",
    "snippet": "static int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_WRITE"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "1556-1564",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_swap_writer",
          "args": [
            "handle"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "release_swap_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "404-409",
          "snippet": "static void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reqd_free_pages",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "reqd_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "77-80",
          "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_swapdev_block",
          "args": [
            "root_swap"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_swapdev_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "178-190",
          "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot find swap device, try swapon -a\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_swap_check",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_swap_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "336-361",
          "snippet": "static int swsusp_swap_check(void)\n{\n\tint res;\n\n\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block,\n\t\t\t&hib_resume_bdev);\n\tif (res < 0)\n\t\treturn res;\n\n\troot_swap = res;\n\tres = blkdev_get(hib_resume_bdev, FMODE_WRITE, NULL);\n\tif (res)\n\t\treturn res;\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\t/*\n\t * Update the resume device to the one actually used,\n\t * so the test_resume mode can use it in case it is\n\t * invoked from hibernate() to test the snapshot.\n\t */\n\tswsusp_resume_device = hib_resume_bdev->bd_dev;\n\treturn res;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short root_swap = 0xffff;",
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\nstatic struct block_device *hib_resume_bdev;\n\nstatic int swsusp_swap_check(void)\n{\n\tint res;\n\n\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block,\n\t\t\t&hib_resume_bdev);\n\tif (res < 0)\n\t\treturn res;\n\n\troot_swap = res;\n\tres = blkdev_get(hib_resume_bdev, FMODE_WRITE, NULL);\n\tif (res)\n\t\treturn res;\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\t/*\n\t * Update the resume device to the one actually used,\n\t * so the test_resume mode can use it in case it is\n\t * invoked from hibernate() to test the snapshot.\n\t */\n\tswsusp_resume_device = hib_resume_bdev->bd_dev;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\n\nstatic int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(FMODE_WRITE);\n\treturn ret;\n}"
  },
  {
    "function_name": "release_swap_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "404-409",
    "snippet": "static void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)handle->cur"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}"
  },
  {
    "function_name": "write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "370-402",
    "snippet": "static int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -ENOSPC;\n\n\tif (hb) {\n\t\tsrc = (void *)__get_free_page(GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_io(hb); /* Free pages */\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\thb = NULL;\t/* Go synchronous */\n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_submit_io(REQ_OP_WRITE, REQ_SYNC, offset, src, hb);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "offset",
            "src",
            "hb"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "265-295",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page",
          "args": [
            "src",
            "buf"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "safe_copy_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1340-1349",
          "snippet": "static void safe_copy_page(void *dst, struct page *s_page)\n{\n\tif (kernel_page_present(s_page)) {\n\t\tdo_copy_page(dst, page_address(s_page));\n\t} else {\n\t\tkernel_map_pages(s_page, 1, 1);\n\t\tdo_copy_page(dst, page_address(s_page));\n\t\tkernel_map_pages(s_page, 1, 0);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\n\nstatic void safe_copy_page(void *dst, struct page *s_page)\n{\n\tif (kernel_page_present(s_page)) {\n\t\tdo_copy_page(dst, page_address(s_page));\n\t} else {\n\t\tkernel_map_pages(s_page, 1, 1);\n\t\tdo_copy_page(dst, page_address(s_page));\n\t\tkernel_map_pages(s_page, 1, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_wait_io",
          "args": [
            "hb"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "hib_wait_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "297-301",
          "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -ENOSPC;\n\n\tif (hb) {\n\t\tsrc = (void *)__get_free_page(GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_io(hb); /* Free pages */\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\thb = NULL;\t/* Go synchronous */\n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_submit_io(REQ_OP_WRITE, REQ_SYNC, offset, src, hb);\n}"
  },
  {
    "function_name": "swsusp_swap_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "336-361",
    "snippet": "static int swsusp_swap_check(void)\n{\n\tint res;\n\n\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block,\n\t\t\t&hib_resume_bdev);\n\tif (res < 0)\n\t\treturn res;\n\n\troot_swap = res;\n\tres = blkdev_get(hib_resume_bdev, FMODE_WRITE, NULL);\n\tif (res)\n\t\treturn res;\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\t/*\n\t * Update the resume device to the one actually used,\n\t * so the test_resume mode can use it in case it is\n\t * invoked from hibernate() to test the snapshot.\n\t */\n\tswsusp_resume_device = hib_resume_bdev->bd_dev;\n\treturn res;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short root_swap = 0xffff;",
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "hib_resume_bdev",
            "FMODE_WRITE"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "hib_resume_bdev",
            "PAGE_SIZE"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "hib_resume_bdev",
            "FMODE_WRITE",
            "NULL"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_type_of",
          "args": [
            "swsusp_resume_device",
            "swsusp_resume_block",
            "&hib_resume_bdev"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic unsigned short root_swap = 0xffff;\nstatic struct block_device *hib_resume_bdev;\n\nstatic int swsusp_swap_check(void)\n{\n\tint res;\n\n\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block,\n\t\t\t&hib_resume_bdev);\n\tif (res < 0)\n\t\treturn res;\n\n\troot_swap = res;\n\tres = blkdev_get(hib_resume_bdev, FMODE_WRITE, NULL);\n\tif (res)\n\t\treturn res;\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, FMODE_WRITE);\n\n\t/*\n\t * Update the resume device to the one actually used,\n\t * so the test_resume mode can use it in case it is\n\t * invoked from hibernate() to test the snapshot.\n\t */\n\tswsusp_resume_device = hib_resume_bdev->bd_dev;\n\treturn res;\n}"
  },
  {
    "function_name": "mark_swapfiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "307-328",
    "snippet": "static int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIBERNATE_SIG\t\"S1SUSPEND\""
    ],
    "globals_used": [
      "static struct swsusp_header *swsusp_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Swap header not found!\\n\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hib_submit_io",
          "args": [
            "REQ_OP_WRITE",
            "REQ_SYNC",
            "swsusp_resume_block",
            "swsusp_header",
            "NULL"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "hib_submit_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "265-295",
          "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "swsusp_header->sig",
            "HIBERNATE_SIG",
            "10"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"SWAPSPACE2\"",
            "swsusp_header->sig",
            "10"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"SWAP-SPACE\"",
            "swsusp_header->sig",
            "10"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "hib_wait_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "297-301",
    "snippet": "static blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "hb->error"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "hb->wait",
            "atomic_read(&hb->count) == 0"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&hb->count"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic blk_status_t hib_wait_io(struct hib_bio_batch *hb)\n{\n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}"
  },
  {
    "function_name": "hib_submit_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "265-295",
    "snippet": "static int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct block_device *hib_resume_bdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "bio"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&hb->count"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Adding page to bio failed at %llu\\n\"",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_op_attrs",
          "args": [
            "bio",
            "op",
            "op_flags"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "hib_resume_bdev"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO | __GFP_HIGH",
            "1"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nstatic int hib_submit_io(int op, int op_flags, pgoff_t page_off, void *addr,\n\t\tstruct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(GFP_NOIO | __GFP_HIGH, 1);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\tbio_set_dev(bio, hib_resume_bdev);\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "hib_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "240-263",
    "snippet": "static void hib_end_io(struct bio *bio)\n{\n\tstruct hib_bio_batch *hb = bio->bi_private;\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%Lu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t}\n\n\tif (bio_data_dir(bio) == WRITE)\n\t\tput_page(page);\n\telse if (clean_pages_on_read)\n\t\tflush_icache_range((unsigned long)page_address(page),\n\t\t\t\t   (unsigned long)page_address(page) + PAGE_SIZE);\n\n\tif (bio->bi_status && !hb->error)\n\t\thb->error = bio->bi_status;\n\tif (atomic_dec_and_test(&hb->count))\n\t\twake_up(&hb->wait);\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool clean_pages_on_read;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&hb->wait"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&hb->count"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)page_address(page)",
            "(unsigned long)page_address(page) + PAGE_SIZE"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_data_dir",
          "args": [
            "bio"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Read-error on swap-device (%u:%u:%Lu)\\n\"",
            "MAJOR(bio_dev(bio))",
            "MINOR(bio_dev(bio))",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_first_page_all",
          "args": [
            "bio"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic bool clean_pages_on_read;\n\nstatic void hib_end_io(struct bio *bio)\n{\n\tstruct hib_bio_batch *hb = bio->bi_private;\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%Lu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t}\n\n\tif (bio_data_dir(bio) == WRITE)\n\t\tput_page(page);\n\telse if (clean_pages_on_read)\n\t\tflush_icache_range((unsigned long)page_address(page),\n\t\t\t\t   (unsigned long)page_address(page) + PAGE_SIZE);\n\n\tif (bio->bi_status && !hb->error)\n\t\thb->error = bio->bi_status;\n\tif (atomic_dec_and_test(&hb->count))\n\t\twake_up(&hb->wait);\n\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "hib_init_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "233-238",
    "snippet": "static void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&hb->wait"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&hb->count",
            "0"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n}"
  },
  {
    "function_name": "swsusp_swap_in_use",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "215-218",
    "snippet": "int swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root swsusp_extents = RB_ROOT;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nint swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}"
  },
  {
    "function_name": "free_all_swap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "198-213",
    "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root swsusp_extents = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_free",
          "args": [
            "swp_entry(swap, offset)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "swap",
            "offset"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&swsusp_extents"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structswsusp_extent",
            "node"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
  },
  {
    "function_name": "alloc_swapdev_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "178-190",
    "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swapdev_block",
          "args": [
            "swap",
            "offset"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_free",
          "args": [
            "swp_entry(swap, offset)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "swap",
            "offset"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_extents_insert",
          "args": [
            "offset"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_extents_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "132-171",
          "snippet": "static int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nstatic int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "get_swap_page_of_type(swap)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_swap_page_of_type",
          "args": [
            "swap"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "swsusp_extents_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "132-171",
    "snippet": "static int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root swsusp_extents = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&ext->node",
            "&swsusp_extents"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&ext->node",
            "parent",
            "new"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct swsusp_extent)",
            "GFP_KERNEL"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structswsusp_extent",
            "node"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nstatic int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t/* Figure out where to put the new node */\n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t/* Try to merge */\n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t/* It already is in the tree */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Add the new node and rebalance the tree. */\n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}"
  },
  {
    "function_name": "reqd_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "77-80",
    "snippet": "static inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "low_free_pages",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "low_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}"
  },
  {
    "function_name": "low_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
    "lines": "68-71",
    "snippet": "static inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/ktime.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/atomic.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/lzo.h>",
      "#include <linux/slab.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/device.h>",
      "#include <linux/genhd.h>",
      "#include <linux/bitops.h>",
      "#include <linux/delay.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_highpages",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_pages",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}"
  }
]