[
  {
    "function_name": "irq_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "253-272",
    "snippet": "static int __init irq_debugfs_init(void)\n{\n\tstruct dentry *root_dir;\n\tint irq;\n\n\troot_dir = debugfs_create_dir(\"irq\", NULL);\n\tif (!root_dir)\n\t\treturn -ENOMEM;\n\n\tirq_domain_debugfs_init(root_dir);\n\n\tirq_dir = debugfs_create_dir(\"irqs\", root_dir);\n\n\tirq_lock_sparse();\n\tfor_each_active_irq(irq)\n\t\tirq_add_debugfs_entry(irq, irq_to_desc(irq));\n\tirq_unlock_sparse();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_unlock_sparse",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "irq_unlock_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "367-370",
          "snippet": "void irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_unlock_sparse(void)\n{\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_lock_sparse",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "irq_lock_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "362-365",
          "snippet": "void irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_lock_sparse(void)\n{\n\tmutex_lock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"irqs\"",
            "root_dir"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_debugfs_init",
          "args": [
            "root_dir"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "467-469",
          "snippet": "static inline void irq_domain_debugfs_init(struct dentry *root)\n{\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irq_domain_debugfs_init(struct dentry *root)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"irq\"",
            "NULL"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic struct dentry *irq_dir;\n\nstatic int __init irq_debugfs_init(void)\n{\n\tstruct dentry *root_dir;\n\tint irq;\n\n\troot_dir = debugfs_create_dir(\"irq\", NULL);\n\tif (!root_dir)\n\t\treturn -ENOMEM;\n\n\tirq_domain_debugfs_init(root_dir);\n\n\tirq_dir = debugfs_create_dir(\"irqs\", root_dir);\n\n\tirq_lock_sparse();\n\tfor_each_active_irq(irq)\n\t\tirq_add_debugfs_entry(irq, irq_to_desc(irq));\n\tirq_unlock_sparse();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_add_debugfs_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "241-251",
    "snippet": "void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [10];\n\n\tif (!irq_dir || !desc || desc->debugfs_file)\n\t\treturn;\n\n\tsprintf(name, \"%d\", irq);\n\tdesc->debugfs_file = debugfs_create_file(name, 0644, irq_dir, desc,\n\t\t\t\t\t\t &dfs_irq_ops);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *irq_dir;",
      "static const struct file_operations dfs_irq_ops = {\n\t.open\t\t= irq_debug_open,\n\t.write\t\t= irq_debug_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "name",
            "0644",
            "irq_dir",
            "desc",
            "&dfs_irq_ops"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%d\"",
            "irq"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic struct dentry *irq_dir;\nstatic const struct file_operations dfs_irq_ops = {\n\t.open\t\t= irq_debug_open,\n\t.write\t\t= irq_debug_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nvoid irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [10];\n\n\tif (!irq_dir || !desc || desc->debugfs_file)\n\t\treturn;\n\n\tsprintf(name, \"%d\", irq);\n\tdesc->debugfs_file = debugfs_create_file(name, 0644, irq_dir, desc,\n\t\t\t\t\t\t &dfs_irq_ops);\n}"
  },
  {
    "function_name": "irq_debugfs_copy_devname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "232-239",
    "snippet": "void irq_debugfs_copy_devname(int irq, struct device *dev)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tconst char *name = dev_name(dev);\n\n\tif (name)\n\t\tdesc->dev_name = kstrdup(name, GFP_KERNEL);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nvoid irq_debugfs_copy_devname(int irq, struct device *dev)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tconst char *name = dev_name(dev);\n\n\tif (name)\n\t\tdesc->dev_name = kstrdup(name, GFP_KERNEL);\n}"
  },
  {
    "function_name": "irq_debug_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "178-222",
    "snippet": "static ssize_t irq_debug_write(struct file *file, const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct irq_desc *desc = file_inode(file)->i_private;\n\tchar buf[8] = { 0, };\n\tsize_t size;\n\n\tsize = min(sizeof(buf) - 1, count);\n\tif (copy_from_user(buf, user_buf, size))\n\t\treturn -EFAULT;\n\n\tif (!strncmp(buf, \"trigger\", size)) {\n\t\tunsigned long flags;\n\t\tint err;\n\n\t\t/* Try the HW interface first */\n\t\terr = irq_set_irqchip_state(irq_desc_get_irq(desc),\n\t\t\t\t\t    IRQCHIP_STATE_PENDING, true);\n\t\tif (!err)\n\t\t\treturn count;\n\n\t\t/*\n\t\t * Otherwise, try to inject via the resend interface,\n\t\t * which may or may not succeed.\n\t\t */\n\t\tchip_bus_lock(desc);\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tif (irq_settings_is_level(desc)) {\n\t\t\t/* Can't do level, sorry */\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tdesc->istate |= IRQS_PENDING;\n\t\t\tcheck_irq_resend(desc);\n\t\t\terr = 0;\n\t\t}\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\tchip_bus_sync_unlock(desc);\n\n\t\treturn err ? err : count;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip_bus_sync_unlock",
          "args": [
            "desc"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_sync_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "144-148",
          "snippet": "static inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_resend",
          "args": [
            "desc"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_resend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/resend.c",
          "lines": "55-100",
          "snippet": "void check_irq_resend(struct irq_desc *desc)\n{\n\t/*\n\t * We do not resend level type interrupts. Level type\n\t * interrupts are resent by hardware when they are still\n\t * active. Clear the pending bit so suspend/resume does not\n\t * get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn;\n\t}\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn;\n\tif (desc->istate & IRQS_PENDING) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\tdesc->istate |= IRQS_REPLAY;\n\n\t\tif (!desc->irq_data.chip->irq_retrigger ||\n\t\t    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {\n#ifdef CONFIG_HARDIRQS_SW_RESEND\n\t\t\tunsigned int irq = irq_desc_get_irq(desc);\n\n\t\t\t/*\n\t\t\t * If the interrupt is running in the thread\n\t\t\t * context of the parent irq we need to be\n\t\t\t * careful, because we cannot trigger it\n\t\t\t * directly.\n\t\t\t */\n\t\t\tif (irq_settings_is_nested_thread(desc)) {\n\t\t\t\t/*\n\t\t\t\t * If the parent_irq is valid, we\n\t\t\t\t * retrigger the parent, otherwise we\n\t\t\t\t * do nothing.\n\t\t\t\t */\n\t\t\t\tif (!desc->parent_irq)\n\t\t\t\t\treturn;\n\t\t\t\tirq = desc->parent_irq;\n\t\t\t}\n\t\t\t/* Set it pending and activate the softirq: */\n\t\t\tset_bit(irq, irqs_resend);\n\t\t\ttasklet_schedule(&resend_tasklet);\n#endif\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid check_irq_resend(struct irq_desc *desc)\n{\n\t/*\n\t * We do not resend level type interrupts. Level type\n\t * interrupts are resent by hardware when they are still\n\t * active. Clear the pending bit so suspend/resume does not\n\t * get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn;\n\t}\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn;\n\tif (desc->istate & IRQS_PENDING) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\tdesc->istate |= IRQS_REPLAY;\n\n\t\tif (!desc->irq_data.chip->irq_retrigger ||\n\t\t    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {\n#ifdef CONFIG_HARDIRQS_SW_RESEND\n\t\t\tunsigned int irq = irq_desc_get_irq(desc);\n\n\t\t\t/*\n\t\t\t * If the interrupt is running in the thread\n\t\t\t * context of the parent irq we need to be\n\t\t\t * careful, because we cannot trigger it\n\t\t\t * directly.\n\t\t\t */\n\t\t\tif (irq_settings_is_nested_thread(desc)) {\n\t\t\t\t/*\n\t\t\t\t * If the parent_irq is valid, we\n\t\t\t\t * retrigger the parent, otherwise we\n\t\t\t\t * do nothing.\n\t\t\t\t */\n\t\t\t\tif (!desc->parent_irq)\n\t\t\t\t\treturn;\n\t\t\t\tirq = desc->parent_irq;\n\t\t\t}\n\t\t\t/* Set it pending and activate the softirq: */\n\t\t\tset_bit(irq, irqs_resend);\n\t\t\ttasklet_schedule(&resend_tasklet);\n#endif\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_level",
          "args": [
            "desc"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/settings.h",
          "lines": "81-84",
          "snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_lock",
          "args": [
            "desc"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "138-142",
          "snippet": "static inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_irqchip_state",
          "args": [
            "irq_desc_get_irq(desc)",
            "IRQCHIP_STATE_PENDING",
            "true"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_irqchip_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "2230-2261",
          "snippet": "int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"trigger\"",
            "size"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "user_buf",
            "size"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sizeof(buf) - 1",
            "count"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic ssize_t irq_debug_write(struct file *file, const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct irq_desc *desc = file_inode(file)->i_private;\n\tchar buf[8] = { 0, };\n\tsize_t size;\n\n\tsize = min(sizeof(buf) - 1, count);\n\tif (copy_from_user(buf, user_buf, size))\n\t\treturn -EFAULT;\n\n\tif (!strncmp(buf, \"trigger\", size)) {\n\t\tunsigned long flags;\n\t\tint err;\n\n\t\t/* Try the HW interface first */\n\t\terr = irq_set_irqchip_state(irq_desc_get_irq(desc),\n\t\t\t\t\t    IRQCHIP_STATE_PENDING, true);\n\t\tif (!err)\n\t\t\treturn count;\n\n\t\t/*\n\t\t * Otherwise, try to inject via the resend interface,\n\t\t * which may or may not succeed.\n\t\t */\n\t\tchip_bus_lock(desc);\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tif (irq_settings_is_level(desc)) {\n\t\t\t/* Can't do level, sorry */\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\tdesc->istate |= IRQS_PENDING;\n\t\t\tcheck_irq_resend(desc);\n\t\t\terr = 0;\n\t\t}\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\tchip_bus_sync_unlock(desc);\n\n\t\treturn err ? err : count;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "irq_debug_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "173-176",
    "snippet": "static int irq_debug_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_debug_show, inode->i_private);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "irq_debug_show",
            "inode->i_private"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic int irq_debug_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_debug_show, inode->i_private);\n}"
  },
  {
    "function_name": "irq_debug_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "146-171",
    "snippet": "static int irq_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_desc *desc = m->private;\n\tstruct irq_data *data;\n\n\traw_spin_lock_irq(&desc->lock);\n\tdata = irq_desc_get_irq_data(desc);\n\tseq_printf(m, \"handler:  %pf\\n\", desc->handle_irq);\n\tseq_printf(m, \"device:   %s\\n\", desc->dev_name);\n\tseq_printf(m, \"status:   0x%08x\\n\", desc->status_use_accessors);\n\tirq_debug_show_bits(m, 0, desc->status_use_accessors, irqdesc_states,\n\t\t\t    ARRAY_SIZE(irqdesc_states));\n\tseq_printf(m, \"istate:   0x%08x\\n\", desc->istate);\n\tirq_debug_show_bits(m, 0, desc->istate, irqdesc_istates,\n\t\t\t    ARRAY_SIZE(irqdesc_istates));\n\tseq_printf(m, \"ddepth:   %u\\n\", desc->depth);\n\tseq_printf(m, \"wdepth:   %u\\n\", desc->wake_depth);\n\tseq_printf(m, \"dstate:   0x%08x\\n\", irqd_get(data));\n\tirq_debug_show_bits(m, 0, irqd_get(data), irqdata_states,\n\t\t\t    ARRAY_SIZE(irqdata_states));\n\tseq_printf(m, \"node:     %d\\n\", irq_data_get_node(data));\n\tirq_debug_show_masks(m, desc);\n\tirq_debug_show_data(m, data, 0);\n\traw_spin_unlock_irq(&desc->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct irq_bit_descr irqdata_states[] = {\n\tBIT_MASK_DESCR(IRQ_TYPE_EDGE_RISING),\n\tBIT_MASK_DESCR(IRQ_TYPE_EDGE_FALLING),\n\tBIT_MASK_DESCR(IRQ_TYPE_LEVEL_HIGH),\n\tBIT_MASK_DESCR(IRQ_TYPE_LEVEL_LOW),\n\tBIT_MASK_DESCR(IRQD_LEVEL),\n\n\tBIT_MASK_DESCR(IRQD_ACTIVATED),\n\tBIT_MASK_DESCR(IRQD_IRQ_STARTED),\n\tBIT_MASK_DESCR(IRQD_IRQ_DISABLED),\n\tBIT_MASK_DESCR(IRQD_IRQ_MASKED),\n\tBIT_MASK_DESCR(IRQD_IRQ_INPROGRESS),\n\n\tBIT_MASK_DESCR(IRQD_PER_CPU),\n\tBIT_MASK_DESCR(IRQD_NO_BALANCING),\n\n\tBIT_MASK_DESCR(IRQD_SINGLE_TARGET),\n\tBIT_MASK_DESCR(IRQD_MOVE_PCNTXT),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_SET),\n\tBIT_MASK_DESCR(IRQD_SETAFFINITY_PENDING),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_MANAGED),\n\tBIT_MASK_DESCR(IRQD_MANAGED_SHUTDOWN),\n\tBIT_MASK_DESCR(IRQD_CAN_RESERVE),\n\n\tBIT_MASK_DESCR(IRQD_FORWARDED_TO_VCPU),\n\n\tBIT_MASK_DESCR(IRQD_WAKEUP_STATE),\n\tBIT_MASK_DESCR(IRQD_WAKEUP_ARMED),\n};",
      "static const struct irq_bit_descr irqdesc_states[] = {\n\tBIT_MASK_DESCR(_IRQ_NOPROBE),\n\tBIT_MASK_DESCR(_IRQ_NOREQUEST),\n\tBIT_MASK_DESCR(_IRQ_NOTHREAD),\n\tBIT_MASK_DESCR(_IRQ_NOAUTOEN),\n\tBIT_MASK_DESCR(_IRQ_NESTED_THREAD),\n\tBIT_MASK_DESCR(_IRQ_PER_CPU_DEVID),\n\tBIT_MASK_DESCR(_IRQ_IS_POLLED),\n\tBIT_MASK_DESCR(_IRQ_DISABLE_UNLAZY),\n};",
      "static const struct irq_bit_descr irqdesc_istates[] = {\n\tBIT_MASK_DESCR(IRQS_AUTODETECT),\n\tBIT_MASK_DESCR(IRQS_SPURIOUS_DISABLED),\n\tBIT_MASK_DESCR(IRQS_POLL_INPROGRESS),\n\tBIT_MASK_DESCR(IRQS_ONESHOT),\n\tBIT_MASK_DESCR(IRQS_REPLAY),\n\tBIT_MASK_DESCR(IRQS_WAITING),\n\tBIT_MASK_DESCR(IRQS_PENDING),\n\tBIT_MASK_DESCR(IRQS_SUSPENDED),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_debug_show_data",
          "args": [
            "m",
            "data",
            "0"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debug_show_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
          "lines": "76-91",
          "snippet": "static void\nirq_debug_show_data(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tseq_printf(m, \"%*sdomain:  %s\\n\", ind, \"\",\n\t\t   data->domain ? data->domain->name : \"\");\n\tseq_printf(m, \"%*shwirq:   0x%lx\\n\", ind + 1, \"\", data->hwirq);\n\tirq_debug_show_chip(m, data, ind + 1);\n\tif (data->domain && data->domain->ops && data->domain->ops->debug_show)\n\t\tdata->domain->ops->debug_show(m, NULL, data, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!data->parent_data)\n\t\treturn;\n\tseq_printf(m, \"%*sparent:\\n\", ind + 1, \"\");\n\tirq_debug_show_data(m, data->parent_data, ind + 4);\n#endif\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void\nirq_debug_show_data(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tseq_printf(m, \"%*sdomain:  %s\\n\", ind, \"\",\n\t\t   data->domain ? data->domain->name : \"\");\n\tseq_printf(m, \"%*shwirq:   0x%lx\\n\", ind + 1, \"\", data->hwirq);\n\tirq_debug_show_chip(m, data, ind + 1);\n\tif (data->domain && data->domain->ops && data->domain->ops->debug_show)\n\t\tdata->domain->ops->debug_show(m, NULL, data, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!data->parent_data)\n\t\treturn;\n\tseq_printf(m, \"%*sparent:\\n\", ind + 1, \"\");\n\tirq_debug_show_data(m, data->parent_data, ind + 4);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_debug_show_masks",
          "args": [
            "m",
            "desc"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debug_show_masks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
          "lines": "47-47",
          "snippet": "static void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc) { }",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc) { }"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"node:     %d\\n\"",
            "irq_data_get_node(data)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_node",
          "args": [
            "data"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_debug_show_bits",
          "args": [
            "m",
            "0",
            "irqd_get(data)",
            "irqdata_states",
            "ARRAY_SIZE(irqdata_states)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debug_show_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
          "lines": "18-27",
          "snippet": "static void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "irqdata_states"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_get",
          "args": [
            "data"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "190-193",
          "snippet": "static inline unsigned int irqd_get(struct irq_data *d)\n{\n\treturn __irqd_to_state(d);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline unsigned int irqd_get(struct irq_data *d)\n{\n\treturn __irqd_to_state(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "irqdesc_istates"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "irqdesc_states"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic const struct irq_bit_descr irqdata_states[] = {\n\tBIT_MASK_DESCR(IRQ_TYPE_EDGE_RISING),\n\tBIT_MASK_DESCR(IRQ_TYPE_EDGE_FALLING),\n\tBIT_MASK_DESCR(IRQ_TYPE_LEVEL_HIGH),\n\tBIT_MASK_DESCR(IRQ_TYPE_LEVEL_LOW),\n\tBIT_MASK_DESCR(IRQD_LEVEL),\n\n\tBIT_MASK_DESCR(IRQD_ACTIVATED),\n\tBIT_MASK_DESCR(IRQD_IRQ_STARTED),\n\tBIT_MASK_DESCR(IRQD_IRQ_DISABLED),\n\tBIT_MASK_DESCR(IRQD_IRQ_MASKED),\n\tBIT_MASK_DESCR(IRQD_IRQ_INPROGRESS),\n\n\tBIT_MASK_DESCR(IRQD_PER_CPU),\n\tBIT_MASK_DESCR(IRQD_NO_BALANCING),\n\n\tBIT_MASK_DESCR(IRQD_SINGLE_TARGET),\n\tBIT_MASK_DESCR(IRQD_MOVE_PCNTXT),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_SET),\n\tBIT_MASK_DESCR(IRQD_SETAFFINITY_PENDING),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_MANAGED),\n\tBIT_MASK_DESCR(IRQD_MANAGED_SHUTDOWN),\n\tBIT_MASK_DESCR(IRQD_CAN_RESERVE),\n\n\tBIT_MASK_DESCR(IRQD_FORWARDED_TO_VCPU),\n\n\tBIT_MASK_DESCR(IRQD_WAKEUP_STATE),\n\tBIT_MASK_DESCR(IRQD_WAKEUP_ARMED),\n};\nstatic const struct irq_bit_descr irqdesc_states[] = {\n\tBIT_MASK_DESCR(_IRQ_NOPROBE),\n\tBIT_MASK_DESCR(_IRQ_NOREQUEST),\n\tBIT_MASK_DESCR(_IRQ_NOTHREAD),\n\tBIT_MASK_DESCR(_IRQ_NOAUTOEN),\n\tBIT_MASK_DESCR(_IRQ_NESTED_THREAD),\n\tBIT_MASK_DESCR(_IRQ_PER_CPU_DEVID),\n\tBIT_MASK_DESCR(_IRQ_IS_POLLED),\n\tBIT_MASK_DESCR(_IRQ_DISABLE_UNLAZY),\n};\nstatic const struct irq_bit_descr irqdesc_istates[] = {\n\tBIT_MASK_DESCR(IRQS_AUTODETECT),\n\tBIT_MASK_DESCR(IRQS_SPURIOUS_DISABLED),\n\tBIT_MASK_DESCR(IRQS_POLL_INPROGRESS),\n\tBIT_MASK_DESCR(IRQS_ONESHOT),\n\tBIT_MASK_DESCR(IRQS_REPLAY),\n\tBIT_MASK_DESCR(IRQS_WAITING),\n\tBIT_MASK_DESCR(IRQS_PENDING),\n\tBIT_MASK_DESCR(IRQS_SUSPENDED),\n};\n\nstatic int irq_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_desc *desc = m->private;\n\tstruct irq_data *data;\n\n\traw_spin_lock_irq(&desc->lock);\n\tdata = irq_desc_get_irq_data(desc);\n\tseq_printf(m, \"handler:  %pf\\n\", desc->handle_irq);\n\tseq_printf(m, \"device:   %s\\n\", desc->dev_name);\n\tseq_printf(m, \"status:   0x%08x\\n\", desc->status_use_accessors);\n\tirq_debug_show_bits(m, 0, desc->status_use_accessors, irqdesc_states,\n\t\t\t    ARRAY_SIZE(irqdesc_states));\n\tseq_printf(m, \"istate:   0x%08x\\n\", desc->istate);\n\tirq_debug_show_bits(m, 0, desc->istate, irqdesc_istates,\n\t\t\t    ARRAY_SIZE(irqdesc_istates));\n\tseq_printf(m, \"ddepth:   %u\\n\", desc->depth);\n\tseq_printf(m, \"wdepth:   %u\\n\", desc->wake_depth);\n\tseq_printf(m, \"dstate:   0x%08x\\n\", irqd_get(data));\n\tirq_debug_show_bits(m, 0, irqd_get(data), irqdata_states,\n\t\t\t    ARRAY_SIZE(irqdata_states));\n\tseq_printf(m, \"node:     %d\\n\", irq_data_get_node(data));\n\tirq_debug_show_masks(m, desc);\n\tirq_debug_show_data(m, data, 0);\n\traw_spin_unlock_irq(&desc->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_debug_show_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "76-91",
    "snippet": "static void\nirq_debug_show_data(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tseq_printf(m, \"%*sdomain:  %s\\n\", ind, \"\",\n\t\t   data->domain ? data->domain->name : \"\");\n\tseq_printf(m, \"%*shwirq:   0x%lx\\n\", ind + 1, \"\", data->hwirq);\n\tirq_debug_show_chip(m, data, ind + 1);\n\tif (data->domain && data->domain->ops && data->domain->ops->debug_show)\n\t\tdata->domain->ops->debug_show(m, NULL, data, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!data->parent_data)\n\t\treturn;\n\tseq_printf(m, \"%*sparent:\\n\", ind + 1, \"\");\n\tirq_debug_show_data(m, data->parent_data, ind + 4);\n#endif\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_debug_show_data",
          "args": [
            "m",
            "data->parent_data",
            "ind + 4"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debug_show_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
          "lines": "76-91",
          "snippet": "static void\nirq_debug_show_data(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tseq_printf(m, \"%*sdomain:  %s\\n\", ind, \"\",\n\t\t   data->domain ? data->domain->name : \"\");\n\tseq_printf(m, \"%*shwirq:   0x%lx\\n\", ind + 1, \"\", data->hwirq);\n\tirq_debug_show_chip(m, data, ind + 1);\n\tif (data->domain && data->domain->ops && data->domain->ops->debug_show)\n\t\tdata->domain->ops->debug_show(m, NULL, data, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!data->parent_data)\n\t\treturn;\n\tseq_printf(m, \"%*sparent:\\n\", ind + 1, \"\");\n\tirq_debug_show_data(m, data->parent_data, ind + 4);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*sparent:\\n\"",
            "ind + 1",
            "\"\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->domain->ops->debug_show",
          "args": [
            "m",
            "NULL",
            "data",
            "ind + 1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_debug_show_chip",
          "args": [
            "m",
            "data",
            "ind + 1"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debug_show_chip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
          "lines": "61-74",
          "snippet": "static void\nirq_debug_show_chip(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tstruct irq_chip *chip = data->chip;\n\n\tif (!chip) {\n\t\tseq_printf(m, \"chip: None\\n\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"%*schip:    %s\\n\", ind, \"\", chip->name);\n\tseq_printf(m, \"%*sflags:   0x%lx\\n\", ind + 1, \"\", chip->flags);\n\tirq_debug_show_bits(m, ind, chip->flags, irqchip_flags,\n\t\t\t    ARRAY_SIZE(irqchip_flags));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct irq_bit_descr irqchip_flags[] = {\n\tBIT_MASK_DESCR(IRQCHIP_SET_TYPE_MASKED),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_IF_HANDLED),\n\tBIT_MASK_DESCR(IRQCHIP_MASK_ON_SUSPEND),\n\tBIT_MASK_DESCR(IRQCHIP_ONOFFLINE_ENABLED),\n\tBIT_MASK_DESCR(IRQCHIP_SKIP_SET_WAKE),\n\tBIT_MASK_DESCR(IRQCHIP_ONESHOT_SAFE),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_THREADED),\n\tBIT_MASK_DESCR(IRQCHIP_SUPPORTS_LEVEL_MSI),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic const struct irq_bit_descr irqchip_flags[] = {\n\tBIT_MASK_DESCR(IRQCHIP_SET_TYPE_MASKED),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_IF_HANDLED),\n\tBIT_MASK_DESCR(IRQCHIP_MASK_ON_SUSPEND),\n\tBIT_MASK_DESCR(IRQCHIP_ONOFFLINE_ENABLED),\n\tBIT_MASK_DESCR(IRQCHIP_SKIP_SET_WAKE),\n\tBIT_MASK_DESCR(IRQCHIP_ONESHOT_SAFE),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_THREADED),\n\tBIT_MASK_DESCR(IRQCHIP_SUPPORTS_LEVEL_MSI),\n};\n\nstatic void\nirq_debug_show_chip(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tstruct irq_chip *chip = data->chip;\n\n\tif (!chip) {\n\t\tseq_printf(m, \"chip: None\\n\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"%*schip:    %s\\n\", ind, \"\", chip->name);\n\tseq_printf(m, \"%*sflags:   0x%lx\\n\", ind + 1, \"\", chip->flags);\n\tirq_debug_show_bits(m, ind, chip->flags, irqchip_flags,\n\t\t\t    ARRAY_SIZE(irqchip_flags));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void\nirq_debug_show_data(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tseq_printf(m, \"%*sdomain:  %s\\n\", ind, \"\",\n\t\t   data->domain ? data->domain->name : \"\");\n\tseq_printf(m, \"%*shwirq:   0x%lx\\n\", ind + 1, \"\", data->hwirq);\n\tirq_debug_show_chip(m, data, ind + 1);\n\tif (data->domain && data->domain->ops && data->domain->ops->debug_show)\n\t\tdata->domain->ops->debug_show(m, NULL, data, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!data->parent_data)\n\t\treturn;\n\tseq_printf(m, \"%*sparent:\\n\", ind + 1, \"\");\n\tirq_debug_show_data(m, data->parent_data, ind + 4);\n#endif\n}"
  },
  {
    "function_name": "irq_debug_show_chip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "61-74",
    "snippet": "static void\nirq_debug_show_chip(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tstruct irq_chip *chip = data->chip;\n\n\tif (!chip) {\n\t\tseq_printf(m, \"chip: None\\n\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"%*schip:    %s\\n\", ind, \"\", chip->name);\n\tseq_printf(m, \"%*sflags:   0x%lx\\n\", ind + 1, \"\", chip->flags);\n\tirq_debug_show_bits(m, ind, chip->flags, irqchip_flags,\n\t\t\t    ARRAY_SIZE(irqchip_flags));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct irq_bit_descr irqchip_flags[] = {\n\tBIT_MASK_DESCR(IRQCHIP_SET_TYPE_MASKED),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_IF_HANDLED),\n\tBIT_MASK_DESCR(IRQCHIP_MASK_ON_SUSPEND),\n\tBIT_MASK_DESCR(IRQCHIP_ONOFFLINE_ENABLED),\n\tBIT_MASK_DESCR(IRQCHIP_SKIP_SET_WAKE),\n\tBIT_MASK_DESCR(IRQCHIP_ONESHOT_SAFE),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_THREADED),\n\tBIT_MASK_DESCR(IRQCHIP_SUPPORTS_LEVEL_MSI),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_debug_show_bits",
          "args": [
            "m",
            "ind",
            "chip->flags",
            "irqchip_flags",
            "ARRAY_SIZE(irqchip_flags)"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debug_show_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
          "lines": "18-27",
          "snippet": "static void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/irq.h>",
            "#include <linux/irqdomain.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "irqchip_flags"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*sflags:   0x%lx\\n\"",
            "ind + 1",
            "\"\"",
            "chip->flags"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic const struct irq_bit_descr irqchip_flags[] = {\n\tBIT_MASK_DESCR(IRQCHIP_SET_TYPE_MASKED),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_IF_HANDLED),\n\tBIT_MASK_DESCR(IRQCHIP_MASK_ON_SUSPEND),\n\tBIT_MASK_DESCR(IRQCHIP_ONOFFLINE_ENABLED),\n\tBIT_MASK_DESCR(IRQCHIP_SKIP_SET_WAKE),\n\tBIT_MASK_DESCR(IRQCHIP_ONESHOT_SAFE),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_THREADED),\n\tBIT_MASK_DESCR(IRQCHIP_SUPPORTS_LEVEL_MSI),\n};\n\nstatic void\nirq_debug_show_chip(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tstruct irq_chip *chip = data->chip;\n\n\tif (!chip) {\n\t\tseq_printf(m, \"chip: None\\n\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"%*schip:    %s\\n\", ind, \"\", chip->name);\n\tseq_printf(m, \"%*sflags:   0x%lx\\n\", ind + 1, \"\", chip->flags);\n\tirq_debug_show_bits(m, ind, chip->flags, irqchip_flags,\n\t\t\t    ARRAY_SIZE(irqchip_flags));\n}"
  },
  {
    "function_name": "irq_debug_show_masks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "47-47",
    "snippet": "static void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc) { }",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc) { }"
  },
  {
    "function_name": "irq_debug_show_masks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "30-45",
    "snippet": "static void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct cpumask *msk;\n\n\tmsk = irq_data_get_affinity_mask(data);\n\tseq_printf(m, \"affinity: %*pbl\\n\", cpumask_pr_args(msk));\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tmsk = irq_data_get_effective_affinity_mask(data);\n\tseq_printf(m, \"effectiv: %*pbl\\n\", cpumask_pr_args(msk));\n#endif\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\tmsk = desc->pending_mask;\n\tseq_printf(m, \"pending:  %*pbl\\n\", cpumask_pr_args(msk));\n#endif\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pending:  %*pbl\\n\"",
            "cpumask_pr_args(msk)"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "msk"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "msk"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_effective_affinity_mask",
          "args": [
            "data"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "msk"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_affinity_mask",
          "args": [
            "data"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct cpumask *msk;\n\n\tmsk = irq_data_get_affinity_mask(data);\n\tseq_printf(m, \"affinity: %*pbl\\n\", cpumask_pr_args(msk));\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tmsk = irq_data_get_effective_affinity_mask(data);\n\tseq_printf(m, \"effectiv: %*pbl\\n\", cpumask_pr_args(msk));\n#endif\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\tmsk = desc->pending_mask;\n\tseq_printf(m, \"pending:  %*pbl\\n\", cpumask_pr_args(msk));\n#endif\n}"
  },
  {
    "function_name": "irq_debug_show_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/debugfs.c",
    "lines": "18-27",
    "snippet": "static void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/irq.h>",
      "#include <linux/irqdomain.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*s%s\\n\"",
            "ind + 12",
            "\"\"",
            "sd->name"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\nstatic void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}"
  }
]