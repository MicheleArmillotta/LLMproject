[
  {
    "function_name": "arch_perf_have_user_stack_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "240-243",
    "snippet": "static inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "arch_perf_have_user_stack_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "233-236",
    "snippet": "static inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "put_recursion_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "226-230",
    "snippet": "static inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}"
  },
  {
    "function_name": "get_recursion_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "204-224",
    "snippet": "static inline int get_recursion_context(int *recursion)\n{\n\tint rctx;\n\n\tif (unlikely(in_nmi()))\n\t\trctx = 3;\n\telse if (in_irq())\n\t\trctx = 2;\n\telse if (in_softirq())\n\t\trctx = 1;\n\telse\n\t\trctx = 0;\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_softirq",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_nmi()"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int get_recursion_context(int *recursion)\n{\n\tint rctx;\n\n\tif (unlikely(in_nmi()))\n\t\trctx = 3;\n\telse if (in_irq())\n\t\trctx = 2;\n\telse if (in_softirq())\n\t\trctx = 1;\n\telse\n\t\trctx = 0;\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}"
  },
  {
    "function_name": "arch_perf_out_copy_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "189-199",
    "snippet": "static inline unsigned long\narch_perf_out_copy_user(void *dst, const void *src, unsigned long n)\n{\n\tunsigned long ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define arch_perf_out_copy_user arch_perf_out_copy_user"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user_inatomic",
          "args": [
            "dst",
            "src",
            "n"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\n#define arch_perf_out_copy_user arch_perf_out_copy_user\n\nstatic inline unsigned long\narch_perf_out_copy_user(void *dst, const void *src, unsigned long n)\n{\n\tunsigned long ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "memcpy_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "178-182",
    "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "memcpy_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "169-174",
    "snippet": "static inline unsigned long\nmemcpy_common(void *dst, const void *src, unsigned long n)\n{\n\tmemcpy(dst, src, n);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "n"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_common(void *dst, const void *src, unsigned long n)\n{\n\tmemcpy(dst, src, n);\n\treturn 0;\n}"
  },
  {
    "function_name": "__output_custom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "160-167",
    "snippet": "static inline unsigned long\n__output_custom(struct perf_output_handle *handle, perf_copy_f copy_func,\n\t\tconst void *buf, unsigned long len)\n{\n\tunsigned long orig_len = len;\n\t__DEFINE_OUTPUT_COPY_BODY(false, copy_func, handle->addr, buf,\n\t\t\t\t  orig_len - len, size)\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__DEFINE_OUTPUT_COPY_BODY",
          "args": [
            "false",
            "copy_func",
            "handle->addr",
            "buf",
            "orig_len - len",
            "size"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\n__output_custom(struct perf_output_handle *handle, perf_copy_f copy_func,\n\t\tconst void *buf, unsigned long len)\n{\n\tunsigned long orig_len = len;\n\t__DEFINE_OUTPUT_COPY_BODY(false, copy_func, handle->addr, buf,\n\t\t\t\t  orig_len - len, size)\n}"
  },
  {
    "function_name": "perf_aux_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "122-125",
    "snippet": "static inline unsigned long perf_aux_size(struct ring_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_aux_size(struct ring_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "perf_data_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "117-120",
    "snippet": "static inline unsigned long perf_data_size(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "rb"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "111-114",
          "snippet": "static inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_data_size(struct ring_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}"
  },
  {
    "function_name": "page_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "111-114",
    "snippet": "static inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct ring_buffer *rb)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "page_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "104-107",
    "snippet": "static inline int page_order(struct ring_buffer *rb)\n{\n\treturn rb->page_order;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct ring_buffer *rb)\n{\n\treturn rb->page_order;\n}"
  },
  {
    "function_name": "rb_has_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "86-89",
    "snippet": "static inline bool rb_has_aux(struct ring_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool rb_has_aux(struct ring_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}"
  },
  {
    "function_name": "rb_toggle_paused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "69-75",
    "snippet": "static inline void rb_toggle_paused(struct ring_buffer *rb, bool pause)\n{\n\tif (!pause && rb->nr_pages)\n\t\trb->paused = 0;\n\telse\n\t\trb->paused = 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline void rb_toggle_paused(struct ring_buffer *rb, bool pause)\n{\n\tif (!pause && rb->nr_pages)\n\t\trb->paused = 0;\n\telse\n\t\trb->paused = 1;\n}"
  },
  {
    "function_name": "rb_free_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
    "lines": "61-67",
    "snippet": "static inline void rb_free_rcu(struct rcu_head *rcu_head)\n{\n\tstruct ring_buffer *rb;\n\n\trb = container_of(rcu_head, struct ring_buffer, rcu_head);\n\trb_free(rb);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_free",
          "args": [
            "rb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "61-67",
          "snippet": "static inline void rb_free_rcu(struct rcu_head *rcu_head)\n{\n\tstruct ring_buffer *rb;\n\n\trb = container_of(rcu_head, struct ring_buffer, rcu_head);\n\trb_free(rb);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu_head",
            "structring_buffer",
            "rcu_head"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline void rb_free_rcu(struct rcu_head *rcu_head)\n{\n\tstruct ring_buffer *rb;\n\n\trb = container_of(rcu_head, struct ring_buffer, rcu_head);\n\trb_free(rb);\n}"
  }
]