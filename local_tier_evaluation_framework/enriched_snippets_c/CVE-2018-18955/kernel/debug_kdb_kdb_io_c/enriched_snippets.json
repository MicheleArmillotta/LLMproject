[
  {
    "function_name": "kdb_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "852-862",
    "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vkdb_printf",
          "args": [
            "KDB_MSGSRC_INTERNAL",
            "fmt",
            "ap"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "vkdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "552-850",
          "snippet": "int vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tstruct console *c = console_drivers;\n\tunsigned long uninitialized_var(flags);\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH)\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Clear the flag.\n\t\t\t */\n\t\t\tkdb_grepping_flag = 0;\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"\";\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tkdb_read(buf1, 2); /* '2' indicates to return\n\t\t\t\t    * immediately after getting one key. */\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t/* user hit something other than enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];",
            "int kdb_printf_cpu = -1;",
            "static char kdb_buffer[256];",
            "static char *next_avail = kdb_buffer;",
            "static int  size_avail;",
            "static int  suspend_grep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nchar kdb_prompt_str[CMD_BUFLEN];\nint kdb_printf_cpu = -1;\nstatic char kdb_buffer[256];\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tstruct console *c = console_drivers;\n\tunsigned long uninitialized_var(flags);\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH)\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Clear the flag.\n\t\t\t */\n\t\t\tkdb_grepping_flag = 0;\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"\";\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tkdb_read(buf1, 2); /* '2' indicates to return\n\t\t\t\t    * immediately after getting one key. */\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t/* user hit something other than enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
  },
  {
    "function_name": "vkdb_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "552-850",
    "snippet": "int vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tstruct console *c = console_drivers;\n\tunsigned long uninitialized_var(flags);\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH)\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Clear the flag.\n\t\t\t */\n\t\t\tkdb_grepping_flag = 0;\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"\";\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tkdb_read(buf1, 2); /* '2' indicates to return\n\t\t\t\t    * immediately after getting one key. */\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t/* user hit something other than enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char kdb_prompt_str[CMD_BUFLEN];",
      "int kdb_printf_cpu = -1;",
      "static char kdb_buffer[256];",
      "static char *next_avail = kdb_buffer;",
      "static int  size_avail;",
      "static int  suspend_grep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&kdb_printf_cpu",
            "old_cpu"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kdb_buffer"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kdb_buffer",
            "cphold"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_input_flush",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_input_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "469-488",
          "snippet": "static void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchrnul",
          "args": [
            "kdb_grep_string",
            "'\\n'"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getstr",
          "args": [
            "kdb_grep_string",
            "KDB_GREP_STRLEN",
            "kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \""
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "443-450",
          "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"SEARCHPROMPT\""
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "229-249",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "PAGER"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_SET",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_read",
          "args": [
            "buf1",
            "2"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "204-422",
          "snippet": "static char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s\"",
            "moreprompt"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->write",
          "args": [
            "c",
            "moreprompt",
            "strlen(moreprompt)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "*cp"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "PAGER"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\"",
            "kdb_buffer"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_get_level",
          "args": [
            "kdb_buffer"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->write",
          "args": [
            "c",
            "cp",
            "retlen - (cp - kdb_buffer)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "*cp2"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_msg_write",
          "args": [
            "cp",
            "retlen - (cp - kdb_buffer)"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_msg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/gdbstub.c",
          "lines": "198-232",
          "snippet": "void gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char gdbmsgbuf[BUFMAX + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_skip_headers",
          "args": [
            "kdb_buffer"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kdb_buffer",
            "cphold"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_search_string",
          "args": [
            "kdb_buffer",
            "kdb_grep_string"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_search_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "522-550",
          "snippet": "static int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp2",
            "kdb_prompt_str",
            "len"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "kdb_buffer",
            "'\\n'"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "next_avail",
            "size_avail",
            "fmt",
            "ap"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"LOGGING\"",
            "&logging"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "316-325",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&kdb_printf_cpu",
            "-1",
            "this_cpu"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nchar kdb_prompt_str[CMD_BUFLEN];\nint kdb_printf_cpu = -1;\nstatic char kdb_buffer[256];\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tstruct console *c = console_drivers;\n\tunsigned long uninitialized_var(flags);\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH)\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Clear the flag.\n\t\t\t */\n\t\t\tkdb_grepping_flag = 0;\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"\";\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tkdb_read(buf1, 2); /* '2' indicates to return\n\t\t\t\t    * immediately after getting one key. */\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t/* user hit something other than enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}"
  },
  {
    "function_name": "kdb_search_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "522-550",
    "snippet": "static int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "searchfor",
            "len2"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "firstchar"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searched+len1-len2",
            "searchfor",
            "len2"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searched",
            "searchfor",
            "len2"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "searchfor"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t/* not counting the newline at the end of \"searched\" */\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_input_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "469-488",
    "snippet": "static void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}"
  },
  {
    "function_name": "kdb_getstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "443-450",
    "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CMD_BUFLEN 256"
    ],
    "globals_used": [
      "char kdb_prompt_str[CMD_BUFLEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_read",
          "args": [
            "buffer",
            "bufsize"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "204-422",
          "snippet": "static char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "kdb_prompt_str"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "kdb_prompt_str",
            "prompt",
            "CMD_BUFLEN"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
  },
  {
    "function_name": "kdb_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "204-422",
    "snippet": "static char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CMD_BUFLEN 256"
    ],
    "globals_used": [
      "char kdb_prompt_str[CMD_BUFLEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_KGDB"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"kgdb\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_gdb_state_pass",
          "args": [
            "lastchar - 11"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_gdb_state_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "183-186",
          "snippet": "void kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_state *kdb_ks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nstatic struct kgdb_state *kdb_ks;\n\nvoid kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lastchar - 11",
            "\"$qSupported\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_KGDB"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"kgdb\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lastchar - 5",
            "\"$?#3f\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%c\"",
            "key"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_transition_check",
          "args": [
            "buffer"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_transition_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "35-50",
          "snippet": "static int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp+1",
            "tmpbuffer",
            "lastchar - cp"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cp",
            "p_tmp+len",
            "len_tmp-len + 1"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p_tmp"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "p_tmp+len_tmp",
            "cp",
            "lastchar-cp+1"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!kallsyms_symbol_next(p_tmp, i)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_symbol_next",
          "args": [
            "p_tmp",
            "i"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_symbol_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "228-244",
          "snippet": "int kallsyms_symbol_next(char *prefix_name, int flag)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrncpy(prefix_name, name, strlen(name)+1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kallsyms_symbol_next(char *prefix_name, int flag)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrncpy(prefix_name, name, strlen(name)+1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_symbol_complete",
          "args": [
            "p_tmp",
            "sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_symbol_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "186-216",
          "snippet": "int kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrcpy(ks_namebuf, name);\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nstatic char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];\n\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrcpy(ks_namebuf, name);\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "tmpbuffer",
            "' '"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuffer",
            "' '",
            "strlen(kdb_prompt_str) + (lastchar-buffer)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuffer",
            "' '",
            "strlen(kdb_prompt_str) + (lastchar-buffer)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_read_get_key",
          "args": [
            "buffer",
            "bufsize"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_read_get_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "52-171",
          "snippet": "static int kdb_read_get_key(char *buffer, size_t bufsize)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar escape_data[5];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *ped = escape_data;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_escape = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\t\tif (escape_delay == 2) {\n\t\t\t*ped = '\\0';\n\t\t\tped = escape_data;\n\t\t\t--escape_delay;\n\t\t}\n\t\tif (escape_delay == 1) {\n\t\t\tkey = *ped++;\n\t\t\tif (!*ped)\n\t\t\t\t--escape_delay;\n\t\t\tbreak;\n\t\t}\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\t--escape_delay;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bufsize <= 2) {\n\t\t\tif (key == '\\r')\n\t\t\t\tkey = '\\n';\n\t\t\t*buffer++ = key;\n\t\t\t*buffer = '\\0';\n\t\t\treturn -1;\n\t\t}\n\t\tif (escape_delay == 0 && key == '\\e') {\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t\tped = escape_data;\n\t\t\tf_escape = f;\n\t\t}\n\t\tif (escape_delay) {\n\t\t\t*ped++ = key;\n\t\t\tif (f_escape != f) {\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ped - escape_data == 1) {\n\t\t\t\t/* \\e */\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 2) {\n\t\t\t\t/* \\e<something> */\n\t\t\t\tif (key != '[')\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 3) {\n\t\t\t\t/* \\e[<something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tswitch (key) {\n\t\t\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\t\t\tmapkey = 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\t\t\tmapkey = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\t\t\tmapkey = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\t\t\tmapkey = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1': /* dropthrough */\n\t\t\t\tcase '3': /* dropthrough */\n\t\t\t\t/* \\e[<1,3,4>], may be home, del, end */\n\t\t\t\tcase '4':\n\t\t\t\t\tmapkey = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mapkey != -1) {\n\t\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 4) {\n\t\t\t\t/* \\e[<1,3,4><something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tif (key == '~') {\n\t\t\t\t\tswitch (escape_data[2]) {\n\t\t\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\t\t\tmapkey = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\t\t\tmapkey = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\t\t\tmapkey = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t}\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* A key to process */\n\t}\n\treturn key;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */",
            "#define ESCAPE_UDELAY 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n#define ESCAPE_UDELAY 1000\n\nstatic int kdb_read_get_key(char *buffer, size_t bufsize)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar escape_data[5];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *ped = escape_data;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_escape = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\t\tif (escape_delay == 2) {\n\t\t\t*ped = '\\0';\n\t\t\tped = escape_data;\n\t\t\t--escape_delay;\n\t\t}\n\t\tif (escape_delay == 1) {\n\t\t\tkey = *ped++;\n\t\t\tif (!*ped)\n\t\t\t\t--escape_delay;\n\t\t\tbreak;\n\t\t}\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\t--escape_delay;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bufsize <= 2) {\n\t\t\tif (key == '\\r')\n\t\t\t\tkey = '\\n';\n\t\t\t*buffer++ = key;\n\t\t\t*buffer = '\\0';\n\t\t\treturn -1;\n\t\t}\n\t\tif (escape_delay == 0 && key == '\\e') {\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t\tped = escape_data;\n\t\t\tf_escape = f;\n\t\t}\n\t\tif (escape_delay) {\n\t\t\t*ped++ = key;\n\t\t\tif (f_escape != f) {\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ped - escape_data == 1) {\n\t\t\t\t/* \\e */\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 2) {\n\t\t\t\t/* \\e<something> */\n\t\t\t\tif (key != '[')\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 3) {\n\t\t\t\t/* \\e[<something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tswitch (key) {\n\t\t\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\t\t\tmapkey = 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\t\t\tmapkey = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\t\t\tmapkey = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\t\t\tmapkey = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1': /* dropthrough */\n\t\t\t\tcase '3': /* dropthrough */\n\t\t\t\t/* \\e[<1,3,4>], may be home, del, end */\n\t\t\t\tcase '4':\n\t\t\t\t\tmapkey = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mapkey != -1) {\n\t\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 4) {\n\t\t\t\t/* \\e[<1,3,4><something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tif (key == '~') {\n\t\t\t\t\tswitch (escape_data[2]) {\n\t\t\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\t\t\tmapkey = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\t\t\tmapkey = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\t\t\tmapkey = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t}\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* A key to process */\n\t}\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"DTABCOUNT\"",
            "&dtab_count"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "316-325",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t/* Reserve space for newline\n\t\t\t\t\t\t * and null byte */\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: /* backspace */\n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: /* enter */\n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4: /* Del */\n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Home */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: /* End */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: /* Left */\n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: /* Down */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: /* Right */\n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: /* Up */\n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: /* Tab */\n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; /* reset output line number */\n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t/* The kgdb transition check will hide\n\t\t\t\t * printed characters if we think that\n\t\t\t\t * kgdb is connecting, until the check\n\t\t\t\t * fails */\n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Special escape to kgdb */\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}"
  },
  {
    "function_name": "kdb_read_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "52-171",
    "snippet": "static int kdb_read_get_key(char *buffer, size_t bufsize)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar escape_data[5];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *ped = escape_data;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_escape = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\t\tif (escape_delay == 2) {\n\t\t\t*ped = '\\0';\n\t\t\tped = escape_data;\n\t\t\t--escape_delay;\n\t\t}\n\t\tif (escape_delay == 1) {\n\t\t\tkey = *ped++;\n\t\t\tif (!*ped)\n\t\t\t\t--escape_delay;\n\t\t\tbreak;\n\t\t}\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\t--escape_delay;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bufsize <= 2) {\n\t\t\tif (key == '\\r')\n\t\t\t\tkey = '\\n';\n\t\t\t*buffer++ = key;\n\t\t\t*buffer = '\\0';\n\t\t\treturn -1;\n\t\t}\n\t\tif (escape_delay == 0 && key == '\\e') {\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t\tped = escape_data;\n\t\t\tf_escape = f;\n\t\t}\n\t\tif (escape_delay) {\n\t\t\t*ped++ = key;\n\t\t\tif (f_escape != f) {\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ped - escape_data == 1) {\n\t\t\t\t/* \\e */\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 2) {\n\t\t\t\t/* \\e<something> */\n\t\t\t\tif (key != '[')\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 3) {\n\t\t\t\t/* \\e[<something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tswitch (key) {\n\t\t\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\t\t\tmapkey = 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\t\t\tmapkey = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\t\t\tmapkey = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\t\t\tmapkey = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1': /* dropthrough */\n\t\t\t\tcase '3': /* dropthrough */\n\t\t\t\t/* \\e[<1,3,4>], may be home, del, end */\n\t\t\t\tcase '4':\n\t\t\t\t\tmapkey = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mapkey != -1) {\n\t\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 4) {\n\t\t\t\t/* \\e[<1,3,4><something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tif (key == '~') {\n\t\t\t\t\tswitch (escape_data[2]) {\n\t\t\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\t\t\tmapkey = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\t\t\tmapkey = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\t\t\tmapkey = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t}\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* A key to process */\n\t}\n\treturn key;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */",
      "#define ESCAPE_UDELAY 1000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "ESCAPE_UDELAY"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n#define ESCAPE_UDELAY 1000\n\nstatic int kdb_read_get_key(char *buffer, size_t bufsize)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY) /* 2 seconds worth of udelays */\n\tchar escape_data[5];\t/* longest vt100 escape sequence is 4 bytes */\n\tchar *ped = escape_data;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_escape = NULL;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t/* Reset NMI watchdog once per poll loop */\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\t\tif (escape_delay == 2) {\n\t\t\t*ped = '\\0';\n\t\t\tped = escape_data;\n\t\t\t--escape_delay;\n\t\t}\n\t\tif (escape_delay == 1) {\n\t\t\tkey = *ped++;\n\t\t\tif (!*ped)\n\t\t\t\t--escape_delay;\n\t\t\tbreak;\n\t\t}\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\t--escape_delay;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bufsize <= 2) {\n\t\t\tif (key == '\\r')\n\t\t\t\tkey = '\\n';\n\t\t\t*buffer++ = key;\n\t\t\t*buffer = '\\0';\n\t\t\treturn -1;\n\t\t}\n\t\tif (escape_delay == 0 && key == '\\e') {\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t\tped = escape_data;\n\t\t\tf_escape = f;\n\t\t}\n\t\tif (escape_delay) {\n\t\t\t*ped++ = key;\n\t\t\tif (f_escape != f) {\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ped - escape_data == 1) {\n\t\t\t\t/* \\e */\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 2) {\n\t\t\t\t/* \\e<something> */\n\t\t\t\tif (key != '[')\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 3) {\n\t\t\t\t/* \\e[<something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tswitch (key) {\n\t\t\t\tcase 'A': /* \\e[A, up arrow */\n\t\t\t\t\tmapkey = 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B': /* \\e[B, down arrow */\n\t\t\t\t\tmapkey = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C': /* \\e[C, right arrow */\n\t\t\t\t\tmapkey = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D': /* \\e[D, left arrow */\n\t\t\t\t\tmapkey = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1': /* dropthrough */\n\t\t\t\tcase '3': /* dropthrough */\n\t\t\t\t/* \\e[<1,3,4>], may be home, del, end */\n\t\t\t\tcase '4':\n\t\t\t\t\tmapkey = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mapkey != -1) {\n\t\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 4) {\n\t\t\t\t/* \\e[<1,3,4><something> */\n\t\t\t\tint mapkey = 0;\n\t\t\t\tif (key == '~') {\n\t\t\t\t\tswitch (escape_data[2]) {\n\t\t\t\t\tcase '1': /* \\e[1~, home */\n\t\t\t\t\t\tmapkey = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '3': /* \\e[3~, del */\n\t\t\t\t\t\tmapkey = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '4': /* \\e[4~, end */\n\t\t\t\t\t\tmapkey = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t}\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* A key to process */\n\t}\n\treturn key;\n}"
  },
  {
    "function_name": "kgdb_transition_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
    "lines": "35-50",
    "snippet": "static int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/kallsyms.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/delay.h>",
      "#include <linux/nmi.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/console.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ctype.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_KGDB"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"kgdb\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_gdb_state_pass",
          "args": [
            "buffer"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_gdb_state_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "183-186",
          "snippet": "void kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_state *kdb_ks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nstatic struct kgdb_state *kdb_ks;\n\nvoid kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s\"",
            "buffer"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  }
]