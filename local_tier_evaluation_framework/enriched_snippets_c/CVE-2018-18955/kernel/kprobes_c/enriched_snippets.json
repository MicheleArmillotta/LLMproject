[
  {
    "function_name": "debugfs_kprobe_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2528-2557",
    "snippet": "static int __init debugfs_kprobe_init(void)\n{\n\tstruct dentry *dir, *file;\n\tunsigned int value = 1;\n\n\tdir = debugfs_create_dir(\"kprobes\", NULL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tfile = debugfs_create_file(\"list\", 0400, dir, NULL,\n\t\t\t\t&debugfs_kprobes_operations);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"enabled\", 0600, dir,\n\t\t\t\t\t&value, &fops_kp);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"blacklist\", 0400, dir, NULL,\n\t\t\t\t&debugfs_kprobe_blacklist_ops);\n\tif (!file)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdebugfs_remove(dir);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "dir"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"blacklist\"",
            "0400",
            "dir",
            "NULL",
            "&debugfs_kprobe_blacklist_ops"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"enabled\"",
            "0600",
            "dir",
            "&value",
            "&fops_kp"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"list\"",
            "0400",
            "dir",
            "NULL",
            "&debugfs_kprobes_operations"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"kprobes\"",
            "NULL"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int __init debugfs_kprobe_init(void)\n{\n\tstruct dentry *dir, *file;\n\tunsigned int value = 1;\n\n\tdir = debugfs_create_dir(\"kprobes\", NULL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tfile = debugfs_create_file(\"list\", 0400, dir, NULL,\n\t\t\t\t&debugfs_kprobes_operations);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"enabled\", 0600, dir,\n\t\t\t\t\t&value, &fops_kp);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"blacklist\", 0400, dir, NULL,\n\t\t\t\t&debugfs_kprobe_blacklist_ops);\n\tif (!file)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdebugfs_remove(dir);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "write_enabled_file_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2489-2520",
    "snippet": "static ssize_t write_enabled_file_bool(struct file *file,\n\t       const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tint ret = 0;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\tswitch (buf[0]) {\n\tcase 'y':\n\tcase 'Y':\n\tcase '1':\n\t\tret = arm_all_kprobes();\n\t\tbreak;\n\tcase 'n':\n\tcase 'N':\n\tcase '0':\n\t\tret = disarm_all_kprobes();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disarm_all_kprobes",
          "args": [],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_all_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "2424-2468",
          "snippet": "static int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disarm %d out of %d probes\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disarm %d out of %d probes\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "user_buf",
            "buf_size"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "(sizeof(buf)-1)"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic ssize_t write_enabled_file_bool(struct file *file,\n\t       const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tint ret = 0;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\tswitch (buf[0]) {\n\tcase 'y':\n\tcase 'Y':\n\tcase '1':\n\t\tret = arm_all_kprobes();\n\t\tbreak;\n\tcase 'n':\n\tcase 'N':\n\tcase '0':\n\t\tret = disarm_all_kprobes();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}"
  },
  {
    "function_name": "read_enabled_file_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2475-2487",
    "snippet": "static ssize_t read_enabled_file_bool(struct file *file,\n\t       char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (!kprobes_all_disarmed)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "buf",
            "2"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic ssize_t read_enabled_file_bool(struct file *file,\n\t       char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (!kprobes_all_disarmed)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}"
  },
  {
    "function_name": "disarm_all_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2424-2468",
    "snippet": "static int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disarm %d out of %d probes\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_kprobe_optimizer",
          "args": [],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_kprobe_optimizer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "608-624",
          "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kprobes globally disabled\\n\""
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Kprobes globally disabled, but failed to disarm %d out of %d probes\\n\"",
            "errors",
            "total"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disarm_kprobe",
          "args": [
            "p",
            "false"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1068-1080",
          "snippet": "static int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_trampoline_kprobe",
          "args": [
            "p"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disarm %d out of %d probes\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "arm_all_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2378-2422",
    "snippet": "static int arm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are armed, just return */\n\tif (!kprobes_all_disarmed)\n\t\tgoto already_enabled;\n\n\t/*\n\t * optimize_kprobe() called by arm_kprobe() checks\n\t * kprobes_all_disarmed, so set kprobes_all_disarmed before\n\t * arm_kprobe.\n\t */\n\tkprobes_all_disarmed = false;\n\t/* Arming kprobes doesn't optimize kprobe itself */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Arm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p)) {\n\t\t\t\terr = arm_kprobe(p);\n\t\t\t\tif (err)  {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally enabled, but failed to arm %d out of %d probes\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally enabled\\n\");\n\nalready_enabled:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kprobes globally enabled\\n\""
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Kprobes globally enabled, but failed to arm %d out of %d probes\\n\"",
            "errors",
            "total"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "p"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1053-1065",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int arm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are armed, just return */\n\tif (!kprobes_all_disarmed)\n\t\tgoto already_enabled;\n\n\t/*\n\t * optimize_kprobe() called by arm_kprobe() checks\n\t * kprobes_all_disarmed, so set kprobes_all_disarmed before\n\t * arm_kprobe.\n\t */\n\tkprobes_all_disarmed = false;\n\t/* Arming kprobes doesn't optimize kprobe itself */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Arm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p)) {\n\t\t\t\terr = arm_kprobe(p);\n\t\t\t\tif (err)  {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally enabled, but failed to arm %d out of %d probes\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally enabled\\n\");\n\nalready_enabled:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_blacklist_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2366-2369",
    "snippet": "static int kprobe_blacklist_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open(filp, &kprobe_blacklist_seq_ops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "filp",
            "&kprobe_blacklist_seq_ops"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobe_blacklist_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open(filp, &kprobe_blacklist_seq_ops);\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2341-2357",
    "snippet": "static int kprobe_blacklist_seq_show(struct seq_file *m, void *v)\n{\n\tstruct kprobe_blacklist_entry *ent =\n\t\tlist_entry(v, struct kprobe_blacklist_entry, list);\n\n\t/*\n\t * If /proc/kallsyms is not showing kernel address, we won't\n\t * show them here either.\n\t */\n\tif (!kallsyms_show_value())\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", NULL, NULL,\n\t\t\t   (void *)ent->start_addr);\n\telse\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", (void *)ent->start_addr,\n\t\t\t   (void *)ent->end_addr, (void *)ent->start_addr);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%px-0x%px\\t%ps\\n\"",
            "(void *)ent->start_addr",
            "(void *)ent->end_addr",
            "(void *)ent->start_addr"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_show_value",
          "args": [],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_show_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "645-659",
          "snippet": "int kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structkprobe_blacklist_entry",
            "list"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobe_blacklist_seq_show(struct seq_file *m, void *v)\n{\n\tstruct kprobe_blacklist_entry *ent =\n\t\tlist_entry(v, struct kprobe_blacklist_entry, list);\n\n\t/*\n\t * If /proc/kallsyms is not showing kernel address, we won't\n\t * show them here either.\n\t */\n\tif (!kallsyms_show_value())\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", NULL, NULL,\n\t\t\t   (void *)ent->start_addr);\n\telse\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", (void *)ent->start_addr,\n\t\t\t   (void *)ent->end_addr, (void *)ent->start_addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2336-2339",
    "snippet": "static void *kprobe_blacklist_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &kprobe_blacklist, pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&kprobe_blacklist",
            "pos"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void *kprobe_blacklist_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &kprobe_blacklist, pos);\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2331-2334",
    "snippet": "static void *kprobe_blacklist_seq_start(struct seq_file *m, loff_t *pos)\n{\n\treturn seq_list_start(&kprobe_blacklist, *pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&kprobe_blacklist",
            "*pos"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void *kprobe_blacklist_seq_start(struct seq_file *m, loff_t *pos)\n{\n\treturn seq_list_start(&kprobe_blacklist, *pos);\n}"
  },
  {
    "function_name": "kprobes_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2318-2321",
    "snippet": "static int kprobes_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open(filp, &kprobes_seq_ops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "filp",
            "&kprobes_seq_ops"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobes_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open(filp, &kprobes_seq_ops);\n}"
  },
  {
    "function_name": "show_kprobe_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2287-2309",
    "snippet": "static int show_kprobe_addr(struct seq_file *pi, void *v)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p, *kp;\n\tconst char *sym = NULL;\n\tunsigned int i = *(loff_t *) v;\n\tunsigned long offset = 0;\n\tchar *modname, namebuf[KSYM_NAME_LEN];\n\n\thead = &kprobe_table[i];\n\tpreempt_disable();\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tsym = kallsyms_lookup((unsigned long)p->addr, NULL,\n\t\t\t\t\t&offset, &modname, namebuf);\n\t\tif (kprobe_aggrprobe(p)) {\n\t\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\t\treport_probe(pi, kp, sym, offset, modname, p);\n\t\t} else\n\t\t\treport_probe(pi, p, sym, offset, modname, NULL);\n\t}\n\tpreempt_enable();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_probe",
          "args": [
            "pi",
            "p",
            "sym",
            "offset",
            "modname",
            "NULL"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "report_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "2238-2267",
          "snippet": "static void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value())\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value())\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "(unsigned long)p->addr",
            "NULL",
            "&offset",
            "&modname",
            "namebuf"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\n\nstatic int show_kprobe_addr(struct seq_file *pi, void *v)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p, *kp;\n\tconst char *sym = NULL;\n\tunsigned int i = *(loff_t *) v;\n\tunsigned long offset = 0;\n\tchar *modname, namebuf[KSYM_NAME_LEN];\n\n\thead = &kprobe_table[i];\n\tpreempt_disable();\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tsym = kallsyms_lookup((unsigned long)p->addr, NULL,\n\t\t\t\t\t&offset, &modname, namebuf);\n\t\tif (kprobe_aggrprobe(p)) {\n\t\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\t\treport_probe(pi, kp, sym, offset, modname, p);\n\t\t} else\n\t\t\treport_probe(pi, p, sym, offset, modname, NULL);\n\t}\n\tpreempt_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2282-2285",
    "snippet": "static void kprobe_seq_stop(struct seq_file *f, void *v)\n{\n\t/* Nothing to do */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kprobe_seq_stop(struct seq_file *f, void *v)\n{\n\t/* Nothing to do */\n}"
  },
  {
    "function_name": "kprobe_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2274-2280",
    "snippet": "static void *kprobe_seq_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= KPROBE_TABLE_SIZE)\n\t\treturn NULL;\n\treturn pos;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic void *kprobe_seq_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= KPROBE_TABLE_SIZE)\n\t\treturn NULL;\n\treturn pos;\n}"
  },
  {
    "function_name": "kprobe_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2269-2272",
    "snippet": "static void *kprobe_seq_start(struct seq_file *f, loff_t *pos)\n{\n\treturn (*pos < KPROBE_TABLE_SIZE) ? pos : NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic void *kprobe_seq_start(struct seq_file *f, loff_t *pos)\n{\n\treturn (*pos < KPROBE_TABLE_SIZE) ? pos : NULL;\n}"
  },
  {
    "function_name": "report_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2238-2267",
    "snippet": "static void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value())\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "pi",
            "\"%s%s%s%s\\n\"",
            "(kprobe_gone(p) ? \"[GONE]\" : \"\")",
            "((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\")",
            "(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\")",
            "(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\")"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "pp"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1028-1045",
          "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optimized",
          "args": [
            "pp"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_show_value",
          "args": [],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_show_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "645-659",
          "snippet": "int kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_show_value(void)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn 1;\n\t/* fallthrough */\n\tcase 1:\n\t\tif (has_capability_noaudit(current, CAP_SYSLOG))\n\t\t\treturn 1;\n\t/* fallthrough */\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value())\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}"
  },
  {
    "function_name": "init_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2182-2235",
    "snippet": "static int __init init_kprobes(void)\n{\n\tint i, err = 0;\n\n\t/* FIXME allocate the probe table, currently defined statically */\n\t/* initialize all list heads */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\tINIT_HLIST_HEAD(&kprobe_table[i]);\n\t\tINIT_HLIST_HEAD(&kretprobe_inst_table[i]);\n\t\traw_spin_lock_init(&(kretprobe_table_locks[i].lock));\n\t}\n\n\terr = populate_kprobe_blacklist(__start_kprobe_blacklist,\n\t\t\t\t\t__stop_kprobe_blacklist);\n\tif (err) {\n\t\tpr_err(\"kprobes: failed to populate blacklist: %d\\n\", err);\n\t\tpr_err(\"Please take care of using kprobes.\\n\");\n\t}\n\n\tif (kretprobe_blacklist_size) {\n\t\t/* lookup the function address from its name */\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tkretprobe_blacklist[i].addr =\n\t\t\t\tkprobe_lookup_name(kretprobe_blacklist[i].name, 0);\n\t\t\tif (!kretprobe_blacklist[i].addr)\n\t\t\t\tprintk(\"kretprobe: lookup failed: %s\\n\",\n\t\t\t\t       kretprobe_blacklist[i].name);\n\t\t}\n\t}\n\n#if defined(CONFIG_OPTPROBES)\n#if defined(__ARCH_WANT_KPROBES_INSN_SLOT)\n\t/* Init kprobe_optinsn_slots */\n\tkprobe_optinsn_slots.insn_size = MAX_OPTINSN_SIZE;\n#endif\n\t/* By default, kprobes can be optimized */\n\tkprobes_allow_optimization = true;\n#endif\n\n\t/* By default, kprobes are armed */\n\tkprobes_all_disarmed = false;\n\n\terr = arch_init_kprobes();\n\tif (!err)\n\t\terr = register_die_notifier(&kprobe_exceptions_nb);\n\tif (!err)\n\t\terr = register_module_notifier(&kprobe_module_nb);\n\n\tkprobes_initialized = (err == 0);\n\n\tif (!err)\n\t\tinit_test_probes();\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static int kprobes_initialized;",
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];",
      "static struct notifier_block kprobe_exceptions_nb = {\n\t.notifier_call = kprobe_exceptions_notify,\n\t.priority = 0x7fffffff /* we need to be notified first */\n};",
      "static struct notifier_block kprobe_module_nb = {\n\t.notifier_call = kprobes_module_callback,\n\t.priority = 0\n};",
      "extern unsigned long __start_kprobe_blacklist[];",
      "extern unsigned long __stop_kprobe_blacklist[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_test_probes",
          "args": [],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "init_test_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/test_kprobes.c",
          "lines": "280-322",
          "snippet": "int init_test_probes(void)\n{\n\tint ret;\n\n\ttarget = kprobe_target;\n\ttarget2 = kprobe_target2;\n\n\tdo {\n\t\trand1 = prandom_u32();\n\t} while (rand1 <= div_factor);\n\n\tpr_info(\"started\\n\");\n\tnum_tests++;\n\tret = test_kprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kprobes();\n\tif (ret < 0)\n\t\terrors++;\n\n#ifdef CONFIG_KRETPROBES\n\tnum_tests++;\n\tret = test_kretprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kretprobes();\n\tif (ret < 0)\n\t\terrors++;\n#endif /* CONFIG_KRETPROBES */\n\n\tif (errors)\n\t\tpr_err(\"BUG: %d out of %d tests failed\\n\", errors, num_tests);\n\telse if (handler_errors)\n\t\tpr_err(\"BUG: %d error(s) running handlers\\n\", handler_errors);\n\telse\n\t\tpr_info(\"passed successfully\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/random.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define div_factor 3"
          ],
          "globals_used": [
            "static int errors, handler_errors, num_tests;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/random.h>\n#include <linux/kprobes.h>\n#include <linux/kernel.h>\n\n#define div_factor 3\n\nstatic int errors, handler_errors, num_tests;\n\nint init_test_probes(void)\n{\n\tint ret;\n\n\ttarget = kprobe_target;\n\ttarget2 = kprobe_target2;\n\n\tdo {\n\t\trand1 = prandom_u32();\n\t} while (rand1 <= div_factor);\n\n\tpr_info(\"started\\n\");\n\tnum_tests++;\n\tret = test_kprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kprobes();\n\tif (ret < 0)\n\t\terrors++;\n\n#ifdef CONFIG_KRETPROBES\n\tnum_tests++;\n\tret = test_kretprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kretprobes();\n\tif (ret < 0)\n\t\terrors++;\n#endif /* CONFIG_KRETPROBES */\n\n\tif (errors)\n\t\tpr_err(\"BUG: %d out of %d tests failed\\n\", errors, num_tests);\n\telse if (handler_errors)\n\t\tpr_err(\"BUG: %d error(s) running handlers\\n\", handler_errors);\n\telse\n\t\tpr_info(\"passed successfully\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&kprobe_module_nb"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_die_notifier",
          "args": [
            "&kprobe_exceptions_nb"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_die_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "560-563",
          "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(die_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_init_kprobes",
          "args": [],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kretprobe: lookup failed: %s\\n\"",
            "kretprobe_blacklist[i].name"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_lookup_name",
          "args": [
            "kretprobe_blacklist[i].name",
            "0"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Please take care of using kprobes.\\n\""
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kprobes: failed to populate blacklist: %d\\n\"",
            "err"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_kprobe_blacklist",
          "args": [
            "__start_kprobe_blacklist",
            "__stop_kprobe_blacklist"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "populate_kprobe_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "2104-2127",
          "snippet": "static int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long *iter;\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long entry, offset = 0, size = 0;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = arch_deref_entry_point((void *)*iter);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\t\tcontinue;\n\n\t\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\t\tif (!ent)\n\t\t\treturn -ENOMEM;\n\t\tent->start_addr = entry;\n\t\tent->end_addr = entry + size;\n\t\tINIT_LIST_HEAD(&ent->list);\n\t\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long *iter;\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long entry, offset = 0, size = 0;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = arch_deref_entry_point((void *)*iter);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\t\tcontinue;\n\n\t\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\t\tif (!ent)\n\t\t\treturn -ENOMEM;\n\t\tent->start_addr = entry;\n\t\tent->end_addr = entry + size;\n\t\tINIT_LIST_HEAD(&ent->list);\n\t\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&(kretprobe_table_locks[i].lock)"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&kretprobe_inst_table[i]"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&kprobe_table[i]"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic int kprobes_initialized;\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\nstatic struct notifier_block kprobe_exceptions_nb = {\n\t.notifier_call = kprobe_exceptions_notify,\n\t.priority = 0x7fffffff /* we need to be notified first */\n};\nstatic struct notifier_block kprobe_module_nb = {\n\t.notifier_call = kprobes_module_callback,\n\t.priority = 0\n};\nextern unsigned long __start_kprobe_blacklist[];\nextern unsigned long __stop_kprobe_blacklist[];\n\nstatic int __init init_kprobes(void)\n{\n\tint i, err = 0;\n\n\t/* FIXME allocate the probe table, currently defined statically */\n\t/* initialize all list heads */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\tINIT_HLIST_HEAD(&kprobe_table[i]);\n\t\tINIT_HLIST_HEAD(&kretprobe_inst_table[i]);\n\t\traw_spin_lock_init(&(kretprobe_table_locks[i].lock));\n\t}\n\n\terr = populate_kprobe_blacklist(__start_kprobe_blacklist,\n\t\t\t\t\t__stop_kprobe_blacklist);\n\tif (err) {\n\t\tpr_err(\"kprobes: failed to populate blacklist: %d\\n\", err);\n\t\tpr_err(\"Please take care of using kprobes.\\n\");\n\t}\n\n\tif (kretprobe_blacklist_size) {\n\t\t/* lookup the function address from its name */\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tkretprobe_blacklist[i].addr =\n\t\t\t\tkprobe_lookup_name(kretprobe_blacklist[i].name, 0);\n\t\t\tif (!kretprobe_blacklist[i].addr)\n\t\t\t\tprintk(\"kretprobe: lookup failed: %s\\n\",\n\t\t\t\t       kretprobe_blacklist[i].name);\n\t\t}\n\t}\n\n#if defined(CONFIG_OPTPROBES)\n#if defined(__ARCH_WANT_KPROBES_INSN_SLOT)\n\t/* Init kprobe_optinsn_slots */\n\tkprobe_optinsn_slots.insn_size = MAX_OPTINSN_SIZE;\n#endif\n\t/* By default, kprobes can be optimized */\n\tkprobes_allow_optimization = true;\n#endif\n\n\t/* By default, kprobes are armed */\n\tkprobes_all_disarmed = false;\n\n\terr = arch_init_kprobes();\n\tif (!err)\n\t\terr = register_die_notifier(&kprobe_exceptions_nb);\n\tif (!err)\n\t\terr = register_module_notifier(&kprobe_module_nb);\n\n\tkprobes_initialized = (err == 0);\n\n\tif (!err)\n\t\tinit_test_probes();\n\treturn err;\n}"
  },
  {
    "function_name": "kprobes_module_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2130-2171",
    "snippet": "static int kprobes_module_callback(struct notifier_block *nb,\n\t\t\t\t   unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\tint checkcore = (val == MODULE_STATE_GOING);\n\n\tif (val != MODULE_STATE_GOING && val != MODULE_STATE_LIVE)\n\t\treturn NOTIFY_DONE;\n\n\t/*\n\t * When MODULE_STATE_GOING was notified, both of module .text and\n\t * .init.text sections would be freed. When MODULE_STATE_LIVE was\n\t * notified, only .init.text section would be freed. We need to\n\t * disable kprobes which have been inserted in the sections.\n\t */\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (within_module_init((unsigned long)p->addr, mod) ||\n\t\t\t    (checkcore &&\n\t\t\t     within_module_core((unsigned long)p->addr, mod))) {\n\t\t\t\t/*\n\t\t\t\t * The vaddr this probe is installed will soon\n\t\t\t\t * be vfreed buy not synced to disk. Hence,\n\t\t\t\t * disarming the breakpoint isn't needed.\n\t\t\t\t *\n\t\t\t\t * Note, this will also move any optimized probes\n\t\t\t\t * that are pending to be removed from their\n\t\t\t\t * corresponding lists to the freeing_list and\n\t\t\t\t * will not be touched by the delayed\n\t\t\t\t * kprobe_optimizer work handler.\n\t\t\t\t */\n\t\t\t\tkill_kprobe(p);\n\t\t\t}\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_kprobe",
          "args": [
            "p"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "kill_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "2011-2031",
          "snippet": "static void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "(unsigned long)p->addr",
            "mod"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "(unsigned long)p->addr",
            "mod"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int kprobes_module_callback(struct notifier_block *nb,\n\t\t\t\t   unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\tint checkcore = (val == MODULE_STATE_GOING);\n\n\tif (val != MODULE_STATE_GOING && val != MODULE_STATE_LIVE)\n\t\treturn NOTIFY_DONE;\n\n\t/*\n\t * When MODULE_STATE_GOING was notified, both of module .text and\n\t * .init.text sections would be freed. When MODULE_STATE_LIVE was\n\t * notified, only .init.text section would be freed. We need to\n\t * disable kprobes which have been inserted in the sections.\n\t */\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (within_module_init((unsigned long)p->addr, mod) ||\n\t\t\t    (checkcore &&\n\t\t\t     within_module_core((unsigned long)p->addr, mod))) {\n\t\t\t\t/*\n\t\t\t\t * The vaddr this probe is installed will soon\n\t\t\t\t * be vfreed buy not synced to disk. Hence,\n\t\t\t\t * disarming the breakpoint isn't needed.\n\t\t\t\t *\n\t\t\t\t * Note, this will also move any optimized probes\n\t\t\t\t * that are pending to be removed from their\n\t\t\t\t * corresponding lists to the freeing_list and\n\t\t\t\t * will not be touched by the delayed\n\t\t\t\t * kprobe_optimizer work handler.\n\t\t\t\t */\n\t\t\t\tkill_kprobe(p);\n\t\t\t}\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "populate_kprobe_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2104-2127",
    "snippet": "static int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long *iter;\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long entry, offset = 0, size = 0;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = arch_deref_entry_point((void *)*iter);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\t\tcontinue;\n\n\t\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\t\tif (!ent)\n\t\t\treturn -ENOMEM;\n\t\tent->start_addr = entry;\n\t\tent->end_addr = entry + size;\n\t\tINIT_LIST_HEAD(&ent->list);\n\t\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ent->list",
            "&kprobe_blacklist"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ent->list"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ent)",
            "GFP_KERNEL"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "entry",
            "&size",
            "&offset"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "260-269",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "entry"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/extable.c",
          "lines": "122-160",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots\n\t * and is_bpf_text_address() require RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots\n\t * and is_bpf_text_address() require RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_deref_entry_point",
          "args": [
            "(void *)*iter"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "arch_deref_entry_point",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1798-1801",
          "snippet": "unsigned long __weak arch_deref_entry_point(void *entry)\n{\n\treturn (unsigned long)entry;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nunsigned long __weak arch_deref_entry_point(void *entry)\n{\n\treturn (unsigned long)entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long *iter;\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long entry, offset = 0, size = 0;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = arch_deref_entry_point((void *)*iter);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\t\tcontinue;\n\n\t\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\t\tif (!ent)\n\t\t\treturn -ENOMEM;\n\t\tent->start_addr = entry;\n\t\tent->end_addr = entry + size;\n\t\tINIT_LIST_HEAD(&ent->list);\n\t\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dump_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2088-2093",
    "snippet": "void dump_kprobe(struct kprobe *kp)\n{\n\tpr_err(\"Dumping kprobe:\\n\");\n\tpr_err(\"Name: %s\\nOffset: %x\\nAddress: %pS\\n\",\n\t       kp->symbol_name, kp->offset, kp->addr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Name: %s\\nOffset: %x\\nAddress: %pS\\n\"",
            "kp->symbol_name",
            "kp->offset",
            "kp->addr"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Dumping kprobe:\\n\""
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid dump_kprobe(struct kprobe *kp)\n{\n\tpr_err(\"Dumping kprobe:\\n\");\n\tpr_err(\"Name: %s\\nOffset: %x\\nAddress: %pS\\n\",\n\t       kp->symbol_name, kp->offset, kp->addr);\n}"
  },
  {
    "function_name": "enable_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2052-2084",
    "snippet": "int enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "p"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1053-1065",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "kp"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_valid_kprobe",
          "args": [
            "kp"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "__get_valid_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1449-1466",
          "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "disable_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2034-2048",
    "snippet": "int disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__disable_kprobe",
          "args": [
            "kp"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1634-1668",
          "snippet": "static struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If kprobes_all_disarmed is set, orig_p\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If kprobes_all_disarmed is set, orig_p\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2011-2031",
    "snippet": "static void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_optimized_kprobe",
          "args": [
            "p"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "kill_optimized_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "732-755",
          "snippet": "static void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n}"
  },
  {
    "function_name": "pre_handler_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "2002-2005",
    "snippet": "static int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_kretprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1997-1999",
    "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}"
  },
  {
    "function_name": "unregister_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1992-1994",
    "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
  },
  {
    "function_name": "register_kretprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1986-1989",
    "snippet": "int register_kretprobes(struct kretprobe **rps, int num)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobes(struct kretprobe **rps, int num)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "register_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1980-1983",
    "snippet": "int register_kretprobe(struct kretprobe *rp)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobe(struct kretprobe *rp)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "unregister_kretprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1957-1976",
    "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(&rps[i]->kp) < 0)\n\t\t\trps[i]->kp.addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++) {\n\t\tif (rps[i]->kp.addr) {\n\t\t\t__unregister_kprobe_bottom(&rps[i]->kp);\n\t\t\tcleanup_rp_inst(rps[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_rp_inst",
          "args": [
            "rps[i]"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_rp_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1253-1271",
          "snippet": "static void cleanup_rp_inst(struct kretprobe *rp)\n{\n\tunsigned long flags, hash;\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\tstruct hlist_head *head;\n\n\t/* No race here */\n\tfor (hash = 0; hash < KPROBE_TABLE_SIZE; hash++) {\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thead = &kretprobe_inst_table[hash];\n\t\thlist_for_each_entry_safe(ri, next, head, hlist) {\n\t\t\tif (ri->rp == rp)\n\t\t\t\tri->rp = NULL;\n\t\t}\n\t\tkretprobe_table_unlock(hash, &flags);\n\t}\n\tfree_rp_inst(rp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\n\nstatic void cleanup_rp_inst(struct kretprobe *rp)\n{\n\tunsigned long flags, hash;\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\tstruct hlist_head *head;\n\n\t/* No race here */\n\tfor (hash = 0; hash < KPROBE_TABLE_SIZE; hash++) {\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thead = &kretprobe_inst_table[hash];\n\t\thlist_for_each_entry_safe(ri, next, head, hlist) {\n\t\t\tif (ri->rp == rp)\n\t\t\t\tri->rp = NULL;\n\t\t}\n\t\tkretprobe_table_unlock(hash, &flags);\n\t}\n\tfree_rp_inst(rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_kprobe_bottom",
          "args": [
            "&rps[i]->kp"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_bottom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1727-1741",
          "snippet": "static void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_kprobe_top",
          "args": [
            "&rps[i]->kp"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1673-1725",
          "snippet": "static int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry_rcu(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry_rcu(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(&rps[i]->kp) < 0)\n\t\t\trps[i]->kp.addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++) {\n\t\tif (rps[i]->kp.addr) {\n\t\t\t__unregister_kprobe_bottom(&rps[i]->kp);\n\t\t\tcleanup_rp_inst(rps[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "unregister_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1951-1954",
    "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n\tunregister_kretprobes(&rp, 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kretprobes",
          "args": [
            "&rp",
            "1"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1997-1999",
          "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n\tunregister_kretprobes(&rp, 1);\n}"
  },
  {
    "function_name": "register_kretprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1933-1948",
    "snippet": "int register_kretprobes(struct kretprobe **rps, int num)\n{\n\tint ret = 0, i;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kretprobe(rps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kretprobes(rps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kretprobes",
          "args": [
            "rps",
            "i"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1997-1999",
          "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kretprobe",
          "args": [
            "rps[i]"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1992-1994",
          "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobes(struct kretprobe **rps, int num)\n{\n\tint ret = 0, i;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kretprobe(rps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kretprobes(rps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "register_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1878-1930",
    "snippet": "int register_kretprobe(struct kretprobe *rp)\n{\n\tint ret = 0;\n\tstruct kretprobe_instance *inst;\n\tint i;\n\tvoid *addr;\n\n\tif (!kprobe_on_func_entry(rp->kp.addr, rp->kp.symbol_name, rp->kp.offset))\n\t\treturn -EINVAL;\n\n\tif (kretprobe_blacklist_size) {\n\t\taddr = kprobe_addr(&rp->kp);\n\t\tif (IS_ERR(addr))\n\t\t\treturn PTR_ERR(addr);\n\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tif (kretprobe_blacklist[i].addr == addr)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trp->kp.pre_handler = pre_handler_kretprobe;\n\trp->kp.post_handler = NULL;\n\trp->kp.fault_handler = NULL;\n\n\t/* Pre-allocate memory for max kretprobe instances */\n\tif (rp->maxactive <= 0) {\n#ifdef CONFIG_PREEMPT\n\t\trp->maxactive = max_t(unsigned int, 10, 2*num_possible_cpus());\n#else\n\t\trp->maxactive = num_possible_cpus();\n#endif\n\t}\n\traw_spin_lock_init(&rp->lock);\n\tINIT_HLIST_HEAD(&rp->free_instances);\n\tfor (i = 0; i < rp->maxactive; i++) {\n\t\tinst = kmalloc(sizeof(struct kretprobe_instance) +\n\t\t\t       rp->data_size, GFP_KERNEL);\n\t\tif (inst == NULL) {\n\t\t\tfree_rp_inst(rp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_HLIST_NODE(&inst->hlist);\n\t\thlist_add_head(&inst->hlist, &rp->free_instances);\n\t}\n\n\trp->nmissed = 0;\n\t/* Establish function entry probe point */\n\tret = register_kprobe(&rp->kp);\n\tif (ret != 0)\n\t\tfree_rp_inst(rp);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rp_inst",
          "args": [
            "rp"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "free_rp_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1242-1251",
          "snippet": "static inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\n\thlist_for_each_entry_safe(ri, next, &rp->free_instances, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\n\thlist_for_each_entry_safe(ri, next, &rp->free_instances, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&rp->kp"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1761-1764",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inst->hlist",
            "&rp->free_instances"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&inst->hlist"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct kretprobe_instance) +\n\t\t\t       rp->data_size",
            "GFP_KERNEL"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&rp->free_instances"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rp->lock"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "10",
            "2*num_possible_cpus()"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "addr"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "addr"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_addr",
          "args": [
            "&rp->kp"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1443-1446",
          "snippet": "static kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_on_func_entry",
          "args": [
            "rp->kp.addr",
            "rp->kp.symbol_name",
            "rp->kp.offset"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_on_func_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1864-1876",
          "snippet": "bool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobe(struct kretprobe *rp)\n{\n\tint ret = 0;\n\tstruct kretprobe_instance *inst;\n\tint i;\n\tvoid *addr;\n\n\tif (!kprobe_on_func_entry(rp->kp.addr, rp->kp.symbol_name, rp->kp.offset))\n\t\treturn -EINVAL;\n\n\tif (kretprobe_blacklist_size) {\n\t\taddr = kprobe_addr(&rp->kp);\n\t\tif (IS_ERR(addr))\n\t\t\treturn PTR_ERR(addr);\n\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tif (kretprobe_blacklist[i].addr == addr)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trp->kp.pre_handler = pre_handler_kretprobe;\n\trp->kp.post_handler = NULL;\n\trp->kp.fault_handler = NULL;\n\n\t/* Pre-allocate memory for max kretprobe instances */\n\tif (rp->maxactive <= 0) {\n#ifdef CONFIG_PREEMPT\n\t\trp->maxactive = max_t(unsigned int, 10, 2*num_possible_cpus());\n#else\n\t\trp->maxactive = num_possible_cpus();\n#endif\n\t}\n\traw_spin_lock_init(&rp->lock);\n\tINIT_HLIST_HEAD(&rp->free_instances);\n\tfor (i = 0; i < rp->maxactive; i++) {\n\t\tinst = kmalloc(sizeof(struct kretprobe_instance) +\n\t\t\t       rp->data_size, GFP_KERNEL);\n\t\tif (inst == NULL) {\n\t\t\tfree_rp_inst(rp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_HLIST_NODE(&inst->hlist);\n\t\thlist_add_head(&inst->hlist, &rp->free_instances);\n\t}\n\n\trp->nmissed = 0;\n\t/* Establish function entry probe point */\n\tret = register_kprobe(&rp->kp);\n\tif (ret != 0)\n\t\tfree_rp_inst(rp);\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_on_func_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1864-1876",
    "snippet": "bool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kprobe_on_func_entry",
          "args": [
            "offset"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kprobe_on_func_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1859-1862",
          "snippet": "bool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "(unsigned long)kp_addr",
            "NULL",
            "&offset"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "260-269",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kp_addr"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_kprobe_addr",
          "args": [
            "addr",
            "sym",
            "offset"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "_kprobe_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1423-1441",
          "snippet": "static kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "arch_kprobe_on_func_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1859-1862",
    "snippet": "bool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}"
  },
  {
    "function_name": "pre_handler_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1808-1856",
    "snippet": "static int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kretprobe *rp = container_of(p, struct kretprobe, kp);\n\tunsigned long hash, flags = 0;\n\tstruct kretprobe_instance *ri;\n\n\t/*\n\t * To avoid deadlocks, prohibit return probing in NMI contexts,\n\t * just skip the probe and increase the (inexact) 'nmissed'\n\t * statistical counter, so that the user is informed that\n\t * something happened:\n\t */\n\tif (unlikely(in_nmi())) {\n\t\trp->nmissed++;\n\t\treturn 0;\n\t}\n\n\t/* TODO: consider to only swap the RA after the last pre_handler fired */\n\thash = hash_ptr(current, KPROBE_HASH_BITS);\n\traw_spin_lock_irqsave(&rp->lock, flags);\n\tif (!hlist_empty(&rp->free_instances)) {\n\t\tri = hlist_entry(rp->free_instances.first,\n\t\t\t\tstruct kretprobe_instance, hlist);\n\t\thlist_del(&ri->hlist);\n\t\traw_spin_unlock_irqrestore(&rp->lock, flags);\n\n\t\tri->rp = rp;\n\t\tri->task = current;\n\n\t\tif (rp->entry_handler && rp->entry_handler(ri, regs)) {\n\t\t\traw_spin_lock_irqsave(&rp->lock, flags);\n\t\t\thlist_add_head(&ri->hlist, &rp->free_instances);\n\t\t\traw_spin_unlock_irqrestore(&rp->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tarch_prepare_kretprobe(ri, regs);\n\n\t\t/* XXX(hch): why is there no hlist_move_head? */\n\t\tINIT_HLIST_NODE(&ri->hlist);\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thlist_add_head(&ri->hlist, &kretprobe_inst_table[hash]);\n\t\tkretprobe_table_unlock(hash, &flags);\n\t} else {\n\t\trp->nmissed++;\n\t\traw_spin_unlock_irqrestore(&rp->lock, flags);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];",
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rp->lock",
            "flags"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_table_unlock",
          "args": [
            "hash",
            "&flags"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1200-1206",
          "snippet": "static void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&ri->hlist",
            "&kretprobe_inst_table[hash]"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock",
          "args": [
            "hash",
            "&flags"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1179-1185",
          "snippet": "static void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&ri->hlist"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepare_kretprobe",
          "args": [
            "ri",
            "regs"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&ri->hlist",
            "&rp->free_instances"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rp->lock",
            "flags"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rp->entry_handler",
          "args": [
            "ri",
            "regs"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "entry_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/test_kprobes.c",
          "lines": "168-176",
          "snippet": "static int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tif (preemptible()) {\n\t\thandler_errors++;\n\t\tpr_err(\"kretprobe entry handler is preemptible\\n\");\n\t}\n\tkrph_val = (rand1 / div_factor);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/random.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define div_factor 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/random.h>\n#include <linux/kprobes.h>\n#include <linux/kernel.h>\n\n#define div_factor 3\n\nstatic int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tif (preemptible()) {\n\t\thandler_errors++;\n\t\tpr_err(\"kretprobe entry handler is preemptible\\n\");\n\t}\n\tkrph_val = (rand1 / div_factor);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&ri->hlist"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "rp->free_instances.first",
            "structkretprobe_instance",
            "hlist"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&rp->free_instances"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "current",
            "KPROBE_HASH_BITS"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_nmi()"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structkretprobe",
            "kp"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kretprobe *rp = container_of(p, struct kretprobe, kp);\n\tunsigned long hash, flags = 0;\n\tstruct kretprobe_instance *ri;\n\n\t/*\n\t * To avoid deadlocks, prohibit return probing in NMI contexts,\n\t * just skip the probe and increase the (inexact) 'nmissed'\n\t * statistical counter, so that the user is informed that\n\t * something happened:\n\t */\n\tif (unlikely(in_nmi())) {\n\t\trp->nmissed++;\n\t\treturn 0;\n\t}\n\n\t/* TODO: consider to only swap the RA after the last pre_handler fired */\n\thash = hash_ptr(current, KPROBE_HASH_BITS);\n\traw_spin_lock_irqsave(&rp->lock, flags);\n\tif (!hlist_empty(&rp->free_instances)) {\n\t\tri = hlist_entry(rp->free_instances.first,\n\t\t\t\tstruct kretprobe_instance, hlist);\n\t\thlist_del(&ri->hlist);\n\t\traw_spin_unlock_irqrestore(&rp->lock, flags);\n\n\t\tri->rp = rp;\n\t\tri->task = current;\n\n\t\tif (rp->entry_handler && rp->entry_handler(ri, regs)) {\n\t\t\traw_spin_lock_irqsave(&rp->lock, flags);\n\t\t\thlist_add_head(&ri->hlist, &rp->free_instances);\n\t\t\traw_spin_unlock_irqrestore(&rp->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tarch_prepare_kretprobe(ri, regs);\n\n\t\t/* XXX(hch): why is there no hlist_move_head? */\n\t\tINIT_HLIST_NODE(&ri->hlist);\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thlist_add_head(&ri->hlist, &kretprobe_inst_table[hash]);\n\t\tkretprobe_table_unlock(hash, &flags);\n\t} else {\n\t\trp->nmissed++;\n\t\traw_spin_unlock_irqrestore(&rp->lock, flags);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_deref_entry_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1798-1801",
    "snippet": "unsigned long __weak arch_deref_entry_point(void *entry)\n{\n\treturn (unsigned long)entry;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nunsigned long __weak arch_deref_entry_point(void *entry)\n{\n\treturn (unsigned long)entry;\n}"
  },
  {
    "function_name": "kprobe_exceptions_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1786-1790",
    "snippet": "int __weak kprobe_exceptions_notify(struct notifier_block *self,\n\t\t\t\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __weak kprobe_exceptions_notify(struct notifier_block *self,\n\t\t\t\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "unregister_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1767-1783",
    "snippet": "void unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unregister_kprobe_bottom",
          "args": [
            "kps[i]"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_bottom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1727-1741",
          "snippet": "static void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_kprobe_top",
          "args": [
            "kps[i]"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1673-1725",
          "snippet": "static int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry_rcu(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry_rcu(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}"
  },
  {
    "function_name": "unregister_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1761-1764",
    "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kprobes",
          "args": [
            "&p",
            "1"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1767-1783",
          "snippet": "void unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
  },
  {
    "function_name": "register_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1743-1758",
    "snippet": "int register_kprobes(struct kprobe **kps, int num)\n{\n\tint i, ret = 0;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kprobe(kps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kprobes(kps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kprobes",
          "args": [
            "kps",
            "i"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1767-1783",
          "snippet": "void unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_sched();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "kps[i]"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1761-1764",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kprobes(struct kprobe **kps, int num)\n{\n\tint i, ret = 0;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kprobe(kps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kprobes(kps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__unregister_kprobe_bottom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1727-1741",
    "snippet": "static void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_aggr_kprobe",
          "args": [
            "ap"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "free_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "965-969",
          "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&p->list"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p->list.next",
            "structkprobe",
            "list"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&p->list"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&p->list"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}"
  },
  {
    "function_name": "__unregister_kprobe_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1673-1725",
    "snippet": "static int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry_rcu(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&ap->hlist"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "ap"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "ap"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->list"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "list_p",
            "&ap->list",
            "list"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disarmed",
          "args": [
            "ap"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_disarmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "422-433",
          "snippet": "static inline int kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&ap->list"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!kprobe_aggrprobe(ap)"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "ap"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ap"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ap"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__disable_kprobe",
          "args": [
            "p"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1634-1668",
          "snippet": "static struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If kprobes_all_disarmed is set, orig_p\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If kprobes_all_disarmed is set, orig_p\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry_rcu(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}"
  },
  {
    "function_name": "__disable_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1634-1668",
    "snippet": "static struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If kprobes_all_disarmed is set, orig_p\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disarm_kprobe",
          "args": [
            "orig_p",
            "true"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1068-1080",
          "snippet": "static int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aggr_kprobe_disabled",
          "args": [
            "orig_p"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "orig_p == NULL"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_valid_kprobe",
          "args": [
            "p"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "__get_valid_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1449-1466",
          "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If kprobes_all_disarmed is set, orig_p\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}"
  },
  {
    "function_name": "aggr_kprobe_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1618-1631",
    "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&ap->list",
            "list"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "register_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1548-1614",
    "snippet": "int register_kprobe(struct kprobe *p)\n{\n\tint ret;\n\tstruct kprobe *old_p;\n\tstruct module *probed_mod;\n\tkprobe_opcode_t *addr;\n\n\t/* Adjust probe address from symbol */\n\taddr = kprobe_addr(p);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\tp->addr = addr;\n\n\tret = check_kprobe_rereg(p);\n\tif (ret)\n\t\treturn ret;\n\n\t/* User can pass only KPROBE_FLAG_DISABLED to register_kprobe */\n\tp->flags &= KPROBE_FLAG_DISABLED;\n\tp->nmissed = 0;\n\tINIT_LIST_HEAD(&p->list);\n\n\tret = check_kprobe_address_safe(p, &probed_mod);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&kprobe_mutex);\n\n\told_p = get_kprobe(p->addr);\n\tif (old_p) {\n\t\t/* Since this may unoptimize old_p, locking text_mutex. */\n\t\tret = register_aggr_kprobe(old_p, p);\n\t\tgoto out;\n\t}\n\n\tcpus_read_lock();\n\t/* Prevent text modification */\n\tmutex_lock(&text_mutex);\n\tret = prepare_kprobe(p);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\tif (ret)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&p->hlist);\n\thlist_add_head_rcu(&p->hlist,\n\t\t       &kprobe_table[hash_ptr(p->addr, KPROBE_HASH_BITS)]);\n\n\tif (!kprobes_all_disarmed && !kprobe_disabled(p)) {\n\t\tret = arm_kprobe(p);\n\t\tif (ret) {\n\t\t\thlist_del_rcu(&p->hlist);\n\t\t\tsynchronize_sched();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to optimize kprobe */\n\ttry_to_optimize_kprobe(p);\nout:\n\tmutex_unlock(&kprobe_mutex);\n\n\tif (probed_mod)\n\t\tmodule_put(probed_mod);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "probed_mod"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_optimize_kprobe",
          "args": [
            "p"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&p->hlist"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "p"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1053-1065",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&p->hlist",
            "&kprobe_table[hash_ptr(p->addr, KPROBE_HASH_BITS)]"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "p->addr",
            "KPROBE_HASH_BITS"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&p->hlist"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_kprobe",
          "args": [
            "p"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "985-991",
          "snippet": "static int prepare_kprobe(struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe(p);\n\n\treturn arch_prepare_kprobe_ftrace(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int prepare_kprobe(struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe(p);\n\n\treturn arch_prepare_kprobe_ftrace(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_aggr_kprobe",
          "args": [
            "old_p",
            "p"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "register_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1315-1390",
          "snippet": "static int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If orig_p is not an aggr_kprobe, create new aggr_kprobe. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free aggr_probe. It will be used next time, or\n\t\t\t * freed by unregister_kprobe.\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy ap's insn slot to p */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_sched();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If orig_p is not an aggr_kprobe, create new aggr_kprobe. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free aggr_probe. It will be used next time, or\n\t\t\t * freed by unregister_kprobe.\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy ap's insn slot to p */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_sched();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "p->addr"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "get_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "336-348",
          "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kprobe_address_safe",
          "args": [
            "p",
            "&probed_mod"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "check_kprobe_address_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1499-1546",
          "snippet": "static int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = arch_check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if are we probing a module */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed .init.text, we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = arch_check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if are we probing a module */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed .init.text, we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&p->list"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_kprobe_rereg",
          "args": [
            "p"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "check_kprobe_rereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1469-1479",
          "snippet": "static inline int check_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (__get_valid_kprobe(p))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic inline int check_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (__get_valid_kprobe(p))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "addr"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "addr"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_addr",
          "args": [
            "p"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1443-1446",
          "snippet": "static kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint register_kprobe(struct kprobe *p)\n{\n\tint ret;\n\tstruct kprobe *old_p;\n\tstruct module *probed_mod;\n\tkprobe_opcode_t *addr;\n\n\t/* Adjust probe address from symbol */\n\taddr = kprobe_addr(p);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\tp->addr = addr;\n\n\tret = check_kprobe_rereg(p);\n\tif (ret)\n\t\treturn ret;\n\n\t/* User can pass only KPROBE_FLAG_DISABLED to register_kprobe */\n\tp->flags &= KPROBE_FLAG_DISABLED;\n\tp->nmissed = 0;\n\tINIT_LIST_HEAD(&p->list);\n\n\tret = check_kprobe_address_safe(p, &probed_mod);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&kprobe_mutex);\n\n\told_p = get_kprobe(p->addr);\n\tif (old_p) {\n\t\t/* Since this may unoptimize old_p, locking text_mutex. */\n\t\tret = register_aggr_kprobe(old_p, p);\n\t\tgoto out;\n\t}\n\n\tcpus_read_lock();\n\t/* Prevent text modification */\n\tmutex_lock(&text_mutex);\n\tret = prepare_kprobe(p);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\tif (ret)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&p->hlist);\n\thlist_add_head_rcu(&p->hlist,\n\t\t       &kprobe_table[hash_ptr(p->addr, KPROBE_HASH_BITS)]);\n\n\tif (!kprobes_all_disarmed && !kprobe_disabled(p)) {\n\t\tret = arm_kprobe(p);\n\t\tif (ret) {\n\t\t\thlist_del_rcu(&p->hlist);\n\t\t\tsynchronize_sched();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to optimize kprobe */\n\ttry_to_optimize_kprobe(p);\nout:\n\tmutex_unlock(&kprobe_mutex);\n\n\tif (probed_mod)\n\t\tmodule_put(probed_mod);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_kprobe_address_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1499-1546",
    "snippet": "static int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = arch_check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if are we probing a module */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed .init.text, we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "*probed_mod"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "(unsigned long)p->addr",
            "*probed_mod"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!try_module_get(*probed_mod)"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "*probed_mod"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__module_text_address",
          "args": [
            "(unsigned long) p->addr"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "__module_text_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4363-4373",
          "snippet": "struct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstruct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_text_reserved",
          "args": [
            "p->addr",
            "p->addr"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_text_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "719-731",
          "snippet": "int jump_label_text_reserved(void *start, void *end)\n{\n\tint ret = __jump_label_text_reserved(__start___jump_table,\n\t\t\t__stop___jump_table, start, end);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = __jump_label_mod_text_reserved(start, end);\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nint jump_label_text_reserved(void *start, void *end)\n{\n\tint ret = __jump_label_text_reserved(__start___jump_table,\n\t\t\t__stop___jump_table, start, end);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = __jump_label_mod_text_reserved(start, end);\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_kprobe_blacklist",
          "args": [
            "(unsigned long) p->addr"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "within_kprobe_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1399-1415",
          "snippet": "bool within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If there exists a kprobe_blacklist, verify and\n\t * fail any probe registration in the prohibited area\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nbool within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If there exists a kprobe_blacklist, verify and\n\t * fail any probe registration in the prohibited area\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "(unsigned long) p->addr"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/extable.c",
          "lines": "122-160",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots\n\t * and is_bpf_text_address() require RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots\n\t * and is_bpf_text_address() require RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_ftrace_location",
          "args": [
            "p"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "arch_check_ftrace_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1481-1497",
          "snippet": "int __weak arch_check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __weak arch_check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = arch_check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if are we probing a module */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed .init.text, we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "arch_check_ftrace_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1481-1497",
    "snippet": "int __weak arch_check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location",
          "args": [
            "(unsigned long)p->addr"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "arch_check_ftrace_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1481-1497",
          "snippet": "int __weak arch_check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __weak arch_check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_kprobe_rereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1469-1479",
    "snippet": "static inline int check_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (__get_valid_kprobe(p))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_valid_kprobe",
          "args": [
            "p"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__get_valid_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1449-1466",
          "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic inline int check_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (__get_valid_kprobe(p))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_valid_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1449-1466",
    "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "list_p",
            "&ap->list",
            "list"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ap"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "p->addr"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "get_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "336-348",
          "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry_rcu(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
  },
  {
    "function_name": "kprobe_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1443-1446",
    "snippet": "static kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_kprobe_addr",
          "args": [
            "p->addr",
            "p->symbol_name",
            "p->offset"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "_kprobe_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1423-1441",
          "snippet": "static kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}"
  },
  {
    "function_name": "_kprobe_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1423-1441",
    "snippet": "static kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_lookup_name",
          "args": [
            "symbol_name",
            "offset"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "within_kprobe_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1399-1415",
    "snippet": "bool within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If there exists a kprobe_blacklist, verify and\n\t * fail any probe registration in the prohibited area\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ent",
            "&kprobe_blacklist",
            "list"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_within_kprobe_blacklist",
          "args": [
            "addr"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "arch_within_kprobe_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1392-1397",
          "snippet": "bool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The __kprobes marked functions and entry code must not be probed */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The __kprobes marked functions and entry code must not be probed */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nbool within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If there exists a kprobe_blacklist, verify and\n\t * fail any probe registration in the prohibited area\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "arch_within_kprobe_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1392-1397",
    "snippet": "bool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The __kprobes marked functions and entry code must not be probed */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The __kprobes marked functions and entry code must not be probed */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}"
  },
  {
    "function_name": "register_aggr_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1315-1390",
    "snippet": "static int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If orig_p is not an aggr_kprobe, create new aggr_kprobe. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free aggr_probe. It will be used next time, or\n\t\t\t * freed by unregister_kprobe.\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy ap's insn slot to p */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_sched();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->list"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "ap"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1053-1065",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_new_kprobe",
          "args": [
            "ap",
            "p"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "add_new_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1275-1285",
          "snippet": "static int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_kprobe",
          "args": [
            "ap",
            "p"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "copy_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "369-373",
          "snippet": "static inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_optimized_kprobe",
          "args": [
            "ap"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_optimized_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "765-771",
          "snippet": "static void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_prepare_kprobe",
          "args": [
            "ap"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "ap"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuse_unused_kprobe",
          "args": [
            "ap"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "reuse_unused_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "953-963",
          "snippet": "static int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tprintk(KERN_ERR \"Error: There should be no unused kprobe here.\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tprintk(KERN_ERR \"Error: There should be no unused kprobe here.\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "ap"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "360-364",
          "snippet": "static inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_aggr_kprobe",
          "args": [
            "ap",
            "orig_p"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "init_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1291-1309",
          "snippet": "static void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy p's insn slot to ap */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\tap->fault_handler = aggr_fault_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy p's insn slot to ap */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\tap->fault_handler = aggr_fault_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_aggr_kprobe",
          "args": [
            "orig_p"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "971-974",
          "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "orig_p"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If orig_p is not an aggr_kprobe, create new aggr_kprobe. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free aggr_probe. It will be used next time, or\n\t\t\t * freed by unregister_kprobe.\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy ap's insn slot to p */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_sched();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "init_aggr_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1291-1309",
    "snippet": "static void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy p's insn slot to ap */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\tap->fault_handler = aggr_fault_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_replace_rcu",
          "args": [
            "&p->hlist",
            "&ap->hlist"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&p->list",
            "&ap->list"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&ap->hlist"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ap->list"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_insn_slot",
          "args": [
            "ap"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_kprobe",
          "args": [
            "p",
            "ap"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "copy_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "369-373",
          "snippet": "static inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy p's insn slot to ap */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\tap->fault_handler = aggr_fault_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}"
  },
  {
    "function_name": "add_new_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1275-1285",
    "snippet": "static int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&p->list",
            "&ap->list"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "ap",
            "true"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "670-706",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cleanup_rp_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1253-1271",
    "snippet": "static void cleanup_rp_inst(struct kretprobe *rp)\n{\n\tunsigned long flags, hash;\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\tstruct hlist_head *head;\n\n\t/* No race here */\n\tfor (hash = 0; hash < KPROBE_TABLE_SIZE; hash++) {\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thead = &kretprobe_inst_table[hash];\n\t\thlist_for_each_entry_safe(ri, next, head, hlist) {\n\t\t\tif (ri->rp == rp)\n\t\t\t\tri->rp = NULL;\n\t\t}\n\t\tkretprobe_table_unlock(hash, &flags);\n\t}\n\tfree_rp_inst(rp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rp_inst",
          "args": [
            "rp"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "free_rp_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1242-1251",
          "snippet": "static inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\n\thlist_for_each_entry_safe(ri, next, &rp->free_instances, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\n\thlist_for_each_entry_safe(ri, next, &rp->free_instances, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_table_unlock",
          "args": [
            "hash",
            "&flags"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1200-1206",
          "snippet": "static void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "next",
            "head",
            "hlist"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock",
          "args": [
            "hash",
            "&flags"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1179-1185",
          "snippet": "static void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\n\nstatic void cleanup_rp_inst(struct kretprobe *rp)\n{\n\tunsigned long flags, hash;\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\tstruct hlist_head *head;\n\n\t/* No race here */\n\tfor (hash = 0; hash < KPROBE_TABLE_SIZE; hash++) {\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thead = &kretprobe_inst_table[hash];\n\t\thlist_for_each_entry_safe(ri, next, head, hlist) {\n\t\t\tif (ri->rp == rp)\n\t\t\t\tri->rp = NULL;\n\t\t}\n\t\tkretprobe_table_unlock(hash, &flags);\n\t}\n\tfree_rp_inst(rp);\n}"
  },
  {
    "function_name": "free_rp_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1242-1251",
    "snippet": "static inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\n\thlist_for_each_entry_safe(ri, next, &rp->free_instances, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&ri->hlist"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "next",
            "&rp->free_instances",
            "hlist"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_node *next;\n\n\thlist_for_each_entry_safe(ri, next, &rp->free_instances, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}"
  },
  {
    "function_name": "kprobe_flush_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1215-1239",
    "snippet": "void kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long hash, flags = 0;\n\n\tif (unlikely(!kprobes_initialized))\n\t\t/* Early boot.  kretprobe_table_locks not yet initialized. */\n\t\treturn;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\thash = hash_ptr(tk, KPROBE_HASH_BITS);\n\thead = &kretprobe_inst_table[hash];\n\tkretprobe_table_lock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task == tk)\n\t\t\trecycle_rp_inst(ri, &empty_rp);\n\t}\n\tkretprobe_table_unlock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static int kprobes_initialized;",
      "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];",
      "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&ri->hlist"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "tmp",
            "&empty_rp",
            "hlist"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_table_unlock",
          "args": [
            "hash",
            "&flags"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1200-1206",
          "snippet": "static void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recycle_rp_inst",
          "args": [
            "ri",
            "&empty_rp"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "recycle_rp_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1148-1163",
          "snippet": "void recycle_rp_inst(struct kretprobe_instance *ri,\n\t\t     struct hlist_head *head)\n{\n\tstruct kretprobe *rp = ri->rp;\n\n\t/* remove rp inst off the rprobe_inst_table */\n\thlist_del(&ri->hlist);\n\tINIT_HLIST_NODE(&ri->hlist);\n\tif (likely(rp)) {\n\t\traw_spin_lock(&rp->lock);\n\t\thlist_add_head(&ri->hlist, &rp->free_instances);\n\t\traw_spin_unlock(&rp->lock);\n\t} else\n\t\t/* Unregistering */\n\t\thlist_add_head(&ri->hlist, head);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid recycle_rp_inst(struct kretprobe_instance *ri,\n\t\t     struct hlist_head *head)\n{\n\tstruct kretprobe *rp = ri->rp;\n\n\t/* remove rp inst off the rprobe_inst_table */\n\thlist_del(&ri->hlist);\n\tINIT_HLIST_NODE(&ri->hlist);\n\tif (likely(rp)) {\n\t\traw_spin_lock(&rp->lock);\n\t\thlist_add_head(&ri->hlist, &rp->free_instances);\n\t\traw_spin_unlock(&rp->lock);\n\t} else\n\t\t/* Unregistering */\n\t\thlist_add_head(&ri->hlist, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "tmp",
            "head",
            "hlist"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock",
          "args": [
            "hash",
            "&flags"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1179-1185",
          "snippet": "static void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "tk",
            "KPROBE_HASH_BITS"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&empty_rp"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!kprobes_initialized"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic int kprobes_initialized;\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nvoid kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long hash, flags = 0;\n\n\tif (unlikely(!kprobes_initialized))\n\t\t/* Early boot.  kretprobe_table_locks not yet initialized. */\n\t\treturn;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\thash = hash_ptr(tk, KPROBE_HASH_BITS);\n\thead = &kretprobe_inst_table[hash];\n\tkretprobe_table_lock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task == tk)\n\t\t\trecycle_rp_inst(ri, &empty_rp);\n\t}\n\tkretprobe_table_unlock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}"
  },
  {
    "function_name": "kretprobe_table_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1200-1206",
    "snippet": "static void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "hlist_lock",
            "*flags"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock_ptr",
          "args": [
            "hash"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "81-84",
          "snippet": "static raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "hlist_lock"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_unlock(unsigned long hash,\n\t\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}"
  },
  {
    "function_name": "kretprobe_hash_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1188-1197",
    "snippet": "void kretprobe_hash_unlock(struct task_struct *tsk,\n\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\tunsigned long hash = hash_ptr(tsk, KPROBE_HASH_BITS);\n\traw_spinlock_t *hlist_lock;\n\n\thlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "hlist_lock",
            "*flags"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock_ptr",
          "args": [
            "hash"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "81-84",
          "snippet": "static raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "tsk",
            "KPROBE_HASH_BITS"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "hlist_lock"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nvoid kretprobe_hash_unlock(struct task_struct *tsk,\n\t\t\t   unsigned long *flags)\n__releases(hlist_lock)\n{\n\tunsigned long hash = hash_ptr(tsk, KPROBE_HASH_BITS);\n\traw_spinlock_t *hlist_lock;\n\n\thlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_unlock_irqrestore(hlist_lock, *flags);\n}"
  },
  {
    "function_name": "kretprobe_table_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1179-1185",
    "snippet": "static void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "hlist_lock",
            "*flags"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock_ptr",
          "args": [
            "hash"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "81-84",
          "snippet": "static raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "hlist_lock"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kretprobe_table_lock(unsigned long hash,\n\t\t\t\t unsigned long *flags)\n__acquires(hlist_lock)\n{\n\traw_spinlock_t *hlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}"
  },
  {
    "function_name": "kretprobe_hash_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1166-1176",
    "snippet": "void kretprobe_hash_lock(struct task_struct *tsk,\n\t\t\t struct hlist_head **head, unsigned long *flags)\n__acquires(hlist_lock)\n{\n\tunsigned long hash = hash_ptr(tsk, KPROBE_HASH_BITS);\n\traw_spinlock_t *hlist_lock;\n\n\t*head = &kretprobe_inst_table[hash];\n\thlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "hlist_lock",
            "*flags"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_table_lock_ptr",
          "args": [
            "hash"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_table_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "81-84",
          "snippet": "static raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "tsk",
            "KPROBE_HASH_BITS"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "hlist_lock"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\n\nvoid kretprobe_hash_lock(struct task_struct *tsk,\n\t\t\t struct hlist_head **head, unsigned long *flags)\n__acquires(hlist_lock)\n{\n\tunsigned long hash = hash_ptr(tsk, KPROBE_HASH_BITS);\n\traw_spinlock_t *hlist_lock;\n\n\t*head = &kretprobe_inst_table[hash];\n\thlist_lock = kretprobe_table_lock_ptr(hash);\n\traw_spin_lock_irqsave(hlist_lock, *flags);\n}"
  },
  {
    "function_name": "recycle_rp_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1148-1163",
    "snippet": "void recycle_rp_inst(struct kretprobe_instance *ri,\n\t\t     struct hlist_head *head)\n{\n\tstruct kretprobe *rp = ri->rp;\n\n\t/* remove rp inst off the rprobe_inst_table */\n\thlist_del(&ri->hlist);\n\tINIT_HLIST_NODE(&ri->hlist);\n\tif (likely(rp)) {\n\t\traw_spin_lock(&rp->lock);\n\t\thlist_add_head(&ri->hlist, &rp->free_instances);\n\t\traw_spin_unlock(&rp->lock);\n\t} else\n\t\t/* Unregistering */\n\t\thlist_add_head(&ri->hlist, head);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&ri->hlist",
            "head"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rp->lock"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&ri->hlist",
            "&rp->free_instances"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rp->lock"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rp"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&ri->hlist"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&ri->hlist"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid recycle_rp_inst(struct kretprobe_instance *ri,\n\t\t     struct hlist_head *head)\n{\n\tstruct kretprobe *rp = ri->rp;\n\n\t/* remove rp inst off the rprobe_inst_table */\n\thlist_del(&ri->hlist);\n\tINIT_HLIST_NODE(&ri->hlist);\n\tif (likely(rp)) {\n\t\traw_spin_lock(&rp->lock);\n\t\thlist_add_head(&ri->hlist, &rp->free_instances);\n\t\traw_spin_unlock(&rp->lock);\n\t} else\n\t\t/* Unregistering */\n\t\thlist_add_head(&ri->hlist, head);\n}"
  },
  {
    "function_name": "kprobes_inc_nmissed_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1135-1145",
    "snippet": "void kprobes_inc_nmissed_count(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\tif (!kprobe_aggrprobe(p)) {\n\t\tp->nmissed++;\n\t} else {\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->nmissed++;\n\t}\n\treturn;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid kprobes_inc_nmissed_count(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\tif (!kprobe_aggrprobe(p)) {\n\t\tp->nmissed++;\n\t} else {\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->nmissed++;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "aggr_fault_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1117-1131",
    "snippet": "static int aggr_fault_handler(struct kprobe *p, struct pt_regs *regs,\n\t\t\t      int trapnr)\n{\n\tstruct kprobe *cur = __this_cpu_read(kprobe_instance);\n\n\t/*\n\t * if we faulted \"during\" the execution of a user specified\n\t * probe handler, invoke just that probe's fault handler\n\t */\n\tif (cur && cur->fault_handler) {\n\t\tif (cur->fault_handler(cur, regs, trapnr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;",
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur->fault_handler",
          "args": [
            "cur",
            "regs",
            "trapnr"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "kprobe_instance"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic int aggr_fault_handler(struct kprobe *p, struct pt_regs *regs,\n\t\t\t      int trapnr)\n{\n\tstruct kprobe *cur = __this_cpu_read(kprobe_instance);\n\n\t/*\n\t * if we faulted \"during\" the execution of a user specified\n\t * probe handler, invoke just that probe's fault handler\n\t */\n\tif (cur && cur->fault_handler) {\n\t\tif (cur->fault_handler(cur, regs, trapnr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "aggr_post_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1102-1114",
    "snippet": "static void aggr_post_handler(struct kprobe *p, struct pt_regs *regs,\n\t\t\t      unsigned long flags)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->post_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->post_handler(kp, regs, flags);\n\t\t\treset_kprobe_instance();\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_kprobe_instance",
          "args": [],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "reset_kprobe_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "325-328",
          "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kp->post_handler",
          "args": [
            "kp",
            "regs",
            "flags"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_kprobe_instance",
          "args": [
            "kp"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "set_kprobe_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "320-323",
          "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kprobe_disabled(kp)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic void aggr_post_handler(struct kprobe *p, struct pt_regs *regs,\n\t\t\t      unsigned long flags)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->post_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->post_handler(kp, regs, flags);\n\t\t\treset_kprobe_instance();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "aggr_pre_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1086-1099",
    "snippet": "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tif (kp->pre_handler(kp, regs))\n\t\t\t\treturn 1;\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_kprobe_instance",
          "args": [],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "reset_kprobe_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "325-328",
          "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kp->pre_handler",
          "args": [
            "kp",
            "regs"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_kprobe_instance",
          "args": [
            "kp"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "set_kprobe_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "320-323",
          "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kprobe_disabled(kp)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tif (kp->pre_handler(kp, regs))\n\t\t\t\treturn 1;\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "disarm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1068-1080",
    "snippet": "static int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disarm_kprobe",
          "args": [
            "kp",
            "reopt"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "__disarm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "924-939",
          "snippet": "static void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, optimize it. */\n\t\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/* TODO: reoptimize others after unoptimized this probe */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, optimize it. */\n\t\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/* TODO: reoptimize others after unoptimized this probe */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disarm_kprobe_ftrace",
          "args": [
            "kp"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1028-1045",
          "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kprobe_ftrace(kp)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1053-1065",
    "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__arm_kprobe",
          "args": [
            "kp"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "__arm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "909-921",
          "snippet": "static void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\t/* Check collision with other optimized kprobes */\n\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\t/* Check collision with other optimized kprobes */\n\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arm_kprobe_ftrace",
          "args": [
            "kp"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1028-1045",
          "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kprobe_ftrace(kp)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "disarm_kprobe_ftrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "1028-1045",
    "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "ret < 0",
            "\"Failed to disarm kprobe-ftrace at %pS (%d)\\n\"",
            "p->addr",
            "ret"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&kprobe_ftrace_ops",
            "(unsigned long)p->addr",
            "1",
            "0"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4754-4759",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "ret < 0",
            "\"Failed to unregister kprobe-ftrace (%d)\\n\"",
            "ret"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&kprobe_ftrace_ops"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "arm_kprobe_ftrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "994-1025",
    "snippet": "static int arm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t\t   (unsigned long)p->addr, 0, 0);\n\tif (ret) {\n\t\tpr_debug(\"Failed to arm kprobe-ftrace at %pS (%d)\\n\",\n\t\t\t p->addr, ret);\n\t\treturn ret;\n\t}\n\n\tif (kprobe_ftrace_enabled == 0) {\n\t\tret = register_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (ret) {\n\t\t\tpr_debug(\"Failed to init kprobe-ftrace (%d)\\n\", ret);\n\t\t\tgoto err_ftrace;\n\t\t}\n\t}\n\n\tkprobe_ftrace_enabled++;\n\treturn ret;\n\nerr_ftrace:\n\t/*\n\t * Note: Since kprobe_ftrace_ops has IPMODIFY set, and ftrace requires a\n\t * non-empty filter_hash for IPMODIFY ops, we're safe from an accidental\n\t * empty filter_hash which would undesirably trace all functions.\n\t */\n\tftrace_set_filter_ip(&kprobe_ftrace_ops, (unsigned long)p->addr, 1, 0);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&kprobe_ftrace_ops",
            "(unsigned long)p->addr",
            "1",
            "0"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4754-4759",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Failed to init kprobe-ftrace (%d)\\n\"",
            "ret"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&kprobe_ftrace_ops"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Failed to arm kprobe-ftrace at %pS (%d)\\n\"",
            "p->addr",
            "ret"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t\t   (unsigned long)p->addr, 0, 0);\n\tif (ret) {\n\t\tpr_debug(\"Failed to arm kprobe-ftrace at %pS (%d)\\n\",\n\t\t\t p->addr, ret);\n\t\treturn ret;\n\t}\n\n\tif (kprobe_ftrace_enabled == 0) {\n\t\tret = register_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (ret) {\n\t\t\tpr_debug(\"Failed to init kprobe-ftrace (%d)\\n\", ret);\n\t\t\tgoto err_ftrace;\n\t\t}\n\t}\n\n\tkprobe_ftrace_enabled++;\n\treturn ret;\n\nerr_ftrace:\n\t/*\n\t * Note: Since kprobe_ftrace_ops has IPMODIFY set, and ftrace requires a\n\t * non-empty filter_hash for IPMODIFY ops, we're safe from an accidental\n\t * empty filter_hash which would undesirably trace all functions.\n\t */\n\tftrace_set_filter_ip(&kprobe_ftrace_ops, (unsigned long)p->addr, 1, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "prepare_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "985-991",
    "snippet": "static int prepare_kprobe(struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe(p);\n\n\treturn arch_prepare_kprobe_ftrace(p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepare_kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepare_kprobe",
          "args": [
            "p"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1028-1045",
          "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int prepare_kprobe(struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe(p);\n\n\treturn arch_prepare_kprobe_ftrace(p);\n}"
  },
  {
    "function_name": "alloc_aggr_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "971-974",
    "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kprobe)",
            "GFP_KERNEL"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}"
  },
  {
    "function_name": "free_aggr_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "965-969",
    "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}"
  },
  {
    "function_name": "reuse_unused_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "953-963",
    "snippet": "static int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tprintk(KERN_ERR \"Error: There should be no unused kprobe here.\\n\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error: There should be no unused kprobe here.\\n\""
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tprintk(KERN_ERR \"Error: There should be no unused kprobe here.\\n\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__disarm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "924-939",
    "snippet": "static void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, optimize it. */\n\t\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/* TODO: reoptimize others after unoptimized this probe */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "_p"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "_p"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_optimized_kprobe",
          "args": [
            "(unsigned long)p->addr"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "get_optimized_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "452-469",
          "snippet": "static struct kprobe *get_optimized_kprobe(unsigned long addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *get_optimized_kprobe(unsigned long addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_disarm_kprobe",
          "args": [
            "p"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_queued",
          "args": [
            "p"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "436-446",
          "snippet": "static int kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "p",
            "kprobes_all_disarmed"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "670-706",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, optimize it. */\n\t\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/* TODO: reoptimize others after unoptimized this probe */\n}"
  },
  {
    "function_name": "__arm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "909-921",
    "snippet": "static void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\t/* Check collision with other optimized kprobes */\n\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "p"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_arm_kprobe",
          "args": [
            "p"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "_p",
            "true"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "670-706",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "_p"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_optimized_kprobe",
          "args": [
            "(unsigned long)p->addr"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "get_optimized_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "452-469",
          "snippet": "static struct kprobe *get_optimized_kprobe(unsigned long addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *get_optimized_kprobe(unsigned long addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\t/* Check collision with other optimized kprobes */\n\t_p = get_optimized_kprobe((unsigned long)p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}"
  },
  {
    "function_name": "proc_kprobes_optimization_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "888-905",
    "snippet": "int proc_kprobes_optimization_handler(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer, size_t *length,\n\t\t\t\t      loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&kprobe_sysctl_mutex);\n\tsysctl_kprobes_optimization = kprobes_allow_optimization ? 1 : 0;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\tif (sysctl_kprobes_optimization)\n\t\toptimize_all_kprobes();\n\telse\n\t\tunoptimize_all_kprobes();\n\tmutex_unlock(&kprobe_sysctl_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_sysctl_mutex"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unoptimize_all_kprobes",
          "args": [],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_all_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "856-884",
          "snippet": "static void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion */\n\twait_for_kprobe_optimizer();\n\tprintk(KERN_INFO \"Kprobes globally unoptimized\\n\");\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion */\n\twait_for_kprobe_optimizer();\n\tprintk(KERN_INFO \"Kprobes globally unoptimized\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_sysctl_mutex"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint proc_kprobes_optimization_handler(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer, size_t *length,\n\t\t\t\t      loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&kprobe_sysctl_mutex);\n\tsysctl_kprobes_optimization = kprobes_allow_optimization ? 1 : 0;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\tif (sysctl_kprobes_optimization)\n\t\toptimize_all_kprobes();\n\telse\n\t\tunoptimize_all_kprobes();\n\tmutex_unlock(&kprobe_sysctl_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unoptimize_all_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "856-884",
    "snippet": "static void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion */\n\twait_for_kprobe_optimizer();\n\tprintk(KERN_INFO \"Kprobes globally unoptimized\\n\");\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Kprobes globally unoptimized\\n\""
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_kprobe_optimizer",
          "args": [],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_kprobe_optimizer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "608-624",
          "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "p",
            "false"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "670-706",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion */\n\twait_for_kprobe_optimizer();\n\tprintk(KERN_INFO \"Kprobes globally unoptimized\\n\");\n}"
  },
  {
    "function_name": "optimize_all_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "831-854",
    "snippet": "static void optimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already allowed, just return */\n\tif (kprobes_allow_optimization)\n\t\tgoto out;\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = true;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\toptimize_kprobe(p);\n\t}\n\tcpus_read_unlock();\n\tprintk(KERN_INFO \"Kprobes globally optimized\\n\");\nout:\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Kprobes globally optimized\\n\""
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "p"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void optimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already allowed, just return */\n\tif (kprobes_allow_optimization)\n\t\tgoto out;\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = true;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\toptimize_kprobe(p);\n\t}\n\tcpus_read_unlock();\n\tprintk(KERN_INFO \"Kprobes globally optimized\\n\");\nout:\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "try_to_optimize_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "795-828",
    "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "ap"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "init_aggr_kprobe",
          "args": [
            "ap",
            "p"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "init_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1291-1309",
          "snippet": "static void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy p's insn slot to ap */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\tap->fault_handler = aggr_fault_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy p's insn slot to ap */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\tap->fault_handler = aggr_fault_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepared_optinsn",
          "args": [
            "&op->optinsn"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ap",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_aggr_kprobe",
          "args": [
            "p"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "971-974",
          "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1028-1045",
          "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "alloc_aggr_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "774-787",
    "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = kzalloc(sizeof(struct optimized_kprobe), GFP_KERNEL);\n\tif (!op)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&op->list);\n\top->kp.addr = p->addr;\n\t__prepare_optimized_kprobe(op, p);\n\n\treturn &op->kp;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__prepare_optimized_kprobe",
          "args": [
            "op",
            "p"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "__prepare_optimized_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "757-762",
          "snippet": "static inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&op->list"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct optimized_kprobe)",
            "GFP_KERNEL"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = kzalloc(sizeof(struct optimized_kprobe), GFP_KERNEL);\n\tif (!op)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&op->list);\n\top->kp.addr = p->addr;\n\t__prepare_optimized_kprobe(op, p);\n\n\treturn &op->kp;\n}"
  },
  {
    "function_name": "prepare_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "765-771",
    "snippet": "static void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__prepare_optimized_kprobe",
          "args": [
            "op",
            "p"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "__prepare_optimized_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "757-762",
          "snippet": "static inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}"
  },
  {
    "function_name": "__prepare_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "757-762",
    "snippet": "static inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepare_optimized_kprobe",
          "args": [
            "op",
            "p"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1028-1045",
          "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tif (kprobe_ftrace_enabled == 1) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (%d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\tkprobe_ftrace_enabled--;\n\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (%d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}"
  },
  {
    "function_name": "kill_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "732-755",
    "snippet": "static void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_remove_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&op->kp.hlist"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&op->list",
            "&freeing_list"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "p"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "360-364",
          "snippet": "static inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}"
  },
  {
    "function_name": "reuse_unused_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "709-729",
    "snippet": "static int reuse_unused_kprobe(struct kprobe *ap)\n{\n\tstruct optimized_kprobe *op;\n\tint ret;\n\n\t/*\n\t * Unused kprobe MUST be on the way of delayed unoptimizing (means\n\t * there is still a relative jump) and disabled.\n\t */\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tWARN_ON_ONCE(list_empty(&op->list));\n\t/* Enable the probe again */\n\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t/* Optimize it again (remove from op->list) */\n\tret = kprobe_optready(ap);\n\tif (ret)\n\t\treturn ret;\n\n\toptimize_kprobe(ap);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "ap"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "795-828",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optready",
          "args": [
            "ap"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_optready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "409-419",
          "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&op->list)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ap",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int reuse_unused_kprobe(struct kprobe *ap)\n{\n\tstruct optimized_kprobe *op;\n\tint ret;\n\n\t/*\n\t * Unused kprobe MUST be on the way of delayed unoptimizing (means\n\t * there is still a relative jump) and disabled.\n\t */\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tWARN_ON_ONCE(list_empty(&op->list));\n\t/* Enable the probe again */\n\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t/* Optimize it again (remove from op->list) */\n\tret = kprobe_optready(ap);\n\tif (ret)\n\t\treturn ret;\n\n\toptimize_kprobe(ap);\n\treturn 0;\n}"
  },
  {
    "function_name": "unoptimize_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "670-706",
    "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_kprobe_optimizer",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "kick_kprobe_optimizer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "562-565",
          "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define OPTIMIZE_DELAY 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&op->list",
            "&unoptimizing_list"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_unoptimize_kprobe",
          "args": [
            "op"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "force_unoptimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "661-667",
          "snippet": "static void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\tif (kprobe_disabled(&op->kp))\n\t\tarch_disarm_kprobe(&op->kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\tif (kprobe_disabled(&op->kp))\n\t\tarch_disarm_kprobe(&op->kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_optimized",
          "args": [
            "p"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disarmed",
          "args": [
            "p"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_disarmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "422-433",
          "snippet": "static inline int kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p)) {\n\t\t/* Unoptimized or unoptimizing case */\n\t\tif (force && !list_empty(&op->list)) {\n\t\t\t/*\n\t\t\t * Only if this is unoptimizing kprobe and forced,\n\t\t\t * forcibly unoptimize it. (No need to unoptimize\n\t\t\t * unoptimized kprobe again :)\n\t\t\t */\n\t\t\tlist_del_init(&op->list);\n\t\t\tforce_unoptimize_kprobe(op);\n\t\t}\n\t\treturn;\n\t}\n\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\tif (!list_empty(&op->list)) {\n\t\t/* Dequeue from the optimization queue */\n\t\tlist_del_init(&op->list);\n\t\treturn;\n\t}\n\t/* Optimized kprobe case */\n\tif (force)\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\telse {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
  },
  {
    "function_name": "force_unoptimize_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "661-667",
    "snippet": "static void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\tif (kprobe_disabled(&op->kp))\n\t\tarch_disarm_kprobe(&op->kp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_disarm_kprobe",
          "args": [
            "&op->kp"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "&op->kp"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_unoptimize_kprobe",
          "args": [
            "op"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\tif (kprobe_disabled(&op->kp))\n\t\tarch_disarm_kprobe(&op->kp);\n}"
  },
  {
    "function_name": "optimize_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "627-658",
    "snippet": "static void optimize_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* Check if the kprobe is disabled or not ready for optimization. */\n\tif (!kprobe_optready(p) || !kprobes_allow_optimization ||\n\t    (kprobe_disabled(p) || kprobes_all_disarmed))\n\t\treturn;\n\n\t/* kprobes with post_handler can not be optimized */\n\tif (p->post_handler)\n\t\treturn;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\t/* Check there is no other kprobes at the optimized instructions */\n\tif (arch_check_optimized_kprobe(op) < 0)\n\t\treturn;\n\n\t/* Check if it is already optimized. */\n\tif (op->kp.flags & KPROBE_FLAG_OPTIMIZED)\n\t\treturn;\n\top->kp.flags |= KPROBE_FLAG_OPTIMIZED;\n\n\tif (!list_empty(&op->list))\n\t\t/* This is under unoptimizing. Just dequeue the probe */\n\t\tlist_del_init(&op->list);\n\telse {\n\t\tlist_add(&op->list, &optimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_kprobe_optimizer",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "kick_kprobe_optimizer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "562-565",
          "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define OPTIMIZE_DELAY 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&op->list",
            "&optimizing_list"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optready",
          "args": [
            "p"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_optready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "409-419",
          "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void optimize_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* Check if the kprobe is disabled or not ready for optimization. */\n\tif (!kprobe_optready(p) || !kprobes_allow_optimization ||\n\t    (kprobe_disabled(p) || kprobes_all_disarmed))\n\t\treturn;\n\n\t/* kprobes with post_handler can not be optimized */\n\tif (p->post_handler)\n\t\treturn;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\t/* Check there is no other kprobes at the optimized instructions */\n\tif (arch_check_optimized_kprobe(op) < 0)\n\t\treturn;\n\n\t/* Check if it is already optimized. */\n\tif (op->kp.flags & KPROBE_FLAG_OPTIMIZED)\n\t\treturn;\n\top->kp.flags |= KPROBE_FLAG_OPTIMIZED;\n\n\tif (!list_empty(&op->list))\n\t\t/* This is under unoptimizing. Just dequeue the probe */\n\t\tlist_del_init(&op->list);\n\telse {\n\t\tlist_add(&op->list, &optimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
  },
  {
    "function_name": "wait_for_kprobe_optimizer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "608-624",
    "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&optimizing_work"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "flush_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3056-3063",
          "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&unoptimizing_list"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "kprobe_optimizer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "568-605",
    "snippet": "static void kprobe_optimizer(struct work_struct *work)\n{\n\tmutex_lock(&kprobe_mutex);\n\tcpus_read_lock();\n\t/* Lock modules while optimizing kprobes */\n\tmutex_lock(&module_mutex);\n\n\t/*\n\t * Step 1: Unoptimize kprobes and collect cleaned (unused and disarmed)\n\t * kprobes before waiting for quiesence period.\n\t */\n\tdo_unoptimize_kprobes();\n\n\t/*\n\t * Step 2: Wait for quiesence period to ensure all potentially\n\t * preempted tasks to have normally scheduled. Because optprobe\n\t * may modify multiple instructions, there is a chance that Nth\n\t * instruction is preempted. In that case, such tasks can return\n\t * to 2nd-Nth byte of jump instruction. This wait is for avoiding it.\n\t * Note that on non-preemptive kernel, this is transparently converted\n\t * to synchronoze_sched() to wait for all interrupts to have completed.\n\t */\n\tsynchronize_rcu_tasks();\n\n\t/* Step 3: Optimize kprobes after quiesence period */\n\tdo_optimize_kprobes();\n\n\t/* Step 4: Free cleaned kprobes after quiesence period */\n\tdo_free_cleaned_kprobes();\n\n\tmutex_unlock(&module_mutex);\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Step 5: Kick optimizer again if needed */\n\tif (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list))\n\t\tkick_kprobe_optimizer();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_kprobe_optimizer",
          "args": [],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "kick_kprobe_optimizer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "562-565",
          "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define OPTIMIZE_DELAY 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&unoptimizing_list"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_free_cleaned_kprobes",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "do_free_cleaned_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "544-559",
          "snippet": "static void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_optimize_kprobes",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "do_optimize_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "484-506",
          "snippet": "static void do_optimize_kprobes(void)\n{\n\t/*\n\t * The optimization/unoptimization refers online_cpus via\n\t * stop_machine() and cpu-hotplug modifies online_cpus.\n\t * And same time, text_mutex will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug try to lock\n\t * text_mutex but stop_machine can not be done because online_cpus\n\t * has been changed)\n\t * To avoid this deadlock, caller must have locked cpu hotplug\n\t * for preventing cpu-hotplug outside of text_mutex locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_optimize_kprobes(&optimizing_list);\n\tmutex_unlock(&text_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void do_optimize_kprobes(void)\n{\n\t/*\n\t * The optimization/unoptimization refers online_cpus via\n\t * stop_machine() and cpu-hotplug modifies online_cpus.\n\t * And same time, text_mutex will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug try to lock\n\t * text_mutex but stop_machine can not be done because online_cpus\n\t * has been changed)\n\t * To avoid this deadlock, caller must have locked cpu hotplug\n\t * for preventing cpu-hotplug outside of text_mutex locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_optimize_kprobes(&optimizing_list);\n\tmutex_unlock(&text_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unoptimize_kprobes",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "do_unoptimize_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "512-541",
          "snippet": "static void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop free_list for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes.)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n\tmutex_unlock(&text_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop free_list for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes.)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n\tmutex_unlock(&text_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&module_mutex"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void kprobe_optimizer(struct work_struct *work)\n{\n\tmutex_lock(&kprobe_mutex);\n\tcpus_read_lock();\n\t/* Lock modules while optimizing kprobes */\n\tmutex_lock(&module_mutex);\n\n\t/*\n\t * Step 1: Unoptimize kprobes and collect cleaned (unused and disarmed)\n\t * kprobes before waiting for quiesence period.\n\t */\n\tdo_unoptimize_kprobes();\n\n\t/*\n\t * Step 2: Wait for quiesence period to ensure all potentially\n\t * preempted tasks to have normally scheduled. Because optprobe\n\t * may modify multiple instructions, there is a chance that Nth\n\t * instruction is preempted. In that case, such tasks can return\n\t * to 2nd-Nth byte of jump instruction. This wait is for avoiding it.\n\t * Note that on non-preemptive kernel, this is transparently converted\n\t * to synchronoze_sched() to wait for all interrupts to have completed.\n\t */\n\tsynchronize_rcu_tasks();\n\n\t/* Step 3: Optimize kprobes after quiesence period */\n\tdo_optimize_kprobes();\n\n\t/* Step 4: Free cleaned kprobes after quiesence period */\n\tdo_free_cleaned_kprobes();\n\n\tmutex_unlock(&module_mutex);\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Step 5: Kick optimizer again if needed */\n\tif (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list))\n\t\tkick_kprobe_optimizer();\n}"
  },
  {
    "function_name": "kick_kprobe_optimizer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "562-565",
    "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define OPTIMIZE_DELAY 5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&optimizing_work",
            "OPTIMIZE_DELAY"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
  },
  {
    "function_name": "do_free_cleaned_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "544-559",
    "snippet": "static void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_aggr_kprobe",
          "args": [
            "&op->kp"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "free_aggr_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "965-969",
          "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kprobe_unused(&op->kp)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "&op->kp"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "360-364",
          "snippet": "static inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "op",
            "tmp",
            "&freeing_list",
            "list"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}"
  },
  {
    "function_name": "do_unoptimize_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "512-541",
    "snippet": "static void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop free_list for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes.)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n\tmutex_unlock(&text_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&op->kp.hlist"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "&op->kp"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "360-364",
          "snippet": "static inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_disarm_kprobe",
          "args": [
            "&op->kp"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "&op->kp"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "op",
            "tmp",
            "&freeing_list",
            "list"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_unoptimize_kprobes",
          "args": [
            "&unoptimizing_list",
            "&freeing_list"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&unoptimizing_list"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop free_list for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes.)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n\tmutex_unlock(&text_mutex);\n}"
  },
  {
    "function_name": "do_optimize_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "484-506",
    "snippet": "static void do_optimize_kprobes(void)\n{\n\t/*\n\t * The optimization/unoptimization refers online_cpus via\n\t * stop_machine() and cpu-hotplug modifies online_cpus.\n\t * And same time, text_mutex will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug try to lock\n\t * text_mutex but stop_machine can not be done because online_cpus\n\t * has been changed)\n\t * To avoid this deadlock, caller must have locked cpu hotplug\n\t * for preventing cpu-hotplug outside of text_mutex locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_optimize_kprobes(&optimizing_list);\n\tmutex_unlock(&text_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_optimize_kprobes",
          "args": [
            "&optimizing_list"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&optimizing_list"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void do_optimize_kprobes(void)\n{\n\t/*\n\t * The optimization/unoptimization refers online_cpus via\n\t * stop_machine() and cpu-hotplug modifies online_cpus.\n\t * And same time, text_mutex will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug try to lock\n\t * text_mutex but stop_machine can not be done because online_cpus\n\t * has been changed)\n\t * To avoid this deadlock, caller must have locked cpu hotplug\n\t * for preventing cpu-hotplug outside of text_mutex locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tmutex_lock(&text_mutex);\n\tarch_optimize_kprobes(&optimizing_list);\n\tmutex_unlock(&text_mutex);\n}"
  },
  {
    "function_name": "get_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "452-469",
    "snippet": "static struct kprobe *get_optimized_kprobe(unsigned long addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_within_optimized_kprobe",
          "args": [
            "op",
            "addr"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_optready",
          "args": [
            "p"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_optready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "409-419",
          "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "(void *)(addr - i)"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "get_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "336-348",
          "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *get_optimized_kprobe(unsigned long addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "kprobe_queued",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "436-446",
    "snippet": "static int kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_disarmed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "422-433",
    "snippet": "static inline int kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}"
  },
  {
    "function_name": "kprobe_optready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "409-419",
    "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepared_optinsn",
          "args": [
            "&op->optinsn"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_aggr_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "398-406",
    "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tarch_remove_optimized_kprobe(op);\n\tarch_remove_kprobe(p);\n\tkfree(op);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_remove_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tarch_remove_optimized_kprobe(op);\n\tarch_remove_kprobe(p);\n\tkfree(op);\n}"
  },
  {
    "function_name": "opt_pre_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "383-394",
    "snippet": "void opt_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->pre_handler(kp, regs);\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_kprobe_instance",
          "args": [],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "reset_kprobe_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "325-328",
          "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kp->pre_handler",
          "args": [
            "kp",
            "regs"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_kprobe_instance",
          "args": [
            "kp"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "set_kprobe_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "320-323",
          "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kprobe_disabled(kp)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nvoid opt_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->pre_handler(kp, regs);\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n}"
  },
  {
    "function_name": "copy_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "369-373",
    "snippet": "static inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&p->ainsn",
            "&ap->ainsn",
            "sizeof(struct arch_specific_insn)"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}"
  },
  {
    "function_name": "kprobe_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "360-364",
    "snippet": "static inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&p->list"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1618-1631",
          "snippet": "static int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * There is an active probe on the list.\n\t\t\t * We can't disable this ap.\n\t\t\t */\n\t\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "354-357",
          "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
  },
  {
    "function_name": "kprobe_aggrprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "354-357",
    "snippet": "static inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
  },
  {
    "function_name": "get_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "336-348",
    "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "addr",
            "KPROBE_HASH_BITS"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "reset_kprobe_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "325-328",
    "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "kprobe_instance",
            "NULL"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
  },
  {
    "function_name": "set_kprobe_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "320-323",
    "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "kprobe_instance",
            "kp"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance) = NULL;\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
  },
  {
    "function_name": "__is_insn_slot_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "288-304",
    "snippet": "bool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__free_insn_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "248-281",
    "snippet": "void __free_insn_slot(struct kprobe_insn_cache *c,\n\t\t      kprobe_opcode_t *slot, int dirty)\n{\n\tstruct kprobe_insn_page *kip;\n\tlong idx;\n\n\tmutex_lock(&c->mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tidx = ((long)slot - (long)kip->insns) /\n\t\t\t(c->insn_size * sizeof(kprobe_opcode_t));\n\t\tif (idx >= 0 && idx < slots_per_page(c))\n\t\t\tgoto out;\n\t}\n\t/* Could not find this slot. */\n\tWARN_ON(1);\n\tkip = NULL;\nout:\n\trcu_read_unlock();\n\t/* Mark and sweep: this may sleep */\n\tif (kip) {\n\t\t/* Check double free */\n\t\tWARN_ON(kip->slot_used[idx] != SLOT_USED);\n\t\tif (dirty) {\n\t\t\tkip->slot_used[idx] = SLOT_DIRTY;\n\t\t\tkip->ngarbage++;\n\t\t\tif (++c->nr_garbage > slots_per_page(c))\n\t\t\t\tcollect_garbage_slots(c);\n\t\t} else {\n\t\t\tcollect_one_slot(kip, idx);\n\t\t}\n\t}\n\tmutex_unlock(&c->mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&c->mutex"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_one_slot",
          "args": [
            "kip",
            "idx"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "collect_one_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "205-225",
          "snippet": "static int collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_garbage_slots",
          "args": [
            "c"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "collect_garbage_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "227-246",
          "snippet": "static int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_sched();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_sched();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slots_per_page",
          "args": [
            "c"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "slots_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "109-112",
          "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kip->slot_used[idx] != SLOT_USED"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&c->mutex"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __free_insn_slot(struct kprobe_insn_cache *c,\n\t\t      kprobe_opcode_t *slot, int dirty)\n{\n\tstruct kprobe_insn_page *kip;\n\tlong idx;\n\n\tmutex_lock(&c->mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tidx = ((long)slot - (long)kip->insns) /\n\t\t\t(c->insn_size * sizeof(kprobe_opcode_t));\n\t\tif (idx >= 0 && idx < slots_per_page(c))\n\t\t\tgoto out;\n\t}\n\t/* Could not find this slot. */\n\tWARN_ON(1);\n\tkip = NULL;\nout:\n\trcu_read_unlock();\n\t/* Mark and sweep: this may sleep */\n\tif (kip) {\n\t\t/* Check double free */\n\t\tWARN_ON(kip->slot_used[idx] != SLOT_USED);\n\t\tif (dirty) {\n\t\t\tkip->slot_used[idx] = SLOT_DIRTY;\n\t\t\tkip->ngarbage++;\n\t\t\tif (++c->nr_garbage > slots_per_page(c))\n\t\t\t\tcollect_garbage_slots(c);\n\t\t} else {\n\t\t\tcollect_one_slot(kip, idx);\n\t\t}\n\t}\n\tmutex_unlock(&c->mutex);\n}"
  },
  {
    "function_name": "collect_garbage_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "227-246",
    "snippet": "static int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_sched();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_one_slot",
          "args": [
            "kip",
            "i"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "collect_one_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "205-225",
          "snippet": "static int collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slots_per_page",
          "args": [
            "c"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "slots_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "109-112",
          "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "kip",
            "next",
            "&c->pages",
            "list"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_sched();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "collect_one_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "205-225",
    "snippet": "static int collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kip"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kip->cache->free",
          "args": [
            "kip->insns"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&kip->list"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&kip->list"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__get_insn_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "144-202",
    "snippet": "kprobe_opcode_t *__get_insn_slot(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip;\n\tkprobe_opcode_t *slot = NULL;\n\n\t/* Since the slot array is not protected by rcu, we need a mutex */\n\tmutex_lock(&c->mutex);\n retry:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (kip->nused < slots_per_page(c)) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\t\tif (kip->slot_used[i] == SLOT_CLEAN) {\n\t\t\t\t\tkip->slot_used[i] = SLOT_USED;\n\t\t\t\t\tkip->nused++;\n\t\t\t\t\tslot = kip->insns + (i * c->insn_size);\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* kip->nused is broken. Fix it. */\n\t\t\tkip->nused = slots_per_page(c);\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* If there are any garbage slots, collect it and try again. */\n\tif (c->nr_garbage && collect_garbage_slots(c) == 0)\n\t\tgoto retry;\n\n\t/* All out of space.  Need to allocate a new page. */\n\tkip = kmalloc(KPROBE_INSN_PAGE_SIZE(slots_per_page(c)), GFP_KERNEL);\n\tif (!kip)\n\t\tgoto out;\n\n\t/*\n\t * Use module_alloc so this page is within +/- 2GB of where the\n\t * kernel image and loaded module images reside. This is required\n\t * so x86_64 can correctly handle the %rip-relative fixups.\n\t */\n\tkip->insns = c->alloc();\n\tif (!kip->insns) {\n\t\tkfree(kip);\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&kip->list);\n\tmemset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));\n\tkip->slot_used[0] = SLOT_USED;\n\tkip->nused = 1;\n\tkip->ngarbage = 0;\n\tkip->cache = c;\n\tlist_add_rcu(&kip->list, &c->pages);\n\tslot = kip->insns;\nout:\n\tmutex_unlock(&c->mutex);\n\treturn slot;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&c->mutex"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&kip->list",
            "&c->pages"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kip->slot_used",
            "SLOT_CLEAN",
            "slots_per_page(c)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slots_per_page",
          "args": [
            "c"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "slots_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "109-112",
          "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&kip->list"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kip"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->alloc",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "KPROBE_INSN_PAGE_SIZE(slots_per_page(c))",
            "GFP_KERNEL"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KPROBE_INSN_PAGE_SIZE",
          "args": [
            "slots_per_page(c)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_garbage_slots",
          "args": [
            "c"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "collect_garbage_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "227-246",
          "snippet": "static int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_sched();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_sched();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&c->mutex"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nkprobe_opcode_t *__get_insn_slot(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip;\n\tkprobe_opcode_t *slot = NULL;\n\n\t/* Since the slot array is not protected by rcu, we need a mutex */\n\tmutex_lock(&c->mutex);\n retry:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (kip->nused < slots_per_page(c)) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\t\tif (kip->slot_used[i] == SLOT_CLEAN) {\n\t\t\t\t\tkip->slot_used[i] = SLOT_USED;\n\t\t\t\t\tkip->nused++;\n\t\t\t\t\tslot = kip->insns + (i * c->insn_size);\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* kip->nused is broken. Fix it. */\n\t\t\tkip->nused = slots_per_page(c);\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* If there are any garbage slots, collect it and try again. */\n\tif (c->nr_garbage && collect_garbage_slots(c) == 0)\n\t\tgoto retry;\n\n\t/* All out of space.  Need to allocate a new page. */\n\tkip = kmalloc(KPROBE_INSN_PAGE_SIZE(slots_per_page(c)), GFP_KERNEL);\n\tif (!kip)\n\t\tgoto out;\n\n\t/*\n\t * Use module_alloc so this page is within +/- 2GB of where the\n\t * kernel image and loaded module images reside. This is required\n\t * so x86_64 can correctly handle the %rip-relative fixups.\n\t */\n\tkip->insns = c->alloc();\n\tif (!kip->insns) {\n\t\tkfree(kip);\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&kip->list);\n\tmemset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));\n\tkip->slot_used[0] = SLOT_USED;\n\tkip->nused = 1;\n\tkip->ngarbage = 0;\n\tkip->cache = c;\n\tlist_add_rcu(&kip->list, &c->pages);\n\tslot = kip->insns;\nout:\n\tmutex_unlock(&c->mutex);\n\treturn slot;\n}"
  },
  {
    "function_name": "free_insn_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "125-128",
    "snippet": "void __weak free_insn_page(void *page)\n{\n\tmodule_memfree(page);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_memfree",
          "args": [
            "page"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "module_memfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "2113-2116",
          "snippet": "void __weak module_memfree(void *module_region)\n{\n\tvfree(module_region);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid __weak module_memfree(void *module_region)\n{\n\tvfree(module_region);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __weak free_insn_page(void *page)\n{\n\tmodule_memfree(page);\n}"
  },
  {
    "function_name": "alloc_insn_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "120-123",
    "snippet": "void __weak *alloc_insn_page(void)\n{\n\treturn module_alloc(PAGE_SIZE);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_alloc",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "module_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "2731-2734",
          "snippet": "void * __weak module_alloc(unsigned long size)\n{\n\treturn vmalloc_exec(size);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid * __weak module_alloc(unsigned long size)\n{\n\treturn vmalloc_exec(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __weak *alloc_insn_page(void)\n{\n\treturn module_alloc(PAGE_SIZE);\n}"
  },
  {
    "function_name": "slots_per_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "109-112",
    "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
  },
  {
    "function_name": "kretprobe_table_lock_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
    "lines": "81-84",
    "snippet": "static raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}"
  }
]