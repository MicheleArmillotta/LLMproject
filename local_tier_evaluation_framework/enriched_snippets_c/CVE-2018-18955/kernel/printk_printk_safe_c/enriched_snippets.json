[
  {
    "function_name": "printk_safe_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "401-427",
    "snippet": "void __init printk_safe_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct printk_safe_seq_buf *s;\n\n\t\ts = &per_cpu(safe_print_seq, cpu);\n\t\tinit_irq_work(&s->work, __printk_safe_flush);\n\n#ifdef CONFIG_PRINTK_NMI\n\t\ts = &per_cpu(nmi_print_seq, cpu);\n\t\tinit_irq_work(&s->work, __printk_safe_flush);\n#endif\n\t}\n\n\t/*\n\t * In the highly unlikely event that a NMI were to trigger at\n\t * this moment. Make sure IRQ work is set up before this\n\t * variable is set.\n\t */\n\tbarrier();\n\tprintk_safe_irq_ready = 1;\n\n\t/* Flush pending messages that did not have scheduled IRQ works. */\n\tprintk_safe_flush();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int printk_safe_irq_ready",
      "static DEFINE_PER_CPU(struct printk_safe_seq_buf, safe_print_seq);",
      "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_safe_flush",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "printk_safe_flush_on_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "278-293",
          "snippet": "void printk_safe_flush_on_panic(void)\n{\n\t/*\n\t * Make sure that we could access the main ring buffer.\n\t * Do not risk a double release when more CPUs are up.\n\t */\n\tif (raw_spin_is_locked(&logbuf_lock)) {\n\t\tif (num_online_cpus() > 1)\n\t\t\treturn;\n\n\t\tdebug_locks_off();\n\t\traw_spin_lock_init(&logbuf_lock);\n\t}\n\n\tprintk_safe_flush();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/printk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/smp.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nvoid printk_safe_flush_on_panic(void)\n{\n\t/*\n\t * Make sure that we could access the main ring buffer.\n\t * Do not risk a double release when more CPUs are up.\n\t */\n\tif (raw_spin_is_locked(&logbuf_lock)) {\n\t\tif (num_online_cpus() > 1)\n\t\t\treturn;\n\n\t\tdebug_locks_off();\n\t\traw_spin_lock_init(&logbuf_lock);\n\t}\n\n\tprintk_safe_flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&s->work",
            "__printk_safe_flush"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "nmi_print_seq",
            "cpu"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&s->work",
            "__printk_safe_flush"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic int printk_safe_irq_ready;\nstatic DEFINE_PER_CPU(struct printk_safe_seq_buf, safe_print_seq);\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nvoid __init printk_safe_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct printk_safe_seq_buf *s;\n\n\t\ts = &per_cpu(safe_print_seq, cpu);\n\t\tinit_irq_work(&s->work, __printk_safe_flush);\n\n#ifdef CONFIG_PRINTK_NMI\n\t\ts = &per_cpu(nmi_print_seq, cpu);\n\t\tinit_irq_work(&s->work, __printk_safe_flush);\n#endif\n\t}\n\n\t/*\n\t * In the highly unlikely event that a NMI were to trigger at\n\t * this moment. Make sure IRQ work is set up before this\n\t * variable is set.\n\t */\n\tbarrier();\n\tprintk_safe_irq_ready = 1;\n\n\t/* Flush pending messages that did not have scheduled IRQ works. */\n\tprintk_safe_flush();\n}"
  },
  {
    "function_name": "vprintk_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "373-399",
    "snippet": "int vprintk_func(const char *fmt, va_list args)\n{\n\t/*\n\t * Try to use the main logbuf even in NMI. But avoid calling console\n\t * drivers that might have their own locks.\n\t */\n\tif ((this_cpu_read(printk_context) & PRINTK_NMI_DIRECT_CONTEXT_MASK) &&\n\t    raw_spin_trylock(&logbuf_lock)) {\n\t\tint len;\n\n\t\tlen = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);\n\t\traw_spin_unlock(&logbuf_lock);\n\t\tdefer_console_output();\n\t\treturn len;\n\t}\n\n\t/* Use extra buffer in NMI when logbuf_lock is taken or in safe mode. */\n\tif (this_cpu_read(printk_context) & PRINTK_NMI_CONTEXT_MASK)\n\t\treturn vprintk_nmi(fmt, args);\n\n\t/* Use extra buffer to prevent a recursion deadlock in safe mode. */\n\tif (this_cpu_read(printk_context) & PRINTK_SAFE_CONTEXT_MASK)\n\t\treturn vprintk_safe(fmt, args);\n\n\t/* No obstacles. */\n\treturn vprintk_default(fmt, args);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);",
      "size_t len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vprintk_default",
          "args": [
            "fmt",
            "args"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1953-1967",
          "snippet": "int vprintk_default(const char *fmt, va_list args)\n{\n\tint r;\n\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow to pass printk() to kdb but avoid a recursion. */\n\tif (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {\n\t\tr = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);\n\t\treturn r;\n\t}\n#endif\n\tr = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_default(const char *fmt, va_list args)\n{\n\tint r;\n\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow to pass printk() to kdb but avoid a recursion. */\n\tif (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {\n\t\tr = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);\n\t\treturn r;\n\t}\n#endif\n\tr = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vprintk_safe",
          "args": [
            "fmt",
            "args"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "printk_context"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk_nmi",
          "args": [
            "fmt",
            "args"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "printk_context"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defer_console_output",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "defer_console_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2908-2914",
          "snippet": "void defer_console_output(void)\n{\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRINTK_PENDING_OUTPUT\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_OUTPUT\t0x02\n\nvoid defer_console_output(void)\n{\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&logbuf_lock"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vprintk_store",
          "args": [
            "0",
            "LOGLEVEL_DEFAULT",
            "NULL",
            "0",
            "fmt",
            "args"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1831-1882",
          "snippet": "int vprintk_store(int facility, int level,\n\t\t  const char *dict, size_t dictlen,\n\t\t  const char *fmt, va_list args)\n{\n\tstatic char textbuf[LOG_LINE_MAX];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\tenum log_flags lflags = 0;\n\n\t/*\n\t * The printf needs to come first; we need the syslog\n\t * prefix which might be passed-in as a parameter.\n\t */\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t/* mark and strip a trailing newline */\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= LOG_NEWLINE;\n\t}\n\n\t/* strip kernel syslog prefix and extract log level or control flags */\n\tif (facility == 0) {\n\t\tint kern_level;\n\n\t\twhile ((kern_level = printk_get_level(text)) != 0) {\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == LOGLEVEL_DEFAULT)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t/* fallthrough */\n\t\t\tcase 'd':\t/* KERN_DEFAULT */\n\t\t\t\tlflags |= LOG_PREFIX;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\t/* KERN_CONT */\n\t\t\t\tlflags |= LOG_CONT;\n\t\t\t}\n\n\t\t\ttext_len -= 2;\n\t\t\ttext += 2;\n\t\t}\n\t}\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= LOG_PREFIX|LOG_NEWLINE;\n\n\treturn log_output(facility, level, lflags,\n\t\t\t  dict, dictlen, text, text_len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n\nint vprintk_store(int facility, int level,\n\t\t  const char *dict, size_t dictlen,\n\t\t  const char *fmt, va_list args)\n{\n\tstatic char textbuf[LOG_LINE_MAX];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\tenum log_flags lflags = 0;\n\n\t/*\n\t * The printf needs to come first; we need the syslog\n\t * prefix which might be passed-in as a parameter.\n\t */\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t/* mark and strip a trailing newline */\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= LOG_NEWLINE;\n\t}\n\n\t/* strip kernel syslog prefix and extract log level or control flags */\n\tif (facility == 0) {\n\t\tint kern_level;\n\n\t\twhile ((kern_level = printk_get_level(text)) != 0) {\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == LOGLEVEL_DEFAULT)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t/* fallthrough */\n\t\t\tcase 'd':\t/* KERN_DEFAULT */\n\t\t\t\tlflags |= LOG_PREFIX;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\t/* KERN_CONT */\n\t\t\t\tlflags |= LOG_CONT;\n\t\t\t}\n\n\t\t\ttext_len -= 2;\n\t\t\ttext += 2;\n\t\t}\n\t}\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= LOG_PREFIX|LOG_NEWLINE;\n\n\treturn log_output(facility, level, lflags,\n\t\t\t  dict, dictlen, text, text_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&logbuf_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "printk_context"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\nsize_t len;\n\nint vprintk_func(const char *fmt, va_list args)\n{\n\t/*\n\t * Try to use the main logbuf even in NMI. But avoid calling console\n\t * drivers that might have their own locks.\n\t */\n\tif ((this_cpu_read(printk_context) & PRINTK_NMI_DIRECT_CONTEXT_MASK) &&\n\t    raw_spin_trylock(&logbuf_lock)) {\n\t\tint len;\n\n\t\tlen = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);\n\t\traw_spin_unlock(&logbuf_lock);\n\t\tdefer_console_output();\n\t\treturn len;\n\t}\n\n\t/* Use extra buffer in NMI when logbuf_lock is taken or in safe mode. */\n\tif (this_cpu_read(printk_context) & PRINTK_NMI_CONTEXT_MASK)\n\t\treturn vprintk_nmi(fmt, args);\n\n\t/* Use extra buffer to prevent a recursion deadlock in safe mode. */\n\tif (this_cpu_read(printk_context) & PRINTK_SAFE_CONTEXT_MASK)\n\t\treturn vprintk_safe(fmt, args);\n\n\t/* No obstacles. */\n\treturn vprintk_default(fmt, args);\n}"
  },
  {
    "function_name": "__printk_safe_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "368-371",
    "snippet": "void __printk_safe_exit(void)\n{\n\tthis_cpu_dec(printk_context);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "printk_context"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid __printk_safe_exit(void)\n{\n\tthis_cpu_dec(printk_context);\n}"
  },
  {
    "function_name": "__printk_safe_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "362-365",
    "snippet": "void __printk_safe_enter(void)\n{\n\tthis_cpu_inc(printk_context);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "printk_context"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid __printk_safe_enter(void)\n{\n\tthis_cpu_inc(printk_context);\n}"
  },
  {
    "function_name": "printk_nmi_direct_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "335-338",
    "snippet": "void printk_nmi_direct_exit(void)\n{\n\tthis_cpu_and(printk_context, ~PRINTK_NMI_DIRECT_CONTEXT_MASK);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_and",
          "args": [
            "printk_context",
            "~PRINTK_NMI_DIRECT_CONTEXT_MASK"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid printk_nmi_direct_exit(void)\n{\n\tthis_cpu_and(printk_context, ~PRINTK_NMI_DIRECT_CONTEXT_MASK);\n}"
  },
  {
    "function_name": "printk_nmi_direct_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "329-333",
    "snippet": "void printk_nmi_direct_enter(void)\n{\n\tif (this_cpu_read(printk_context) & PRINTK_NMI_CONTEXT_MASK)\n\t\tthis_cpu_or(printk_context, PRINTK_NMI_DIRECT_CONTEXT_MASK);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_or",
          "args": [
            "printk_context",
            "PRINTK_NMI_DIRECT_CONTEXT_MASK"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "printk_context"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid printk_nmi_direct_enter(void)\n{\n\tif (this_cpu_read(printk_context) & PRINTK_NMI_CONTEXT_MASK)\n\t\tthis_cpu_or(printk_context, PRINTK_NMI_DIRECT_CONTEXT_MASK);\n}"
  },
  {
    "function_name": "printk_nmi_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "314-317",
    "snippet": "void notrace printk_nmi_exit(void)\n{\n\tthis_cpu_and(printk_context, ~PRINTK_NMI_CONTEXT_MASK);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_and",
          "args": [
            "printk_context",
            "~PRINTK_NMI_CONTEXT_MASK"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid notrace printk_nmi_exit(void)\n{\n\tthis_cpu_and(printk_context, ~PRINTK_NMI_CONTEXT_MASK);\n}"
  },
  {
    "function_name": "printk_nmi_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "309-312",
    "snippet": "void notrace printk_nmi_enter(void)\n{\n\tthis_cpu_or(printk_context, PRINTK_NMI_CONTEXT_MASK);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, printk_context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_or",
          "args": [
            "printk_context",
            "PRINTK_NMI_CONTEXT_MASK"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(int, printk_context);\n\nvoid notrace printk_nmi_enter(void)\n{\n\tthis_cpu_or(printk_context, PRINTK_NMI_CONTEXT_MASK);\n}"
  },
  {
    "function_name": "printk_safe_flush_on_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "278-293",
    "snippet": "void printk_safe_flush_on_panic(void)\n{\n\t/*\n\t * Make sure that we could access the main ring buffer.\n\t * Do not risk a double release when more CPUs are up.\n\t */\n\tif (raw_spin_is_locked(&logbuf_lock)) {\n\t\tif (num_online_cpus() > 1)\n\t\t\treturn;\n\n\t\tdebug_locks_off();\n\t\traw_spin_lock_init(&logbuf_lock);\n\t}\n\n\tprintk_safe_flush();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_safe_flush",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "printk_safe_flush_on_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "278-293",
          "snippet": "void printk_safe_flush_on_panic(void)\n{\n\t/*\n\t * Make sure that we could access the main ring buffer.\n\t * Do not risk a double release when more CPUs are up.\n\t */\n\tif (raw_spin_is_locked(&logbuf_lock)) {\n\t\tif (num_online_cpus() > 1)\n\t\t\treturn;\n\n\t\tdebug_locks_off();\n\t\traw_spin_lock_init(&logbuf_lock);\n\t}\n\n\tprintk_safe_flush();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&logbuf_lock"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&logbuf_lock"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nvoid printk_safe_flush_on_panic(void)\n{\n\t/*\n\t * Make sure that we could access the main ring buffer.\n\t * Do not risk a double release when more CPUs are up.\n\t */\n\tif (raw_spin_is_locked(&logbuf_lock)) {\n\t\tif (num_online_cpus() > 1)\n\t\t\treturn;\n\n\t\tdebug_locks_off();\n\t\traw_spin_lock_init(&logbuf_lock);\n\t}\n\n\tprintk_safe_flush();\n}"
  },
  {
    "function_name": "printk_safe_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "256-266",
    "snippet": "void printk_safe_flush(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n#ifdef CONFIG_PRINTK_NMI\n\t\t__printk_safe_flush(&per_cpu(nmi_print_seq, cpu).work);\n#endif\n\t\t__printk_safe_flush(&per_cpu(safe_print_seq, cpu).work);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct printk_safe_seq_buf, safe_print_seq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__printk_safe_flush",
          "args": [
            "&per_cpu(safe_print_seq, cpu).work"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__printk_safe_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "192-247",
          "snippet": "static void __printk_safe_flush(struct irq_work *work)\n{\n\tstatic raw_spinlock_t read_lock =\n\t\t__RAW_SPIN_LOCK_INITIALIZER(read_lock);\n\tstruct printk_safe_seq_buf *s =\n\t\tcontainer_of(work, struct printk_safe_seq_buf, work);\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * The lock has two functions. First, one reader has to flush all\n\t * available message to make the lockless synchronization with\n\t * writers easier. Second, we do not want to mix messages from\n\t * different CPUs. This is especially important when printing\n\t * a backtrace.\n\t */\n\traw_spin_lock_irqsave(&read_lock, flags);\n\n\ti = 0;\nmore:\n\tlen = atomic_read(&s->len);\n\n\t/*\n\t * This is just a paranoid check that nobody has manipulated\n\t * the buffer an unexpected way. If we printed something then\n\t * @len must only increase. Also it should never overflow the\n\t * buffer size.\n\t */\n\tif ((i && i >= len) || len > sizeof(s->buffer)) {\n\t\tconst char *msg = \"printk_safe_flush: internal error\\n\";\n\n\t\tprintk_safe_flush_line(msg, strlen(msg));\n\t\tlen = 0;\n\t}\n\n\tif (!len)\n\t\tgoto out; /* Someone else has already flushed the buffer. */\n\n\t/* Make sure that data has been written up to the @len */\n\tsmp_rmb();\n\ti += printk_safe_flush_buffer(s->buffer + i, len - i);\n\n\t/*\n\t * Check that nothing has got added in the meantime and truncate\n\t * the buffer. Note that atomic_cmpxchg() is an implicit memory\n\t * barrier that makes sure that the data were copied before\n\t * updating s->len.\n\t */\n\tif (atomic_cmpxchg(&s->len, len, 0) != len)\n\t\tgoto more;\n\nout:\n\treport_message_lost(s);\n\traw_spin_unlock_irqrestore(&read_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/printk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/smp.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "size_t len;",
            "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic void __printk_safe_flush(struct irq_work *work)\n{\n\tstatic raw_spinlock_t read_lock =\n\t\t__RAW_SPIN_LOCK_INITIALIZER(read_lock);\n\tstruct printk_safe_seq_buf *s =\n\t\tcontainer_of(work, struct printk_safe_seq_buf, work);\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * The lock has two functions. First, one reader has to flush all\n\t * available message to make the lockless synchronization with\n\t * writers easier. Second, we do not want to mix messages from\n\t * different CPUs. This is especially important when printing\n\t * a backtrace.\n\t */\n\traw_spin_lock_irqsave(&read_lock, flags);\n\n\ti = 0;\nmore:\n\tlen = atomic_read(&s->len);\n\n\t/*\n\t * This is just a paranoid check that nobody has manipulated\n\t * the buffer an unexpected way. If we printed something then\n\t * @len must only increase. Also it should never overflow the\n\t * buffer size.\n\t */\n\tif ((i && i >= len) || len > sizeof(s->buffer)) {\n\t\tconst char *msg = \"printk_safe_flush: internal error\\n\";\n\n\t\tprintk_safe_flush_line(msg, strlen(msg));\n\t\tlen = 0;\n\t}\n\n\tif (!len)\n\t\tgoto out; /* Someone else has already flushed the buffer. */\n\n\t/* Make sure that data has been written up to the @len */\n\tsmp_rmb();\n\ti += printk_safe_flush_buffer(s->buffer + i, len - i);\n\n\t/*\n\t * Check that nothing has got added in the meantime and truncate\n\t * the buffer. Note that atomic_cmpxchg() is an implicit memory\n\t * barrier that makes sure that the data were copied before\n\t * updating s->len.\n\t */\n\tif (atomic_cmpxchg(&s->len, len, 0) != len)\n\t\tgoto more;\n\nout:\n\treport_message_lost(s);\n\traw_spin_unlock_irqrestore(&read_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "safe_print_seq",
            "cpu"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic DEFINE_PER_CPU(struct printk_safe_seq_buf, safe_print_seq);\n\nvoid printk_safe_flush(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n#ifdef CONFIG_PRINTK_NMI\n\t\t__printk_safe_flush(&per_cpu(nmi_print_seq, cpu).work);\n#endif\n\t\t__printk_safe_flush(&per_cpu(safe_print_seq, cpu).work);\n\t}\n}"
  },
  {
    "function_name": "__printk_safe_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "192-247",
    "snippet": "static void __printk_safe_flush(struct irq_work *work)\n{\n\tstatic raw_spinlock_t read_lock =\n\t\t__RAW_SPIN_LOCK_INITIALIZER(read_lock);\n\tstruct printk_safe_seq_buf *s =\n\t\tcontainer_of(work, struct printk_safe_seq_buf, work);\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * The lock has two functions. First, one reader has to flush all\n\t * available message to make the lockless synchronization with\n\t * writers easier. Second, we do not want to mix messages from\n\t * different CPUs. This is especially important when printing\n\t * a backtrace.\n\t */\n\traw_spin_lock_irqsave(&read_lock, flags);\n\n\ti = 0;\nmore:\n\tlen = atomic_read(&s->len);\n\n\t/*\n\t * This is just a paranoid check that nobody has manipulated\n\t * the buffer an unexpected way. If we printed something then\n\t * @len must only increase. Also it should never overflow the\n\t * buffer size.\n\t */\n\tif ((i && i >= len) || len > sizeof(s->buffer)) {\n\t\tconst char *msg = \"printk_safe_flush: internal error\\n\";\n\n\t\tprintk_safe_flush_line(msg, strlen(msg));\n\t\tlen = 0;\n\t}\n\n\tif (!len)\n\t\tgoto out; /* Someone else has already flushed the buffer. */\n\n\t/* Make sure that data has been written up to the @len */\n\tsmp_rmb();\n\ti += printk_safe_flush_buffer(s->buffer + i, len - i);\n\n\t/*\n\t * Check that nothing has got added in the meantime and truncate\n\t * the buffer. Note that atomic_cmpxchg() is an implicit memory\n\t * barrier that makes sure that the data were copied before\n\t * updating s->len.\n\t */\n\tif (atomic_cmpxchg(&s->len, len, 0) != len)\n\t\tgoto more;\n\nout:\n\treport_message_lost(s);\n\traw_spin_unlock_irqrestore(&read_lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "size_t len;",
      "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&read_lock",
            "flags"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_message_lost",
          "args": [
            "s"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "report_message_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "180-186",
          "snippet": "static void report_message_lost(struct printk_safe_seq_buf *s)\n{\n\tint lost = atomic_xchg(&s->message_lost, 0);\n\n\tif (lost)\n\t\tprintk_deferred(\"Lost %d message(s)!\\n\", lost);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/printk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/smp.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic void report_message_lost(struct printk_safe_seq_buf *s)\n{\n\tint lost = atomic_xchg(&s->message_lost, 0);\n\n\tif (lost)\n\t\tprintk_deferred(\"Lost %d message(s)!\\n\", lost);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&s->len",
            "len",
            "0"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_flush_buffer",
          "args": [
            "s->buffer + i",
            "len - i"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "printk_safe_flush_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "134-178",
          "snippet": "static int printk_safe_flush_buffer(const char *start, size_t len)\n{\n\tconst char *c, *end;\n\tbool header;\n\n\tc = start;\n\tend = start + len;\n\theader = true;\n\n\t/* Print line by line. */\n\twhile (c < end) {\n\t\tif (*c == '\\n') {\n\t\t\tprintk_safe_flush_line(start, c - start + 1);\n\t\t\tstart = ++c;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle continuous lines or missing new line. */\n\t\tif ((c + 1 < end) && printk_get_level(c)) {\n\t\t\tif (header) {\n\t\t\t\tc = printk_skip_level(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintk_safe_flush_line(start, c - start);\n\t\t\tstart = c++;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\theader = false;\n\t\tc++;\n\t}\n\n\t/* Check if there was a partial line. Ignore pure header. */\n\tif (start < end && !header) {\n\t\tstatic const char newline[] = KERN_CONT \"\\n\";\n\n\t\tprintk_safe_flush_line(start, end - start);\n\t\tprintk_safe_flush_line(newline, strlen(newline));\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/printk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/smp.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "size_t len;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\n\nstatic int printk_safe_flush_buffer(const char *start, size_t len)\n{\n\tconst char *c, *end;\n\tbool header;\n\n\tc = start;\n\tend = start + len;\n\theader = true;\n\n\t/* Print line by line. */\n\twhile (c < end) {\n\t\tif (*c == '\\n') {\n\t\t\tprintk_safe_flush_line(start, c - start + 1);\n\t\t\tstart = ++c;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle continuous lines or missing new line. */\n\t\tif ((c + 1 < end) && printk_get_level(c)) {\n\t\t\tif (header) {\n\t\t\t\tc = printk_skip_level(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintk_safe_flush_line(start, c - start);\n\t\t\tstart = c++;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\theader = false;\n\t\tc++;\n\t}\n\n\t/* Check if there was a partial line. Ignore pure header. */\n\tif (start < end && !header) {\n\t\tstatic const char newline[] = KERN_CONT \"\\n\";\n\n\t\tprintk_safe_flush_line(start, end - start);\n\t\tprintk_safe_flush_line(newline, strlen(newline));\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_flush_line",
          "args": [
            "msg",
            "strlen(msg)"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "printk_safe_flush_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "122-131",
          "snippet": "static inline void printk_safe_flush_line(const char *text, int len)\n{\n\t/*\n\t * Avoid any console drivers calls from here, because we may be\n\t * in NMI or printk_safe context (when in panic). The messages\n\t * must go only into the ring buffer at this stage.  Consoles will\n\t * get explicitly called later when a crashdump is not generated.\n\t */\n\tprintk_deferred(\"%.*s\", len, text);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/printk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/smp.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "size_t len;",
            "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic inline void printk_safe_flush_line(const char *text, int len)\n{\n\t/*\n\t * Avoid any console drivers calls from here, because we may be\n\t * in NMI or printk_safe context (when in panic). The messages\n\t * must go only into the ring buffer at this stage.  Consoles will\n\t * get explicitly called later when a crashdump is not generated.\n\t */\n\tprintk_deferred(\"%.*s\", len, text);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->len"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&read_lock",
            "flags"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structprintk_safe_seq_buf",
            "work"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__RAW_SPIN_LOCK_INITIALIZER",
          "args": [
            "read_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic void __printk_safe_flush(struct irq_work *work)\n{\n\tstatic raw_spinlock_t read_lock =\n\t\t__RAW_SPIN_LOCK_INITIALIZER(read_lock);\n\tstruct printk_safe_seq_buf *s =\n\t\tcontainer_of(work, struct printk_safe_seq_buf, work);\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * The lock has two functions. First, one reader has to flush all\n\t * available message to make the lockless synchronization with\n\t * writers easier. Second, we do not want to mix messages from\n\t * different CPUs. This is especially important when printing\n\t * a backtrace.\n\t */\n\traw_spin_lock_irqsave(&read_lock, flags);\n\n\ti = 0;\nmore:\n\tlen = atomic_read(&s->len);\n\n\t/*\n\t * This is just a paranoid check that nobody has manipulated\n\t * the buffer an unexpected way. If we printed something then\n\t * @len must only increase. Also it should never overflow the\n\t * buffer size.\n\t */\n\tif ((i && i >= len) || len > sizeof(s->buffer)) {\n\t\tconst char *msg = \"printk_safe_flush: internal error\\n\";\n\n\t\tprintk_safe_flush_line(msg, strlen(msg));\n\t\tlen = 0;\n\t}\n\n\tif (!len)\n\t\tgoto out; /* Someone else has already flushed the buffer. */\n\n\t/* Make sure that data has been written up to the @len */\n\tsmp_rmb();\n\ti += printk_safe_flush_buffer(s->buffer + i, len - i);\n\n\t/*\n\t * Check that nothing has got added in the meantime and truncate\n\t * the buffer. Note that atomic_cmpxchg() is an implicit memory\n\t * barrier that makes sure that the data were copied before\n\t * updating s->len.\n\t */\n\tif (atomic_cmpxchg(&s->len, len, 0) != len)\n\t\tgoto more;\n\nout:\n\treport_message_lost(s);\n\traw_spin_unlock_irqrestore(&read_lock, flags);\n}"
  },
  {
    "function_name": "report_message_lost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "180-186",
    "snippet": "static void report_message_lost(struct printk_safe_seq_buf *s)\n{\n\tint lost = atomic_xchg(&s->message_lost, 0);\n\n\tif (lost)\n\t\tprintk_deferred(\"Lost %d message(s)!\\n\", lost);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "\"Lost %d message(s)!\\n\"",
            "lost"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&s->message_lost",
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic void report_message_lost(struct printk_safe_seq_buf *s)\n{\n\tint lost = atomic_xchg(&s->message_lost, 0);\n\n\tif (lost)\n\t\tprintk_deferred(\"Lost %d message(s)!\\n\", lost);\n}"
  },
  {
    "function_name": "printk_safe_flush_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "134-178",
    "snippet": "static int printk_safe_flush_buffer(const char *start, size_t len)\n{\n\tconst char *c, *end;\n\tbool header;\n\n\tc = start;\n\tend = start + len;\n\theader = true;\n\n\t/* Print line by line. */\n\twhile (c < end) {\n\t\tif (*c == '\\n') {\n\t\t\tprintk_safe_flush_line(start, c - start + 1);\n\t\t\tstart = ++c;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle continuous lines or missing new line. */\n\t\tif ((c + 1 < end) && printk_get_level(c)) {\n\t\t\tif (header) {\n\t\t\t\tc = printk_skip_level(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintk_safe_flush_line(start, c - start);\n\t\t\tstart = c++;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\theader = false;\n\t\tc++;\n\t}\n\n\t/* Check if there was a partial line. Ignore pure header. */\n\tif (start < end && !header) {\n\t\tstatic const char newline[] = KERN_CONT \"\\n\";\n\n\t\tprintk_safe_flush_line(start, end - start);\n\t\tprintk_safe_flush_line(newline, strlen(newline));\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "size_t len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_safe_flush_line",
          "args": [
            "newline",
            "strlen(newline)"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "printk_safe_flush_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
          "lines": "122-131",
          "snippet": "static inline void printk_safe_flush_line(const char *text, int len)\n{\n\t/*\n\t * Avoid any console drivers calls from here, because we may be\n\t * in NMI or printk_safe context (when in panic). The messages\n\t * must go only into the ring buffer at this stage.  Consoles will\n\t * get explicitly called later when a crashdump is not generated.\n\t */\n\tprintk_deferred(\"%.*s\", len, text);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/printk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/smp.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "size_t len;",
            "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic inline void printk_safe_flush_line(const char *text, int len)\n{\n\t/*\n\t * Avoid any console drivers calls from here, because we may be\n\t * in NMI or printk_safe context (when in panic). The messages\n\t * must go only into the ring buffer at this stage.  Consoles will\n\t * get explicitly called later when a crashdump is not generated.\n\t */\n\tprintk_deferred(\"%.*s\", len, text);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newline"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_skip_level",
          "args": [
            "c"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_get_level",
          "args": [
            "c"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\n\nstatic int printk_safe_flush_buffer(const char *start, size_t len)\n{\n\tconst char *c, *end;\n\tbool header;\n\n\tc = start;\n\tend = start + len;\n\theader = true;\n\n\t/* Print line by line. */\n\twhile (c < end) {\n\t\tif (*c == '\\n') {\n\t\t\tprintk_safe_flush_line(start, c - start + 1);\n\t\t\tstart = ++c;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle continuous lines or missing new line. */\n\t\tif ((c + 1 < end) && printk_get_level(c)) {\n\t\t\tif (header) {\n\t\t\t\tc = printk_skip_level(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintk_safe_flush_line(start, c - start);\n\t\t\tstart = c++;\n\t\t\theader = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\theader = false;\n\t\tc++;\n\t}\n\n\t/* Check if there was a partial line. Ignore pure header. */\n\tif (start < end && !header) {\n\t\tstatic const char newline[] = KERN_CONT \"\\n\";\n\n\t\tprintk_safe_flush_line(start, end - start);\n\t\tprintk_safe_flush_line(newline, strlen(newline));\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "printk_safe_flush_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "122-131",
    "snippet": "static inline void printk_safe_flush_line(const char *text, int len)\n{\n\t/*\n\t * Avoid any console drivers calls from here, because we may be\n\t * in NMI or printk_safe context (when in panic). The messages\n\t * must go only into the ring buffer at this stage.  Consoles will\n\t * get explicitly called later when a crashdump is not generated.\n\t */\n\tprintk_deferred(\"%.*s\", len, text);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "size_t len;",
      "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "\"%.*s\"",
            "len",
            "text"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nsize_t len;\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic inline void printk_safe_flush_line(const char *text, int len)\n{\n\t/*\n\t * Avoid any console drivers calls from here, because we may be\n\t * in NMI or printk_safe context (when in panic). The messages\n\t * must go only into the ring buffer at this stage.  Consoles will\n\t * get explicitly called later when a crashdump is not generated.\n\t */\n\tprintk_deferred(\"%.*s\", len, text);\n}"
  },
  {
    "function_name": "queue_flush_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk_safe.c",
    "lines": "64-68",
    "snippet": "static void queue_flush_work(struct printk_safe_seq_buf *s)\n{\n\tif (printk_safe_irq_ready)\n\t\tirq_work_queue(&s->work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/printk.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/smp.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/preempt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int printk_safe_irq_ready",
      "static __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&s->work"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/printk.h>\n#include <linux/irq_work.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/debug_locks.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n\nstatic int printk_safe_irq_ready;\nstatic __printf(1, 0) int vprintk_safe(const char *fmt, va_list args)\n{\n\tstruct printk_safe_seq_buf *s = this_cpu_ptr(&safe_print_seq);\n\nstatic void queue_flush_work(struct printk_safe_seq_buf *s)\n{\n\tif (printk_safe_irq_ready)\n\t\tirq_work_queue(&s->work);\n}"
  }
]