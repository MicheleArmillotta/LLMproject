[
  {
    "function_name": "rt_mutex_print_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.h",
    "lines": "34-37",
    "snippet": "static inline void rt_mutex_print_deadlock(struct rt_mutex_waiter *w)\n{\n\tdebug_rt_mutex_print_deadlock(w);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_rt_mutex_print_deadlock",
          "args": [
            "w"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rt_mutex_print_deadlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.c",
          "lines": "87-137",
          "snippet": "void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)\n{\n\tstruct task_struct *task;\n\n\tif (!waiter->deadlock_lock || !debug_locks)\n\t\treturn;\n\n\trcu_read_lock();\n\ttask = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (!debug_locks_off()) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: circular locking deadlock detected!\\n\");\n\tpr_warn(\"%s\\n\", print_tainted());\n\tpr_warn(\"--------------------------------------------\\n\");\n\tprintk(\"%s/%d is deadlocking current task %s/%d\\n\\n\",\n\t       task->comm, task_pid_nr(task),\n\t       current->comm, task_pid_nr(current));\n\n\tprintk(\"\\n1) %s/%d is trying to acquire this lock:\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprintk_lock(waiter->lock, 1);\n\n\tprintk(\"\\n2) %s/%d is blocked on this lock:\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tprintk_lock(waiter->deadlock_lock, 1);\n\n\tdebug_show_held_locks(current);\n\tdebug_show_held_locks(task);\n\n\tprintk(\"\\n%s/%d's [blocked] stackdump:\\n\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tshow_stack(task, NULL);\n\tprintk(\"\\n%s/%d's [current] stackdump:\\n\\n\",\n\t\tcurrent->comm, task_pid_nr(current));\n\tdump_stack();\n\tdebug_show_all_locks();\n\trcu_read_unlock();\n\n\tprintk(\"[ turning off deadlock detection.\"\n\t       \"Please report this trace. ]\\n\\n\");\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/debug_locks.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n\nvoid debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter)\n{\n\tstruct task_struct *task;\n\n\tif (!waiter->deadlock_lock || !debug_locks)\n\t\treturn;\n\n\trcu_read_lock();\n\ttask = pid_task(waiter->deadlock_task_pid, PIDTYPE_PID);\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (!debug_locks_off()) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"============================================\\n\");\n\tpr_warn(\"WARNING: circular locking deadlock detected!\\n\");\n\tpr_warn(\"%s\\n\", print_tainted());\n\tpr_warn(\"--------------------------------------------\\n\");\n\tprintk(\"%s/%d is deadlocking current task %s/%d\\n\\n\",\n\t       task->comm, task_pid_nr(task),\n\t       current->comm, task_pid_nr(current));\n\n\tprintk(\"\\n1) %s/%d is trying to acquire this lock:\\n\",\n\t       current->comm, task_pid_nr(current));\n\tprintk_lock(waiter->lock, 1);\n\n\tprintk(\"\\n2) %s/%d is blocked on this lock:\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tprintk_lock(waiter->deadlock_lock, 1);\n\n\tdebug_show_held_locks(current);\n\tdebug_show_held_locks(task);\n\n\tprintk(\"\\n%s/%d's [blocked] stackdump:\\n\\n\",\n\t\ttask->comm, task_pid_nr(task));\n\tshow_stack(task, NULL);\n\tprintk(\"\\n%s/%d's [current] stackdump:\\n\\n\",\n\t\tcurrent->comm, task_pid_nr(current));\n\tdump_stack();\n\tdebug_show_all_locks();\n\trcu_read_unlock();\n\n\tprintk(\"[ turning off deadlock detection.\"\n\t       \"Please report this trace. ]\\n\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void rt_mutex_print_deadlock(struct rt_mutex_waiter *w)\n{\n\tdebug_rt_mutex_print_deadlock(w);\n}"
  },
  {
    "function_name": "debug_rt_mutex_detect_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex-debug.h",
    "lines": "28-32",
    "snippet": "static inline bool debug_rt_mutex_detect_deadlock(struct rt_mutex_waiter *waiter,\n\t\t\t\t\t\t  enum rtmutex_chainwalk walk)\n{\n\treturn (waiter != NULL);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "extern void debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter);",
      "extern void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter);",
      "extern void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter);"
    ],
    "called_functions": [],
    "contextual_snippet": "extern void debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter);\nextern void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter);\nextern void debug_rt_mutex_print_deadlock(struct rt_mutex_waiter *waiter);\n\nstatic inline bool debug_rt_mutex_detect_deadlock(struct rt_mutex_waiter *waiter,\n\t\t\t\t\t\t  enum rtmutex_chainwalk walk)\n{\n\treturn (waiter != NULL);\n}"
  }
]