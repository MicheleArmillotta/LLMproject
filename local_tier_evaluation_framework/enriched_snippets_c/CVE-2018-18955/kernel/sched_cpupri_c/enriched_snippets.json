[
  {
    "function_name": "cpupri_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
    "lines": "234-241",
    "snippet": "void cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cp->pri_to_cpu[i].mask"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cp->cpu_to_pri"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}"
  },
  {
    "function_name": "cpupri_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
    "lines": "203-228",
    "snippet": "int cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cp->pri_to_cpu[i].mask"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_cpu_ids",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&vec->mask",
            "GFP_KERNEL"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&vec->count",
            "0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "cpupri_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
    "lines": "135-195",
    "snippet": "void cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t/*\n\t * If the CPU was currently mapped to a different value, we\n\t * need to map it to the new value then remove the old value.\n\t * Note, we must add the new value first, otherwise we risk the\n\t * cpu being missed by the priority loop in cpupri_find.\n\t */\n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t/*\n\t\t * When adding a new vector, we update the mask first,\n\t\t * do a write memory barrier, and then update the count, to\n\t\t * make sure the vector is visible when count is set.\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t/*\n\t\t * Because the order of modification of the vec->count\n\t\t * is important, we must make sure that the update\n\t\t * of the new prio is seen before we decrement the\n\t\t * old prio. This makes sure that the loop sees\n\t\t * one or the other when we raise the priority of\n\t\t * the run queue. We don't care about when we lower the\n\t\t * priority, as that will trigger an rt pull anyway.\n\t\t *\n\t\t * We only need to do a memory barrier if we updated\n\t\t * the new priority vec.\n\t\t */\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * When removing from the vector, we decrement the counter first\n\t\t * do a memory barrier and then clear the mask.\n\t\t */\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "vec->mask"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&(vec)->count"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "oldpri != CPUPRI_INVALID"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&(vec)->count"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "vec->mask"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "newpri != CPUPRI_INVALID"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "newpri >= CPUPRI_NR_PRIORITIES"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_prio",
          "args": [
            "newpri"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "32-46",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t/*\n\t * If the CPU was currently mapped to a different value, we\n\t * need to map it to the new value then remove the old value.\n\t * Note, we must add the new value first, otherwise we risk the\n\t * cpu being missed by the priority loop in cpupri_find.\n\t */\n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t/*\n\t\t * When adding a new vector, we update the mask first,\n\t\t * do a write memory barrier, and then update the count, to\n\t\t * make sure the vector is visible when count is set.\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t/*\n\t\t * Because the order of modification of the vec->count\n\t\t * is important, we must make sure that the update\n\t\t * of the new prio is seen before we decrement the\n\t\t * old prio. This makes sure that the loop sees\n\t\t * one or the other when we raise the priority of\n\t\t * the run queue. We don't care about when we lower the\n\t\t * priority, as that will trigger an rt pull anyway.\n\t\t *\n\t\t * We only need to do a memory barrier if we updated\n\t\t * the new priority vec.\n\t\t */\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * When removing from the vector, we decrement the counter first\n\t\t * do a memory barrier and then clear the mask.\n\t\t */\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}"
  },
  {
    "function_name": "cpupri_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
    "lines": "63-123",
    "snippet": "int cpupri_find(struct cpupri *cp, struct task_struct *p,\n\t\tstruct cpumask *lowest_mask)\n{\n\tint idx = 0;\n\tint task_pri = convert_prio(p->prio);\n\n\tBUG_ON(task_pri >= CPUPRI_NR_PRIORITIES);\n\n\tfor (idx = 0; idx < task_pri; idx++) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[idx];\n\t\tint skip = 0;\n\n\t\tif (!atomic_read(&(vec)->count))\n\t\t\tskip = 1;\n\t\t/*\n\t\t * When looking at the vector, we need to read the counter,\n\t\t * do a memory barrier, then read the mask.\n\t\t *\n\t\t * Note: This is still all racey, but we can deal with it.\n\t\t *  Ideally, we only want to look at masks that are set.\n\t\t *\n\t\t *  If a mask is not set, then the only thing wrong is that we\n\t\t *  did a little more work than necessary.\n\t\t *\n\t\t *  If we read a zero count but the mask is set, because of the\n\t\t *  memory barriers, that can only happen when the highest prio\n\t\t *  task for a run queue has left the run queue, in which case,\n\t\t *  it will be followed by a pull. If the task we are processing\n\t\t *  fails to find a proper place to go, that pull request will\n\t\t *  pull this task if the run queue is running at a lower\n\t\t *  priority.\n\t\t */\n\t\tsmp_rmb();\n\n\t\t/* Need to do the rmb for every iteration */\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tif (cpumask_any_and(&p->cpus_allowed, vec->mask) >= nr_cpu_ids)\n\t\t\tcontinue;\n\n\t\tif (lowest_mask) {\n\t\t\tcpumask_and(lowest_mask, &p->cpus_allowed, vec->mask);\n\n\t\t\t/*\n\t\t\t * We have to ensure that we have at least one bit\n\t\t\t * still set in the array, since the map could have\n\t\t\t * been concurrently emptied between the first and\n\t\t\t * second reads of vec->mask.  If we hit this\n\t\t\t * condition, simply act as though we never hit this\n\t\t\t * priority level and continue on.\n\t\t\t */\n\t\t\tif (cpumask_any(lowest_mask) >= nr_cpu_ids)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "lowest_mask"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "lowest_mask",
            "&p->cpus_allowed",
            "vec->mask"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "&p->cpus_allowed",
            "vec->mask"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(vec)->count"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task_pri >= CPUPRI_NR_PRIORITIES"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_prio",
          "args": [
            "p->prio"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "32-46",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint cpupri_find(struct cpupri *cp, struct task_struct *p,\n\t\tstruct cpumask *lowest_mask)\n{\n\tint idx = 0;\n\tint task_pri = convert_prio(p->prio);\n\n\tBUG_ON(task_pri >= CPUPRI_NR_PRIORITIES);\n\n\tfor (idx = 0; idx < task_pri; idx++) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[idx];\n\t\tint skip = 0;\n\n\t\tif (!atomic_read(&(vec)->count))\n\t\t\tskip = 1;\n\t\t/*\n\t\t * When looking at the vector, we need to read the counter,\n\t\t * do a memory barrier, then read the mask.\n\t\t *\n\t\t * Note: This is still all racey, but we can deal with it.\n\t\t *  Ideally, we only want to look at masks that are set.\n\t\t *\n\t\t *  If a mask is not set, then the only thing wrong is that we\n\t\t *  did a little more work than necessary.\n\t\t *\n\t\t *  If we read a zero count but the mask is set, because of the\n\t\t *  memory barriers, that can only happen when the highest prio\n\t\t *  task for a run queue has left the run queue, in which case,\n\t\t *  it will be followed by a pull. If the task we are processing\n\t\t *  fails to find a proper place to go, that pull request will\n\t\t *  pull this task if the run queue is running at a lower\n\t\t *  priority.\n\t\t */\n\t\tsmp_rmb();\n\n\t\t/* Need to do the rmb for every iteration */\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tif (cpumask_any_and(&p->cpus_allowed, vec->mask) >= nr_cpu_ids)\n\t\t\tcontinue;\n\n\t\tif (lowest_mask) {\n\t\t\tcpumask_and(lowest_mask, &p->cpus_allowed, vec->mask);\n\n\t\t\t/*\n\t\t\t * We have to ensure that we have at least one bit\n\t\t\t * still set in the array, since the map could have\n\t\t\t * been concurrently emptied between the first and\n\t\t\t * second reads of vec->mask.  If we hit this\n\t\t\t * condition, simply act as though we never hit this\n\t\t\t * priority level and continue on.\n\t\t\t */\n\t\t\tif (cpumask_any(lowest_mask) >= nr_cpu_ids)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "convert_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
    "lines": "32-46",
    "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
  }
]