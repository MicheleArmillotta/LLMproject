[
  {
    "function_name": "devm_irq_setup_generic_chip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "265-285",
    "snippet": "int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,\n\t\t\t\tu32 msk, enum irq_gc_flags flags,\n\t\t\t\tunsigned int clr, unsigned int set)\n{\n\tstruct irq_generic_chip_devres *dr;\n\n\tdr = devres_alloc(devm_irq_remove_generic_chip,\n\t\t\t  sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tirq_setup_generic_chip(gc, msk, flags, clr, set);\n\n\tdr->gc = gc;\n\tdr->msk = msk;\n\tdr->clr = clr;\n\tdr->set = set;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_setup_generic_chip",
          "args": [
            "gc",
            "msk",
            "flags",
            "clr",
            "set"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_generic_chip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/generic-chip.c",
          "lines": "466-501",
          "snippet": "void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t    enum irq_gc_flags flags, unsigned int clr,\n\t\t\t    unsigned int set)\n{\n\tstruct irq_chip_type *ct = gc->chip_types;\n\tstruct irq_chip *chip = &ct->chip;\n\tunsigned int i;\n\n\traw_spin_lock(&gc_lock);\n\tlist_add_tail(&gc->list, &gc_list);\n\traw_spin_unlock(&gc_lock);\n\n\tirq_gc_init_mask_cache(gc, flags);\n\n\tfor (i = gc->irq_base; msk; msk >>= 1, i++) {\n\t\tif (!(msk & 0x01))\n\t\t\tcontinue;\n\n\t\tif (flags & IRQ_GC_INIT_NESTED_LOCK)\n\t\t\tirq_set_lockdep_class(i, &irq_nested_lock_class,\n\t\t\t\t\t      &irq_nested_request_class);\n\n\t\tif (!(flags & IRQ_GC_NO_MASK)) {\n\t\t\tstruct irq_data *d = irq_get_irq_data(i);\n\n\t\t\tif (chip->irq_calc_mask)\n\t\t\t\tchip->irq_calc_mask(d);\n\t\t\telse\n\t\t\t\td->mask = 1 << (i - gc->irq_base);\n\t\t}\n\t\tirq_set_chip_and_handler(i, chip, ct->handler);\n\t\tirq_set_chip_data(i, gc);\n\t\tirq_modify_status(i, clr, set);\n\t}\n\tgc->irq_cnt = i - gc->irq_base;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(gc_list);",
            "static DEFINE_RAW_SPINLOCK(gc_lock);",
            "static struct lock_class_key irq_nested_lock_class;",
            "static struct lock_class_key irq_nested_request_class;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n\nstatic LIST_HEAD(gc_list);\nstatic DEFINE_RAW_SPINLOCK(gc_lock);\nstatic struct lock_class_key irq_nested_lock_class;\nstatic struct lock_class_key irq_nested_request_class;\n\nvoid irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t    enum irq_gc_flags flags, unsigned int clr,\n\t\t\t    unsigned int set)\n{\n\tstruct irq_chip_type *ct = gc->chip_types;\n\tstruct irq_chip *chip = &ct->chip;\n\tunsigned int i;\n\n\traw_spin_lock(&gc_lock);\n\tlist_add_tail(&gc->list, &gc_list);\n\traw_spin_unlock(&gc_lock);\n\n\tirq_gc_init_mask_cache(gc, flags);\n\n\tfor (i = gc->irq_base; msk; msk >>= 1, i++) {\n\t\tif (!(msk & 0x01))\n\t\t\tcontinue;\n\n\t\tif (flags & IRQ_GC_INIT_NESTED_LOCK)\n\t\t\tirq_set_lockdep_class(i, &irq_nested_lock_class,\n\t\t\t\t\t      &irq_nested_request_class);\n\n\t\tif (!(flags & IRQ_GC_NO_MASK)) {\n\t\t\tstruct irq_data *d = irq_get_irq_data(i);\n\n\t\t\tif (chip->irq_calc_mask)\n\t\t\t\tchip->irq_calc_mask(d);\n\t\t\telse\n\t\t\t\td->mask = 1 << (i - gc->irq_base);\n\t\t}\n\t\tirq_set_chip_and_handler(i, chip, ct->handler);\n\t\tirq_set_chip_data(i, gc);\n\t\tirq_modify_status(i, clr, set);\n\t}\n\tgc->irq_cnt = i - gc->irq_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_irq_remove_generic_chip",
            "sizeof(*dr)",
            "GFP_KERNEL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nint devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,\n\t\t\t\tu32 msk, enum irq_gc_flags flags,\n\t\t\t\tunsigned int clr, unsigned int set)\n{\n\tstruct irq_generic_chip_devres *dr;\n\n\tdr = devres_alloc(devm_irq_remove_generic_chip,\n\t\t\t  sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tirq_setup_generic_chip(gc, msk, flags, clr, set);\n\n\tdr->gc = gc;\n\tdr->msk = msk;\n\tdr->clr = clr;\n\tdr->set = set;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "devm_irq_remove_generic_chip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "243-248",
    "snippet": "static void devm_irq_remove_generic_chip(struct device *dev, void *res)\n{\n\tstruct irq_generic_chip_devres *this = res;\n\n\tirq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_remove_generic_chip",
          "args": [
            "this->gc",
            "this->msk",
            "this->clr",
            "this->set"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "irq_remove_generic_chip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/generic-chip.c",
          "lines": "537-556",
          "snippet": "void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t     unsigned int clr, unsigned int set)\n{\n\tunsigned int i = gc->irq_base;\n\n\traw_spin_lock(&gc_lock);\n\tlist_del(&gc->list);\n\traw_spin_unlock(&gc_lock);\n\n\tfor (; msk; msk >>= 1, i++) {\n\t\tif (!(msk & 0x01))\n\t\t\tcontinue;\n\n\t\t/* Remove handler first. That will mask the irq line */\n\t\tirq_set_handler(i, NULL);\n\t\tirq_set_chip(i, &no_irq_chip);\n\t\tirq_set_chip_data(i, NULL);\n\t\tirq_modify_status(i, clr, set);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(gc_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n\nstatic DEFINE_RAW_SPINLOCK(gc_lock);\n\nvoid irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t     unsigned int clr, unsigned int set)\n{\n\tunsigned int i = gc->irq_base;\n\n\traw_spin_lock(&gc_lock);\n\tlist_del(&gc->list);\n\traw_spin_unlock(&gc_lock);\n\n\tfor (; msk; msk >>= 1, i++) {\n\t\tif (!(msk & 0x01))\n\t\t\tcontinue;\n\n\t\t/* Remove handler first. That will mask the irq line */\n\t\tirq_set_handler(i, NULL);\n\t\tirq_set_chip(i, &no_irq_chip);\n\t\tirq_set_chip_data(i, NULL);\n\t\tirq_modify_status(i, clr, set);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nstatic void devm_irq_remove_generic_chip(struct device *dev, void *res)\n{\n\tstruct irq_generic_chip_devres *this = res;\n\n\tirq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);\n}"
  },
  {
    "function_name": "devm_irq_alloc_generic_chip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "219-233",
    "snippet": "struct irq_chip_generic *\ndevm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,\n\t\t\t    unsigned int irq_base, void __iomem *reg_base,\n\t\t\t    irq_flow_handler_t handler)\n{\n\tstruct irq_chip_generic *gc;\n\tunsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);\n\n\tgc = devm_kzalloc(dev, sz, GFP_KERNEL);\n\tif (gc)\n\t\tirq_init_generic_chip(gc, name, num_ct,\n\t\t\t\t      irq_base, reg_base, handler);\n\n\treturn gc;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_init_generic_chip",
          "args": [
            "gc",
            "name",
            "num_ct",
            "irq_base",
            "reg_base",
            "handler"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "irq_init_generic_chip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "385-388",
          "snippet": "static inline void\nirq_init_generic_chip(struct irq_chip_generic *gc, const char *name,\n\t\t      int num_ct, unsigned int irq_base,\n\t\t      void __iomem *reg_base, irq_flow_handler_t handler) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void\nirq_init_generic_chip(struct irq_chip_generic *gc, const char *name,\n\t\t      int num_ct, unsigned int irq_base,\n\t\t      void __iomem *reg_base, irq_flow_handler_t handler) { }"
        }
      },
      {
        "call_info": {
          "callee": "devm_kzalloc",
          "args": [
            "dev",
            "sz",
            "GFP_KERNEL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nstruct irq_chip_generic *\ndevm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,\n\t\t\t    unsigned int irq_base, void __iomem *reg_base,\n\t\t\t    irq_flow_handler_t handler)\n{\n\tstruct irq_chip_generic *gc;\n\tunsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);\n\n\tgc = devm_kzalloc(dev, sz, GFP_KERNEL);\n\tif (gc)\n\t\tirq_init_generic_chip(gc, name, num_ct,\n\t\t\t\t      irq_base, reg_base, handler);\n\n\treturn gc;\n}"
  },
  {
    "function_name": "__devm_irq_alloc_descs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "180-202",
    "snippet": "int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,\n\t\t\t   unsigned int cnt, int node, struct module *owner,\n\t\t\t   const struct cpumask *affinity)\n{\n\tstruct irq_desc_devres *dr;\n\tint base;\n\n\tdr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tbase = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);\n\tif (base < 0) {\n\t\tdevres_free(dr);\n\t\treturn base;\n\t}\n\n\tdr->from = base;\n\tdr->cnt = cnt;\n\tdevres_add(dev, dr);\n\n\treturn base;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_alloc_descs",
          "args": [
            "irq",
            "from",
            "cnt",
            "node",
            "owner",
            "affinity"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_alloc_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "706-745",
          "snippet": "int __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner, const struct cpumask *affinity)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (irq >= 0) {\n\t\tif (from > irq)\n\t\t\treturn -EINVAL;\n\t\tfrom = irq;\n\t} else {\n\t\t/*\n\t\t * For interrupts which are freely allocated the\n\t\t * architecture can force a lower bound to the @from\n\t\t * argument. x86 uses this to exclude the GSI space.\n\t\t */\n\t\tfrom = arch_dynirq_lower_bound(from);\n\t}\n\n\tmutex_lock(&sparse_irq_lock);\n\n\tstart = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,\n\t\t\t\t\t   from, cnt, 0);\n\tret = -EEXIST;\n\tif (irq >=0 && start != irq)\n\t\tgoto unlock;\n\n\tif (start + cnt > nr_irqs) {\n\t\tret = irq_expand_nr_irqs(start + cnt);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = alloc_descs(start, cnt, node, affinity, owner);\nunlock:\n\tmutex_unlock(&sparse_irq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);",
            "static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\nstatic DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);\n\nint __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner, const struct cpumask *affinity)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (irq >= 0) {\n\t\tif (from > irq)\n\t\t\treturn -EINVAL;\n\t\tfrom = irq;\n\t} else {\n\t\t/*\n\t\t * For interrupts which are freely allocated the\n\t\t * architecture can force a lower bound to the @from\n\t\t * argument. x86 uses this to exclude the GSI space.\n\t\t */\n\t\tfrom = arch_dynirq_lower_bound(from);\n\t}\n\n\tmutex_lock(&sparse_irq_lock);\n\n\tstart = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,\n\t\t\t\t\t   from, cnt, 0);\n\tret = -EEXIST;\n\tif (irq >=0 && start != irq)\n\t\tgoto unlock;\n\n\tif (start + cnt > nr_irqs) {\n\t\tret = irq_expand_nr_irqs(start + cnt);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = alloc_descs(start, cnt, node, affinity, owner);\nunlock:\n\tmutex_unlock(&sparse_irq_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_irq_desc_release",
            "sizeof(*dr)",
            "GFP_KERNEL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nint __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,\n\t\t\t   unsigned int cnt, int node, struct module *owner,\n\t\t\t   const struct cpumask *affinity)\n{\n\tstruct irq_desc_devres *dr;\n\tint base;\n\n\tdr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tbase = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);\n\tif (base < 0) {\n\t\tdevres_free(dr);\n\t\treturn base;\n\t}\n\n\tdr->from = base;\n\tdr->cnt = cnt;\n\tdevres_add(dev, dr);\n\n\treturn base;\n}"
  },
  {
    "function_name": "devm_irq_desc_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "156-161",
    "snippet": "static void devm_irq_desc_release(struct device *dev, void *res)\n{\n\tstruct irq_desc_devres *this = res;\n\n\tirq_free_descs(this->from, this->cnt);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "this->from",
            "this->cnt"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "677-690",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nstatic void devm_irq_desc_release(struct device *dev, void *res)\n{\n\tstruct irq_desc_devres *this = res;\n\n\tirq_free_descs(this->from, this->cnt);\n}"
  },
  {
    "function_name": "devm_free_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "141-148",
    "snippet": "void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\n\tstruct irq_devres match_data = { irq, dev_id };\n\n\tWARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,\n\t\t\t       &match_data));\n\tfree_irq(irq, dev_id);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_irq",
          "args": [
            "irq",
            "dev_id"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "free_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "1731-1753",
          "snippet": "const void *free_irq(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tconst char *devname;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n#ifdef CONFIG_SMP\n\tif (WARN_ON(desc->affinity_notify))\n\t\tdesc->affinity_notify = NULL;\n#endif\n\n\taction = __free_irq(desc, dev_id);\n\n\tif (!action)\n\t\treturn NULL;\n\n\tdevname = action->name;\n\tkfree(action);\n\treturn devname;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nconst void *free_irq(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tconst char *devname;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n#ifdef CONFIG_SMP\n\tif (WARN_ON(desc->affinity_notify))\n\t\tdesc->affinity_notify = NULL;\n#endif\n\n\taction = __free_irq(desc, dev_id);\n\n\tif (!action)\n\t\treturn NULL;\n\n\tdevname = action->name;\n\tkfree(action);\n\treturn devname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_destroy(dev, devm_irq_release, devm_irq_match,\n\t\t\t       &match_data)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_destroy",
          "args": [
            "dev",
            "devm_irq_release",
            "devm_irq_match",
            "&match_data"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nvoid devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\n\tstruct irq_devres match_data = { irq, dev_id };\n\n\tWARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,\n\t\t\t       &match_data));\n\tfree_irq(irq, dev_id);\n}"
  },
  {
    "function_name": "devm_request_any_context_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "101-127",
    "snippet": "int devm_request_any_context_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tif (!devname)\n\t\tdevname = dev_name(dev);\n\n\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);\n\tif (rc < 0) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_any_context_irq",
          "args": [
            "irq",
            "handler",
            "irqflags",
            "devname",
            "dev_id"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "request_any_context_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "1901-1922",
          "snippet": "int request_any_context_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t    unsigned long flags, const char *name, void *dev_id)\n{\n\tstruct irq_desc *desc;\n\tint ret;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (irq_settings_is_nested_thread(desc)) {\n\t\tret = request_threaded_irq(irq, NULL, handler,\n\t\t\t\t\t   flags, name, dev_id);\n\t\treturn !ret ? IRQC_IS_NESTED : ret;\n\t}\n\n\tret = request_irq(irq, handler, flags, name, dev_id);\n\treturn !ret ? IRQC_IS_HARDIRQ : ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_any_context_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t    unsigned long flags, const char *name, void *dev_id)\n{\n\tstruct irq_desc *desc;\n\tint ret;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (irq_settings_is_nested_thread(desc)) {\n\t\tret = request_threaded_irq(irq, NULL, handler,\n\t\t\t\t\t   flags, name, dev_id);\n\t\treturn !ret ? IRQC_IS_NESTED : ret;\n\t}\n\n\tret = request_irq(irq, handler, flags, name, dev_id);\n\treturn !ret ? IRQC_IS_HARDIRQ : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_irq_release",
            "sizeof(struct irq_devres)",
            "GFP_KERNEL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nint devm_request_any_context_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tif (!devname)\n\t\tdevname = dev_name(dev);\n\n\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);\n\tif (rc < 0) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "devm_request_threaded_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "51-79",
    "snippet": "int devm_request_threaded_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,\n\t\t\t      unsigned long irqflags, const char *devname,\n\t\t\t      void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tif (!devname)\n\t\tdevname = dev_name(dev);\n\n\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,\n\t\t\t\t  dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_threaded_irq",
          "args": [
            "irq",
            "handler",
            "thread_fn",
            "irqflags",
            "devname",
            "dev_id"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "request_threaded_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "1798-1881",
          "snippet": "int request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t *\n\t * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and\n\t * it cannot be set along with IRQF_NO_SUSPEND.\n\t */\n\tif (((irqflags & IRQF_SHARED) && !dev_id) ||\n\t    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||\n\t    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action->secondary);\n\t\tkfree(action);\n\t}\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t *\n\t * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and\n\t * it cannot be set along with IRQF_NO_SUSPEND.\n\t */\n\tif (((irqflags & IRQF_SHARED) && !dev_id) ||\n\t    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||\n\t    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action->secondary);\n\t\tkfree(action);\n\t}\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_irq_release",
            "sizeof(struct irq_devres)",
            "GFP_KERNEL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nint devm_request_threaded_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,\n\t\t\t      unsigned long irqflags, const char *devname,\n\t\t\t      void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tif (!devname)\n\t\tdevname = dev_name(dev);\n\n\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,\n\t\t\t\t  dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "devm_irq_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "25-30",
    "snippet": "static int devm_irq_match(struct device *dev, void *res, void *data)\n{\n\tstruct irq_devres *this = res, *match = data;\n\n\treturn this->irq == match->irq && this->dev_id == match->dev_id;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nstatic int devm_irq_match(struct device *dev, void *res, void *data)\n{\n\tstruct irq_devres *this = res, *match = data;\n\n\treturn this->irq == match->irq && this->dev_id == match->dev_id;\n}"
  },
  {
    "function_name": "devm_irq_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/devres.c",
    "lines": "18-23",
    "snippet": "static void devm_irq_release(struct device *dev, void *res)\n{\n\tstruct irq_devres *this = res;\n\n\tfree_irq(this->irq, this->dev_id);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/irq.h>",
      "#include <linux/gfp.h>",
      "#include <linux/device.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_irq",
          "args": [
            "this->irq",
            "this->dev_id"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "free_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "1731-1753",
          "snippet": "const void *free_irq(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tconst char *devname;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n#ifdef CONFIG_SMP\n\tif (WARN_ON(desc->affinity_notify))\n\t\tdesc->affinity_notify = NULL;\n#endif\n\n\taction = __free_irq(desc, dev_id);\n\n\tif (!action)\n\t\treturn NULL;\n\n\tdevname = action->name;\n\tkfree(action);\n\treturn devname;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nconst void *free_irq(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tconst char *devname;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n#ifdef CONFIG_SMP\n\tif (WARN_ON(desc->affinity_notify))\n\t\tdesc->affinity_notify = NULL;\n#endif\n\n\taction = __free_irq(desc, dev_id);\n\n\tif (!action)\n\t\treturn NULL;\n\n\tdevname = action->name;\n\tkfree(action);\n\treturn devname;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\nstatic void devm_irq_release(struct device *dev, void *res)\n{\n\tstruct irq_devres *this = res;\n\n\tfree_irq(this->irq, this->dev_id);\n}"
  }
]