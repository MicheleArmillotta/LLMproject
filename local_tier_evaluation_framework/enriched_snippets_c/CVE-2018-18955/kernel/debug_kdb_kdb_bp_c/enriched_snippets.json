[
  {
    "function_name": "kdb_initbptab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "519-558",
    "snippet": "void __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t/*\n\t * First time initialization.\n\t */\n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_flags(\"bp\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Set/Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bl\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_flags(\"bph\", kdb_bp, \"[<vaddr>]\",\n\t\t\"[datar [length]|dataw [length]]   Set hw brk\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bc\", kdb_bc, \"<bpnum>\",\n\t\t\"Clear Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"be\", kdb_bc, \"<bpnum>\",\n\t\t\"Enable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"bd\", kdb_bc, \"<bpnum>\",\n\t\t\"Disable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\n\tkdb_register_flags(\"ss\", kdb_ss, \"\",\n\t\t\"Single Step\", 1,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\t/*\n\t * Architecture dependent initialization.\n\t */\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_register_flags",
          "args": [
            "\"ss\"",
            "kdb_ss",
            "\"\"",
            "\"Single Step\"",
            "1",
            "KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2674-2734",
          "snippet": "int kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define kdb_command_extend 50\t/* arbitrary */",
            "#define KDB_BASE_CMD_MAX 50"
          ],
          "globals_used": [
            "static kdbtab_t *kdb_commands;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define kdb_command_extend 50\t/* arbitrary */\n#define KDB_BASE_CMD_MAX 50\n\nstatic kdbtab_t *kdb_commands;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&kdb_breakpoints",
            "'\\0'",
            "sizeof(kdb_breakpoints)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nvoid __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t/*\n\t * First time initialization.\n\t */\n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_flags(\"bp\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Set/Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bl\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_flags(\"bph\", kdb_bp, \"[<vaddr>]\",\n\t\t\"[datar [length]|dataw [length]]   Set hw brk\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bc\", kdb_bc, \"<bpnum>\",\n\t\t\"Clear Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"be\", kdb_bc, \"<bpnum>\",\n\t\t\"Enable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"bd\", kdb_bc, \"<bpnum>\",\n\t\t\"Disable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\n\tkdb_register_flags(\"ss\", kdb_ss, \"\",\n\t\t\"Single Step\", 1,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\t/*\n\t * Architecture dependent initialization.\n\t */\n}"
  },
  {
    "function_name": "kdb_ss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "506-515",
    "snippet": "static int kdb_ss(int argc, const char **argv)\n{\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\t/*\n\t * Set trace flag and go.\n\t */\n\tKDB_STATE_SET(DOING_SS);\n\treturn KDB_CMD_SS;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_SS"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int kdb_ss(int argc, const char **argv)\n{\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\t/*\n\t * Set trace flag and go.\n\t */\n\tKDB_STATE_SET(DOING_SS);\n\treturn KDB_CMD_SS;\n}"
  },
  {
    "function_name": "kdb_bc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "377-482",
    "snippet": "static int kdb_bc(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tkdb_bp_t *bp = NULL;\n\tint lowbp = KDB_MAXBPT;\n\tint highbp = 0;\n\tint done = 0;\n\tint i;\n\tint diag = 0;\n\n\tint cmd;\t\t\t/* KDBCMD_B? */\n#define KDBCMD_BC\t0\n#define KDBCMD_BE\t1\n#define KDBCMD_BD\t2\n\n\tif (strcmp(argv[0], \"be\") == 0)\n\t\tcmd = KDBCMD_BE;\n\telse if (strcmp(argv[0], \"bd\") == 0)\n\t\tcmd = KDBCMD_BD;\n\telse\n\t\tcmd = KDBCMD_BC;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (strcmp(argv[1], \"*\") == 0) {\n\t\tlowbp = 0;\n\t\thighbp = KDB_MAXBPT;\n\t} else {\n\t\tdiag = kdbgetularg(argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\n\t\t/*\n\t\t * For addresses less than the maximum breakpoint number,\n\t\t * assume that the breakpoint number is desired.\n\t\t */\n\t\tif (addr < KDB_MAXBPT) {\n\t\t\tbp = &kdb_breakpoints[addr];\n\t\t\tlowbp = highbp = addr;\n\t\t\thighbp++;\n\t\t} else {\n\t\t\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT;\n\t\t\t    i++, bp++) {\n\t\t\t\tif (bp->bp_addr == addr) {\n\t\t\t\t\tlowbp = highbp = i;\n\t\t\t\t\thighbp++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now operate on the set of breakpoints matching the input\n\t * criteria (either '*' for all, or an individual breakpoint).\n\t */\n\tfor (bp = &kdb_breakpoints[lowbp], i = lowbp;\n\t    i < highbp;\n\t    i++, bp++) {\n\t\tif (bp->bp_free)\n\t\t\tcontinue;\n\n\t\tdone++;\n\n\t\tswitch (cmd) {\n\t\tcase KDBCMD_BC:\n\t\t\tbp->bp_enabled = 0;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" cleared\\n\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tbp->bp_addr = 0;\n\t\t\tbp->bp_free = 1;\n\n\t\t\tbreak;\n\t\tcase KDBCMD_BE:\n\t\t\tbp->bp_enabled = 1;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" enabled\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tbreak;\n\t\tcase KDBCMD_BD:\n\t\t\tif (!bp->bp_enabled)\n\t\t\t\tbreak;\n\n\t\t\tbp->bp_enabled = 0;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" disabled\\n\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (bp->bp_delay && (cmd == KDBCMD_BC || cmd == KDBCMD_BD)) {\n\t\t\tbp->bp_delay = 0;\n\t\t\tKDB_STATE_CLEAR(SSBPT);\n\t\t}\n\t}\n\n\treturn (!done) ? KDB_BPTNOTFOUND : 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [
      "#define KDBCMD_BD\t2",
      "#define KDBCMD_BE\t1",
      "#define KDBCMD_BC\t0"
    ],
    "globals_used": [
      "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SSBPT"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" disabled\\n\"",
            "i",
            "bp->bp_addr"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[1]",
            "&addr"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"*\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"bd\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"be\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n#define KDBCMD_BD\t2\n#define KDBCMD_BE\t1\n#define KDBCMD_BC\t0\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nstatic int kdb_bc(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tkdb_bp_t *bp = NULL;\n\tint lowbp = KDB_MAXBPT;\n\tint highbp = 0;\n\tint done = 0;\n\tint i;\n\tint diag = 0;\n\n\tint cmd;\t\t\t/* KDBCMD_B? */\n#define KDBCMD_BC\t0\n#define KDBCMD_BE\t1\n#define KDBCMD_BD\t2\n\n\tif (strcmp(argv[0], \"be\") == 0)\n\t\tcmd = KDBCMD_BE;\n\telse if (strcmp(argv[0], \"bd\") == 0)\n\t\tcmd = KDBCMD_BD;\n\telse\n\t\tcmd = KDBCMD_BC;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (strcmp(argv[1], \"*\") == 0) {\n\t\tlowbp = 0;\n\t\thighbp = KDB_MAXBPT;\n\t} else {\n\t\tdiag = kdbgetularg(argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\n\t\t/*\n\t\t * For addresses less than the maximum breakpoint number,\n\t\t * assume that the breakpoint number is desired.\n\t\t */\n\t\tif (addr < KDB_MAXBPT) {\n\t\t\tbp = &kdb_breakpoints[addr];\n\t\t\tlowbp = highbp = addr;\n\t\t\thighbp++;\n\t\t} else {\n\t\t\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT;\n\t\t\t    i++, bp++) {\n\t\t\t\tif (bp->bp_addr == addr) {\n\t\t\t\t\tlowbp = highbp = i;\n\t\t\t\t\thighbp++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now operate on the set of breakpoints matching the input\n\t * criteria (either '*' for all, or an individual breakpoint).\n\t */\n\tfor (bp = &kdb_breakpoints[lowbp], i = lowbp;\n\t    i < highbp;\n\t    i++, bp++) {\n\t\tif (bp->bp_free)\n\t\t\tcontinue;\n\n\t\tdone++;\n\n\t\tswitch (cmd) {\n\t\tcase KDBCMD_BC:\n\t\t\tbp->bp_enabled = 0;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" cleared\\n\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tbp->bp_addr = 0;\n\t\t\tbp->bp_free = 1;\n\n\t\t\tbreak;\n\t\tcase KDBCMD_BE:\n\t\t\tbp->bp_enabled = 1;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" enabled\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tbreak;\n\t\tcase KDBCMD_BD:\n\t\t\tif (!bp->bp_enabled)\n\t\t\t\tbreak;\n\n\t\t\tbp->bp_enabled = 0;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" disabled\\n\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (bp->bp_delay && (cmd == KDBCMD_BC || cmd == KDBCMD_BD)) {\n\t\t\tbp->bp_delay = 0;\n\t\t\tKDB_STATE_CLEAR(SSBPT);\n\t\t}\n\t}\n\n\treturn (!done) ? KDB_BPTNOTFOUND : 0;\n}"
  },
  {
    "function_name": "kdb_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "277-356",
    "snippet": "static int kdb_bp(int argc, const char **argv)\n{\n\tint i, bpno;\n\tkdb_bp_t *bp, *bp_check;\n\tint diag;\n\tchar *symname = NULL;\n\tlong offset = 0ul;\n\tint nextarg;\n\tkdb_bp_t template = {0};\n\n\tif (argc == 0) {\n\t\t/*\n\t\t * Display breakpoint table\n\t\t */\n\t\tfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT;\n\t\t     bpno++, bp++) {\n\t\t\tif (bp->bp_free)\n\t\t\t\tcontinue;\n\t\t\tkdb_printbp(bp, bpno);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &template.bp_addr,\n\t\t\t     &offset, &symname);\n\tif (diag)\n\t\treturn diag;\n\tif (!template.bp_addr)\n\t\treturn KDB_BADINT;\n\n\t/*\n\t * Find an empty bp structure to allocate\n\t */\n\tfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT; bpno++, bp++) {\n\t\tif (bp->bp_free)\n\t\t\tbreak;\n\t}\n\n\tif (bpno == KDB_MAXBPT)\n\t\treturn KDB_TOOMANYBPT;\n\n\tif (strcmp(argv[0], \"bph\") == 0) {\n\t\ttemplate.bp_type = BP_HARDWARE_BREAKPOINT;\n\t\tdiag = kdb_parsebp(argc, argv, &nextarg, &template);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else {\n\t\ttemplate.bp_type = BP_BREAKPOINT;\n\t}\n\n\t/*\n\t * Check for clashing breakpoints.\n\t *\n\t * Note, in this design we can't have hardware breakpoints\n\t * enabled for both read and write on the same address.\n\t */\n\tfor (i = 0, bp_check = kdb_breakpoints; i < KDB_MAXBPT;\n\t     i++, bp_check++) {\n\t\tif (!bp_check->bp_free &&\n\t\t    bp_check->bp_addr == template.bp_addr) {\n\t\t\tkdb_printf(\"You already have a breakpoint at \"\n\t\t\t\t   kdb_bfd_vma_fmt0 \"\\n\", template.bp_addr);\n\t\t\treturn KDB_DUPBPT;\n\t\t}\n\t}\n\n\ttemplate.bp_enabled = 1;\n\n\t/*\n\t * Actually allocate the breakpoint found earlier\n\t */\n\t*bp = template;\n\tbp->bp_free = 0;\n\n\tkdb_printbp(bp, bpno);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printbp",
          "args": [
            "bp",
            "bpno"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printbp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "238-253",
          "snippet": "static void kdb_printbp(kdb_bp_t *bp, int i)\n{\n\tkdb_printf(\"%s \", kdb_bptype(bp));\n\tkdb_printf(\"BP #%d at \", i);\n\tkdb_symbol_print(bp->bp_addr, NULL, KDB_SP_DEFAULT);\n\n\tif (bp->bp_enabled)\n\t\tkdb_printf(\"\\n    is enabled \");\n\telse\n\t\tkdb_printf(\"\\n    is disabled\");\n\n\tkdb_printf(\"  addr at %016lx, hardtype=%d installed=%d\\n\",\n\t\t   bp->bp_addr, bp->bp_type, bp->bp_installed);\n\n\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic void kdb_printbp(kdb_bp_t *bp, int i)\n{\n\tkdb_printf(\"%s \", kdb_bptype(bp));\n\tkdb_printf(\"BP #%d at \", i);\n\tkdb_symbol_print(bp->bp_addr, NULL, KDB_SP_DEFAULT);\n\n\tif (bp->bp_enabled)\n\t\tkdb_printf(\"\\n    is enabled \");\n\telse\n\t\tkdb_printf(\"\\n    is disabled\");\n\n\tkdb_printf(\"  addr at %016lx, hardtype=%d installed=%d\\n\",\n\t\t   bp->bp_addr, bp->bp_type, bp->bp_installed);\n\n\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"You already have a breakpoint at \"\n\t\t\t\t   kdb_bfd_vma_fmt0 \"\\n\"",
            "template.bp_addr"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_parsebp",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&template"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parsebp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "48-90",
          "snippet": "static int kdb_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)\n{\n\tint nextarg = *nextargp;\n\tint diag;\n\n\tbp->bph_length = 1;\n\tif ((argc + 1) != nextarg) {\n\t\tif (strncasecmp(argv[nextarg], \"datar\", sizeof(\"datar\")) == 0)\n\t\t\tbp->bp_type = BP_ACCESS_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"dataw\", sizeof(\"dataw\")) == 0)\n\t\t\tbp->bp_type = BP_WRITE_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"inst\", sizeof(\"inst\")) == 0)\n\t\t\tbp->bp_type = BP_HARDWARE_BREAKPOINT;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tbp->bph_length = 1;\n\n\t\tnextarg++;\n\n\t\tif ((argc + 1) != nextarg) {\n\t\t\tunsigned long len;\n\n\t\t\tdiag = kdbgetularg((char *)argv[nextarg],\n\t\t\t\t\t   &len);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\n\n\t\t\tif (len > 8)\n\t\t\t\treturn KDB_BADLENGTH;\n\n\t\t\tbp->bph_length = len;\n\t\t\tnextarg++;\n\t\t}\n\n\t\tif ((argc + 1) != nextarg)\n\t\t\treturn KDB_ARGCOUNT;\n\t}\n\n\t*nextargp = nextarg;\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int kdb_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)\n{\n\tint nextarg = *nextargp;\n\tint diag;\n\n\tbp->bph_length = 1;\n\tif ((argc + 1) != nextarg) {\n\t\tif (strncasecmp(argv[nextarg], \"datar\", sizeof(\"datar\")) == 0)\n\t\t\tbp->bp_type = BP_ACCESS_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"dataw\", sizeof(\"dataw\")) == 0)\n\t\t\tbp->bp_type = BP_WRITE_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"inst\", sizeof(\"inst\")) == 0)\n\t\t\tbp->bp_type = BP_HARDWARE_BREAKPOINT;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tbp->bph_length = 1;\n\n\t\tnextarg++;\n\n\t\tif ((argc + 1) != nextarg) {\n\t\t\tunsigned long len;\n\n\t\t\tdiag = kdbgetularg((char *)argv[nextarg],\n\t\t\t\t\t   &len);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\n\n\t\t\tif (len > 8)\n\t\t\t\treturn KDB_BADLENGTH;\n\n\t\t\tbp->bph_length = len;\n\t\t\tnextarg++;\n\t\t}\n\n\t\tif ((argc + 1) != nextarg)\n\t\t\treturn KDB_ARGCOUNT;\n\t}\n\n\t*nextargp = nextarg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"bph\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&template.bp_addr",
            "&offset",
            "&symname"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nstatic int kdb_bp(int argc, const char **argv)\n{\n\tint i, bpno;\n\tkdb_bp_t *bp, *bp_check;\n\tint diag;\n\tchar *symname = NULL;\n\tlong offset = 0ul;\n\tint nextarg;\n\tkdb_bp_t template = {0};\n\n\tif (argc == 0) {\n\t\t/*\n\t\t * Display breakpoint table\n\t\t */\n\t\tfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT;\n\t\t     bpno++, bp++) {\n\t\t\tif (bp->bp_free)\n\t\t\t\tcontinue;\n\t\t\tkdb_printbp(bp, bpno);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &template.bp_addr,\n\t\t\t     &offset, &symname);\n\tif (diag)\n\t\treturn diag;\n\tif (!template.bp_addr)\n\t\treturn KDB_BADINT;\n\n\t/*\n\t * Find an empty bp structure to allocate\n\t */\n\tfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT; bpno++, bp++) {\n\t\tif (bp->bp_free)\n\t\t\tbreak;\n\t}\n\n\tif (bpno == KDB_MAXBPT)\n\t\treturn KDB_TOOMANYBPT;\n\n\tif (strcmp(argv[0], \"bph\") == 0) {\n\t\ttemplate.bp_type = BP_HARDWARE_BREAKPOINT;\n\t\tdiag = kdb_parsebp(argc, argv, &nextarg, &template);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else {\n\t\ttemplate.bp_type = BP_BREAKPOINT;\n\t}\n\n\t/*\n\t * Check for clashing breakpoints.\n\t *\n\t * Note, in this design we can't have hardware breakpoints\n\t * enabled for both read and write on the same address.\n\t */\n\tfor (i = 0, bp_check = kdb_breakpoints; i < KDB_MAXBPT;\n\t     i++, bp_check++) {\n\t\tif (!bp_check->bp_free &&\n\t\t    bp_check->bp_addr == template.bp_addr) {\n\t\t\tkdb_printf(\"You already have a breakpoint at \"\n\t\t\t\t   kdb_bfd_vma_fmt0 \"\\n\", template.bp_addr);\n\t\t\treturn KDB_DUPBPT;\n\t\t}\n\t}\n\n\ttemplate.bp_enabled = 1;\n\n\t/*\n\t * Actually allocate the breakpoint found earlier\n\t */\n\t*bp = template;\n\tbp->bp_free = 0;\n\n\tkdb_printbp(bp, bpno);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_printbp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "238-253",
    "snippet": "static void kdb_printbp(kdb_bp_t *bp, int i)\n{\n\tkdb_printf(\"%s \", kdb_bptype(bp));\n\tkdb_printf(\"BP #%d at \", i);\n\tkdb_symbol_print(bp->bp_addr, NULL, KDB_SP_DEFAULT);\n\n\tif (bp->bp_enabled)\n\t\tkdb_printf(\"\\n    is enabled \");\n\telse\n\t\tkdb_printf(\"\\n    is disabled\");\n\n\tkdb_printf(\"  addr at %016lx, hardtype=%d installed=%d\\n\",\n\t\t   bp->bp_addr, bp->bp_type, bp->bp_installed);\n\n\tkdb_printf(\"\\n\");\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_symbol_print",
          "args": [
            "bp->bp_addr",
            "NULL",
            "KDB_SP_DEFAULT"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_symbol_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "258-294",
          "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_bptype",
          "args": [
            "bp"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bptype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "40-46",
          "snippet": "static char *kdb_bptype(kdb_bp_t *bp)\n{\n\tif (bp->bp_type < 0 || bp->bp_type > 4)\n\t\treturn \"\";\n\n\treturn kdb_rwtypes[bp->bp_type];\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *kdb_rwtypes[] = {\n\t\"Instruction(i)\",\n\t\"Instruction(Register)\",\n\t\"Data Write\",\n\t\"I/O\",\n\t\"Data Access\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic char *kdb_rwtypes[] = {\n\t\"Instruction(i)\",\n\t\"Instruction(Register)\",\n\t\"Data Write\",\n\t\"I/O\",\n\t\"Data Access\"\n};\n\nstatic char *kdb_bptype(kdb_bp_t *bp)\n{\n\tif (bp->bp_type < 0 || bp->bp_type > 4)\n\t\treturn \"\";\n\n\treturn kdb_rwtypes[bp->bp_type];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic void kdb_printbp(kdb_bp_t *bp, int i)\n{\n\tkdb_printf(\"%s \", kdb_bptype(bp));\n\tkdb_printf(\"BP #%d at \", i);\n\tkdb_symbol_print(bp->bp_addr, NULL, KDB_SP_DEFAULT);\n\n\tif (bp->bp_enabled)\n\t\tkdb_printf(\"\\n    is enabled \");\n\telse\n\t\tkdb_printf(\"\\n    is disabled\");\n\n\tkdb_printf(\"  addr at %016lx, hardtype=%d installed=%d\\n\",\n\t\t   bp->bp_addr, bp->bp_type, bp->bp_installed);\n\n\tkdb_printf(\"\\n\");\n}"
  },
  {
    "function_name": "kdb_bp_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "205-219",
    "snippet": "void kdb_bp_remove(void)\n{\n\tint i;\n\n\tfor (i = KDB_MAXBPT - 1; i >= 0; i--) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_remove(bp);\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_kdb_bp_remove",
          "args": [
            "bp"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "_kdb_bp_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "92-106",
          "snippet": "static int _kdb_bp_remove(kdb_bp_t *bp)\n{\n\tint ret = 1;\n\tif (!bp->bp_installed)\n\t\treturn ret;\n\tif (!bp->bp_type)\n\t\tret = dbg_remove_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.remove_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0)\n\t\tbp->bp_installed = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int _kdb_bp_remove(kdb_bp_t *bp)\n{\n\tint ret = 1;\n\tif (!bp->bp_installed)\n\t\treturn ret;\n\tif (!bp->bp_type)\n\t\tret = dbg_remove_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.remove_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0)\n\t\tbp->bp_installed = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s: bp %d bp_enabled %d\\n\"",
            "__func__",
            "i",
            "bp->bp_enabled"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "BP"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nvoid kdb_bp_remove(void)\n{\n\tint i;\n\n\tfor (i = KDB_MAXBPT - 1; i >= 0; i--) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_remove(bp);\n\t}\n}"
  },
  {
    "function_name": "kdb_bp_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "174-188",
    "snippet": "void kdb_bp_install(struct pt_regs *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < KDB_MAXBPT; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_install(regs, bp);\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_kdb_bp_install",
          "args": [
            "regs",
            "bp"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "_kdb_bp_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "125-164",
          "snippet": "static int _kdb_bp_install(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tint ret;\n\t/*\n\t * Install the breakpoint, if it is not already installed.\n\t */\n\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"%s: bp_installed %d\\n\",\n\t\t\t   __func__, bp->bp_installed);\n\tif (!KDB_STATE(SSBPT))\n\t\tbp->bp_delay = 0;\n\tif (bp->bp_installed)\n\t\treturn 1;\n\tif (bp->bp_delay || (bp->bp_delayed && KDB_STATE(DOING_SS))) {\n\t\tif (KDB_DEBUG(BP))\n\t\t\tkdb_printf(\"%s: delayed bp\\n\", __func__);\n\t\tkdb_handle_bp(regs, bp);\n\t\treturn 0;\n\t}\n\tif (!bp->bp_type)\n\t\tret = dbg_set_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.set_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0) {\n\t\tbp->bp_installed = 1;\n\t} else {\n\t\tkdb_printf(\"%s: failed to set breakpoint at 0x%lx\\n\",\n\t\t\t   __func__, bp->bp_addr);\n\t\tif (!bp->bp_type) {\n\t\t\tkdb_printf(\"Software breakpoints are unavailable.\\n\"\n\t\t\t\t   \"  Boot the kernel with rodata=off\\n\"\n\t\t\t\t   \"  OR use hw breaks: help bph\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int _kdb_bp_install(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tint ret;\n\t/*\n\t * Install the breakpoint, if it is not already installed.\n\t */\n\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"%s: bp_installed %d\\n\",\n\t\t\t   __func__, bp->bp_installed);\n\tif (!KDB_STATE(SSBPT))\n\t\tbp->bp_delay = 0;\n\tif (bp->bp_installed)\n\t\treturn 1;\n\tif (bp->bp_delay || (bp->bp_delayed && KDB_STATE(DOING_SS))) {\n\t\tif (KDB_DEBUG(BP))\n\t\t\tkdb_printf(\"%s: delayed bp\\n\", __func__);\n\t\tkdb_handle_bp(regs, bp);\n\t\treturn 0;\n\t}\n\tif (!bp->bp_type)\n\t\tret = dbg_set_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.set_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0) {\n\t\tbp->bp_installed = 1;\n\t} else {\n\t\tkdb_printf(\"%s: failed to set breakpoint at 0x%lx\\n\",\n\t\t\t   __func__, bp->bp_addr);\n\t\tif (!bp->bp_type) {\n\t\t\tkdb_printf(\"Software breakpoints are unavailable.\\n\"\n\t\t\t\t   \"  Boot the kernel with rodata=off\\n\"\n\t\t\t\t   \"  OR use hw breaks: help bph\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s: bp %d bp_enabled %d\\n\"",
            "__func__",
            "i",
            "bp->bp_enabled"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "BP"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nvoid kdb_bp_install(struct pt_regs *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < KDB_MAXBPT; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_install(regs, bp);\n\t}\n}"
  },
  {
    "function_name": "_kdb_bp_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "125-164",
    "snippet": "static int _kdb_bp_install(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tint ret;\n\t/*\n\t * Install the breakpoint, if it is not already installed.\n\t */\n\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"%s: bp_installed %d\\n\",\n\t\t\t   __func__, bp->bp_installed);\n\tif (!KDB_STATE(SSBPT))\n\t\tbp->bp_delay = 0;\n\tif (bp->bp_installed)\n\t\treturn 1;\n\tif (bp->bp_delay || (bp->bp_delayed && KDB_STATE(DOING_SS))) {\n\t\tif (KDB_DEBUG(BP))\n\t\t\tkdb_printf(\"%s: delayed bp\\n\", __func__);\n\t\tkdb_handle_bp(regs, bp);\n\t\treturn 0;\n\t}\n\tif (!bp->bp_type)\n\t\tret = dbg_set_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.set_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0) {\n\t\tbp->bp_installed = 1;\n\t} else {\n\t\tkdb_printf(\"%s: failed to set breakpoint at 0x%lx\\n\",\n\t\t\t   __func__, bp->bp_addr);\n\t\tif (!bp->bp_type) {\n\t\t\tkdb_printf(\"Software breakpoints are unavailable.\\n\"\n\t\t\t\t   \"  Boot the kernel with rodata=off\\n\"\n\t\t\t\t   \"  OR use hw breaks: help bph\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Software breakpoints are unavailable.\\n\"\n\t\t\t\t   \"  Boot the kernel with rodata=off\\n\"\n\t\t\t\t   \"  OR use hw breaks: help bph\\n\""
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.set_hw_breakpoint",
          "args": [
            "bp->bp_addr",
            "bp->bph_length",
            "bp->bp_type"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_sw_break",
          "args": [
            "bp->bp_addr"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_set_sw_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "274-313",
          "snippet": "int dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_handle_bp",
          "args": [
            "regs",
            "bp"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_handle_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "108-123",
          "snippet": "static void kdb_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"regs->ip = 0x%lx\\n\", instruction_pointer(regs));\n\n\t/*\n\t * Setup single step\n\t */\n\tkdb_setsinglestep(regs);\n\n\t/*\n\t * Reset delay attribute\n\t */\n\tbp->bp_delay = 0;\n\tbp->bp_delayed = 1;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic void kdb_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"regs->ip = 0x%lx\\n\", instruction_pointer(regs));\n\n\t/*\n\t * Setup single step\n\t */\n\tkdb_setsinglestep(regs);\n\n\t/*\n\t * Reset delay attribute\n\t */\n\tbp->bp_delay = 0;\n\tbp->bp_delayed = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "BP"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_SS"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "SSBPT"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "BP"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int _kdb_bp_install(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tint ret;\n\t/*\n\t * Install the breakpoint, if it is not already installed.\n\t */\n\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"%s: bp_installed %d\\n\",\n\t\t\t   __func__, bp->bp_installed);\n\tif (!KDB_STATE(SSBPT))\n\t\tbp->bp_delay = 0;\n\tif (bp->bp_installed)\n\t\treturn 1;\n\tif (bp->bp_delay || (bp->bp_delayed && KDB_STATE(DOING_SS))) {\n\t\tif (KDB_DEBUG(BP))\n\t\t\tkdb_printf(\"%s: delayed bp\\n\", __func__);\n\t\tkdb_handle_bp(regs, bp);\n\t\treturn 0;\n\t}\n\tif (!bp->bp_type)\n\t\tret = dbg_set_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.set_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0) {\n\t\tbp->bp_installed = 1;\n\t} else {\n\t\tkdb_printf(\"%s: failed to set breakpoint at 0x%lx\\n\",\n\t\t\t   __func__, bp->bp_addr);\n\t\tif (!bp->bp_type) {\n\t\t\tkdb_printf(\"Software breakpoints are unavailable.\\n\"\n\t\t\t\t   \"  Boot the kernel with rodata=off\\n\"\n\t\t\t\t   \"  OR use hw breaks: help bph\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_handle_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "108-123",
    "snippet": "static void kdb_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"regs->ip = 0x%lx\\n\", instruction_pointer(regs));\n\n\t/*\n\t * Setup single step\n\t */\n\tkdb_setsinglestep(regs);\n\n\t/*\n\t * Reset delay attribute\n\t */\n\tbp->bp_delay = 0;\n\tbp->bp_delayed = 1;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_setsinglestep",
          "args": [
            "regs"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_setsinglestep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "27-30",
          "snippet": "static void kdb_setsinglestep(struct pt_regs *regs)\n{\n\tKDB_STATE_SET(DOING_SS);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic void kdb_setsinglestep(struct pt_regs *regs)\n{\n\tKDB_STATE_SET(DOING_SS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"regs->ip = 0x%lx\\n\"",
            "instruction_pointer(regs)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "BP"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic void kdb_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"regs->ip = 0x%lx\\n\", instruction_pointer(regs));\n\n\t/*\n\t * Setup single step\n\t */\n\tkdb_setsinglestep(regs);\n\n\t/*\n\t * Reset delay attribute\n\t */\n\tbp->bp_delay = 0;\n\tbp->bp_delayed = 1;\n}"
  },
  {
    "function_name": "_kdb_bp_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "92-106",
    "snippet": "static int _kdb_bp_remove(kdb_bp_t *bp)\n{\n\tint ret = 1;\n\tif (!bp->bp_installed)\n\t\treturn ret;\n\tif (!bp->bp_type)\n\t\tret = dbg_remove_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.remove_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0)\n\t\tbp->bp_installed = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.remove_hw_breakpoint",
          "args": [
            "bp->bp_addr",
            "bp->bph_length",
            "bp->bp_type"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_remove_sw_break",
          "args": [
            "bp->bp_addr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_sw_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/debug_core.c",
          "lines": "337-349",
          "snippet": "int dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int _kdb_bp_remove(kdb_bp_t *bp)\n{\n\tint ret = 1;\n\tif (!bp->bp_installed)\n\t\treturn ret;\n\tif (!bp->bp_type)\n\t\tret = dbg_remove_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.remove_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0)\n\t\tbp->bp_installed = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "kdb_parsebp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "48-90",
    "snippet": "static int kdb_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)\n{\n\tint nextarg = *nextargp;\n\tint diag;\n\n\tbp->bph_length = 1;\n\tif ((argc + 1) != nextarg) {\n\t\tif (strncasecmp(argv[nextarg], \"datar\", sizeof(\"datar\")) == 0)\n\t\t\tbp->bp_type = BP_ACCESS_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"dataw\", sizeof(\"dataw\")) == 0)\n\t\t\tbp->bp_type = BP_WRITE_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"inst\", sizeof(\"inst\")) == 0)\n\t\t\tbp->bp_type = BP_HARDWARE_BREAKPOINT;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tbp->bph_length = 1;\n\n\t\tnextarg++;\n\n\t\tif ((argc + 1) != nextarg) {\n\t\t\tunsigned long len;\n\n\t\t\tdiag = kdbgetularg((char *)argv[nextarg],\n\t\t\t\t\t   &len);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\n\n\t\t\tif (len > 8)\n\t\t\t\treturn KDB_BADLENGTH;\n\n\t\t\tbp->bph_length = len;\n\t\t\tnextarg++;\n\t\t}\n\n\t\tif ((argc + 1) != nextarg)\n\t\t\treturn KDB_ARGCOUNT;\n\t}\n\n\t*nextargp = nextarg;\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "(char *)argv[nextarg]",
            "&len"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "argv[nextarg]",
            "\"inst\"",
            "sizeof(\"inst\")"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "argv[nextarg]",
            "\"dataw\"",
            "sizeof(\"dataw\")"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "argv[nextarg]",
            "\"datar\"",
            "sizeof(\"datar\")"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int kdb_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)\n{\n\tint nextarg = *nextargp;\n\tint diag;\n\n\tbp->bph_length = 1;\n\tif ((argc + 1) != nextarg) {\n\t\tif (strncasecmp(argv[nextarg], \"datar\", sizeof(\"datar\")) == 0)\n\t\t\tbp->bp_type = BP_ACCESS_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"dataw\", sizeof(\"dataw\")) == 0)\n\t\t\tbp->bp_type = BP_WRITE_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"inst\", sizeof(\"inst\")) == 0)\n\t\t\tbp->bp_type = BP_HARDWARE_BREAKPOINT;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tbp->bph_length = 1;\n\n\t\tnextarg++;\n\n\t\tif ((argc + 1) != nextarg) {\n\t\t\tunsigned long len;\n\n\t\t\tdiag = kdbgetularg((char *)argv[nextarg],\n\t\t\t\t\t   &len);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\n\n\t\t\tif (len > 8)\n\t\t\t\treturn KDB_BADLENGTH;\n\n\t\t\tbp->bph_length = len;\n\t\t\tnextarg++;\n\t\t}\n\n\t\tif ((argc + 1) != nextarg)\n\t\t\treturn KDB_ARGCOUNT;\n\t}\n\n\t*nextargp = nextarg;\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_bptype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "40-46",
    "snippet": "static char *kdb_bptype(kdb_bp_t *bp)\n{\n\tif (bp->bp_type < 0 || bp->bp_type > 4)\n\t\treturn \"\";\n\n\treturn kdb_rwtypes[bp->bp_type];\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *kdb_rwtypes[] = {\n\t\"Instruction(i)\",\n\t\"Instruction(Register)\",\n\t\"Data Write\",\n\t\"I/O\",\n\t\"Data Access\"\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic char *kdb_rwtypes[] = {\n\t\"Instruction(i)\",\n\t\"Instruction(Register)\",\n\t\"Data Write\",\n\t\"I/O\",\n\t\"Data Access\"\n};\n\nstatic char *kdb_bptype(kdb_bp_t *bp)\n{\n\tif (bp->bp_type < 0 || bp->bp_type > 4)\n\t\treturn \"\";\n\n\treturn kdb_rwtypes[bp->bp_type];\n}"
  },
  {
    "function_name": "kdb_setsinglestep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
    "lines": "27-30",
    "snippet": "static void kdb_setsinglestep(struct pt_regs *regs)\n{\n\tKDB_STATE_SET(DOING_SS);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/sched.h>",
      "#include <linux/smp.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kdb.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_SS"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic void kdb_setsinglestep(struct pt_regs *regs)\n{\n\tKDB_STATE_SET(DOING_SS);\n}"
  }
]