[
  {
    "function_name": "cgroup_namespaces_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "152-155",
    "snippet": "static __init int cgroup_namespaces_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic __init int cgroup_namespaces_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroupns_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "138-141",
    "snippet": "static struct user_namespace *cgroupns_owner(struct ns_common *ns)\n{\n\treturn to_cg_ns(ns)->user_ns;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_cg_ns",
          "args": [
            "ns"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "to_cg_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "93-96",
          "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct user_namespace *cgroupns_owner(struct ns_common *ns)\n{\n\treturn to_cg_ns(ns)->user_ns;\n}"
  },
  {
    "function_name": "cgroupns_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "133-136",
    "snippet": "static void cgroupns_put(struct ns_common *ns)\n{\n\tput_cgroup_ns(to_cg_ns(ns));\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "to_cg_ns(ns)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cg_ns",
          "args": [
            "ns"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "to_cg_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "93-96",
          "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroupns_put(struct ns_common *ns)\n{\n\tput_cgroup_ns(to_cg_ns(ns));\n}"
  },
  {
    "function_name": "cgroupns_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "117-131",
    "snippet": "static struct ns_common *cgroupns_get(struct task_struct *task)\n{\n\tstruct cgroup_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->cgroup_ns;\n\t\tget_cgroup_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "ns"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct ns_common *cgroupns_get(struct task_struct *task)\n{\n\tstruct cgroup_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->cgroup_ns;\n\t\tget_cgroup_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}"
  },
  {
    "function_name": "cgroupns_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "98-115",
    "snippet": "static int cgroupns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);\n\n\tif (!ns_capable(current_user_ns(), CAP_SYS_ADMIN) ||\n\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Don't need to do anything if we are attaching to our own cgroupns. */\n\tif (cgroup_ns == nsproxy->cgroup_ns)\n\t\treturn 0;\n\n\tget_cgroup_ns(cgroup_ns);\n\tput_cgroup_ns(nsproxy->cgroup_ns);\n\tnsproxy->cgroup_ns = cgroup_ns;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "nsproxy->cgroup_ns"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "cgroup_ns"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "cgroup_ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cg_ns",
          "args": [
            "ns"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "to_cg_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "93-96",
          "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroupns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);\n\n\tif (!ns_capable(current_user_ns(), CAP_SYS_ADMIN) ||\n\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Don't need to do anything if we are attaching to our own cgroupns. */\n\tif (cgroup_ns == nsproxy->cgroup_ns)\n\t\treturn 0;\n\n\tget_cgroup_ns(cgroup_ns);\n\tput_cgroup_ns(nsproxy->cgroup_ns);\n\tnsproxy->cgroup_ns = cgroup_ns;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "to_cg_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "93-96",
    "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structcgroup_namespace",
            "ns"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
  },
  {
    "function_name": "copy_cgroup_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "50-91",
    "snippet": "struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_cgroup_namespaces",
          "args": [
            "ucounts"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "dec_cgroup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "17-20",
          "snippet": "static void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "159-174",
          "snippet": "static inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ns"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cgroup_ns",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cgroup_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "22-38",
          "snippet": "static struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nconst struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};\n\nstatic struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "179-182",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_cgroup_namespaces",
          "args": [
            "user_ns"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "inc_cgroup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "12-15",
          "snippet": "static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "old_ns"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!old_ns"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}"
  },
  {
    "function_name": "free_cgroup_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "40-47",
    "snippet": "void free_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tput_css_set(ns->root_cset);\n\tdec_cgroup_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkfree(ns);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns->user_ns"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "209-212",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_cgroup_namespaces",
          "args": [
            "ns->ucounts"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "dec_cgroup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
          "lines": "17-20",
          "snippet": "static void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "ns->root_cset"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "159-174",
          "snippet": "static inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nvoid free_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tput_css_set(ns->root_cset);\n\tdec_cgroup_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkfree(ns);\n}"
  },
  {
    "function_name": "alloc_cgroup_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "22-38",
    "snippet": "static struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&new_ns->count",
            "1"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_ns"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_alloc_inum",
          "args": [
            "&new_ns->ns"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cgroup_namespace)",
            "GFP_KERNEL"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nconst struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};\n\nstatic struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}"
  },
  {
    "function_name": "dec_cgroup_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "17-20",
    "snippet": "static void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_ucount",
          "args": [
            "ucounts",
            "UCOUNT_CGROUP_NAMESPACES"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "dec_ucount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "219-227",
          "snippet": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}"
  },
  {
    "function_name": "inc_cgroup_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/namespace.c",
    "lines": "12-15",
    "snippet": "static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_ucount",
          "args": [
            "ns",
            "current_euid()",
            "UCOUNT_CGROUP_NAMESPACES"
          ],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "inc_ucount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "196-217",
          "snippet": "struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}"
  }
]