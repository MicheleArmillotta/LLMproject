[
  {
    "function_name": "init_uprobe_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1432-1446",
    "snippet": "static __init int init_uprobe_trace(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"uprobe_events\", 0644, d_tracer,\n\t\t\t\t    NULL, &uprobe_events_ops);\n\t/* Profile interface */\n\ttrace_create_file(\"uprobe_profile\", 0444, d_tracer,\n\t\t\t\t    NULL, &uprobe_profile_ops);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations uprobe_events_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= probes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= probes_write,\n};",
      "static const struct file_operations uprobe_profile_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= profile_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"uprobe_profile\"",
            "0444",
            "d_tracer",
            "NULL",
            "&uprobe_profile_ops"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic const struct file_operations uprobe_events_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= probes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= probes_write,\n};\nstatic const struct file_operations uprobe_profile_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= profile_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic __init int init_uprobe_trace(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"uprobe_events\", 0644, d_tracer,\n\t\t\t\t    NULL, &uprobe_events_ops);\n\t/* Profile interface */\n\ttrace_create_file(\"uprobe_profile\", 0444, d_tracer,\n\t\t\t\t    NULL, &uprobe_profile_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_local_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1418-1428",
    "snippet": "void destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(event_call, struct trace_uprobe, tp.call);\n\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\n\tfree_trace_uprobe(tu);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "254-266",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tu->tp.call.print_fmt"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event_call",
            "structtrace_uprobe",
            "tp.call"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(event_call, struct trace_uprobe, tp.call);\n\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\n\tfree_trace_uprobe(tu);\n}"
  },
  {
    "function_name": "create_local_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1369-1416",
    "snippet": "struct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tinit_trace_event_call(tu, &tu->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn &tu->tp.call;\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define UPROBE_EVENT_SYSTEM\t\"uprobes\""
    ],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "254-266",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tu->tp",
            "is_ret_probe(tu)"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "621-637",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tu",
            "&tu->tp.call"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1315-1325",
          "snippet": "static inline void init_trace_event_call(struct trace_uprobe *tu,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->define_fields = uprobe_event_define_fields;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE;\n\tcall->class->reg = trace_uprobe_register;\n\tcall->data = tu;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->define_fields = uprobe_event_define_fields;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE;\n\tcall->class->reg = trace_uprobe_register;\n\tcall->data = tu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tu"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate trace_uprobe.(%d)\\n\"",
            "(int)PTR_ERR(tu)"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tu"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tu"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_uprobe",
          "args": [
            "UPROBE_EVENT_SYSTEM",
            "\"DUMMY_EVENT\"",
            "0",
            "is_return"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "215-252",
          "snippet": "static struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\n\tif (!event || !is_good_name(event))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!group || !is_good_name(group))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttu->tp.call.class = &tu->tp.class;\n\ttu->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tu->tp.call.name)\n\t\tgoto error;\n\n\ttu->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tu->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tu->list);\n\tINIT_LIST_HEAD(&tu->tp.files);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(&tu->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu->tp.call.name);\n\tkfree(tu);\n\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\n\tif (!event || !is_good_name(event))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!group || !is_good_name(group))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttu->tp.call.class = &tu->tp.class;\n\ttu->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tu->tp.call.name)\n\t\tgoto error;\n\n\ttu->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tu->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tu->list);\n\tINIT_LIST_HEAD(&tu->tp.files);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(&tu->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu->tp.call.name);\n\tkfree(tu);\n\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "path.dentry"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "name",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstruct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tinit_trace_event_call(tu, &tu->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn &tu->tp.call;\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "unregister_uprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1355-1366",
    "snippet": "static int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\t/* tu->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tu->tp.call);\n\tif (ret)\n\t\treturn ret;\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tu->tp.call.print_fmt"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_remove_event_call",
          "args": [
            "&tu->tp.call"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "trace_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2370-2383",
          "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\t/* tu->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tu->tp.call);\n\tif (ret)\n\t\treturn ret;\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "register_uprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1327-1353",
    "snippet": "static int register_uprobe_event(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tint ret = 0;\n\n\tinit_trace_event_call(tu, call);\n\n\tif (traceprobe_set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0)\n\t\treturn -ENOMEM;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tkfree(call->print_fmt);\n\t\treturn -ENODEV;\n\t}\n\n\tret = trace_add_event_call(call);\n\n\tif (ret) {\n\t\tpr_info(\"Failed to register uprobe event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tkfree(call->print_fmt);\n\t\tunregister_trace_event(&call->event);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "818-825",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->print_fmt"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to register uprobe event: %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_add_event_call",
          "args": [
            "call"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "trace_add_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2309-2322",
          "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tu->tp",
            "is_ret_probe(tu)"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "621-637",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tu",
            "call"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1315-1325",
          "snippet": "static inline void init_trace_event_call(struct trace_uprobe *tu,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->define_fields = uprobe_event_define_fields;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE;\n\tcall->class->reg = trace_uprobe_register;\n\tcall->data = tu;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->define_fields = uprobe_event_define_fields;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE;\n\tcall->class->reg = trace_uprobe_register;\n\tcall->data = tu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int register_uprobe_event(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tint ret = 0;\n\n\tinit_trace_event_call(tu, call);\n\n\tif (traceprobe_set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0)\n\t\treturn -ENOMEM;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tkfree(call->print_fmt);\n\t\treturn -ENODEV;\n\t}\n\n\tret = trace_add_event_call(call);\n\n\tif (ret) {\n\t\tpr_info(\"Failed to register uprobe event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tkfree(call->print_fmt);\n\t\tunregister_trace_event(&call->event);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_trace_event_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1315-1325",
    "snippet": "static inline void init_trace_event_call(struct trace_uprobe *tu,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->define_fields = uprobe_event_define_fields;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE;\n\tcall->class->reg = trace_uprobe_register;\n\tcall->data = tu;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&call->class->fields"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->define_fields = uprobe_event_define_fields;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE;\n\tcall->class->reg = trace_uprobe_register;\n\tcall->data = tu;\n}"
  },
  {
    "function_name": "uretprobe_dispatcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1276-1309",
    "snippet": "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\n\tudd.tu = tu;\n\tudd.bp_addr = func;\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\turetprobe_trace_func(tu, func, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\turetprobe_perf_func(tu, func, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_put",
          "args": [
            "ucb"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "789-792",
          "snippet": "static void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uretprobe_perf_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "uretprobe_perf_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1173-1178",
          "snippet": "static void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uretprobe_trace_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "uretprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "853-863",
          "snippet": "static void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "ucb->buf",
            "&tu->tp",
            "regs",
            "esize",
            "dsize"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "166-188",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_get",
          "args": [],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "772-787",
          "snippet": "static struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tu->tp",
            "regs"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "147-163",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uprobe_cpu_buffer"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "con",
            "structtrace_uprobe",
            "consumer"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\n\tudd.tu = tu;\n\tudd.bp_addr = func;\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\turetprobe_trace_func(tu, func, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\turetprobe_perf_func(tu, func, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn 0;\n}"
  },
  {
    "function_name": "uprobe_dispatcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1239-1274",
    "snippet": "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\tint ret = 0;\n\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\ttu->nhit++;\n\n\tudd.tu = tu;\n\tudd.bp_addr = instruction_pointer(regs);\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\tret |= uprobe_trace_func(tu, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\tret |= uprobe_perf_func(tu, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_put",
          "args": [
            "ucb"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "789-792",
          "snippet": "static void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_perf_func",
          "args": [
            "tu",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1162-1171",
          "snippet": "static int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_trace_func",
          "args": [
            "tu",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "837-851",
          "snippet": "static int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "ucb->buf",
            "&tu->tp",
            "regs",
            "esize",
            "dsize"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "166-188",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_get",
          "args": [],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "772-787",
          "snippet": "static struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tu->tp",
            "regs"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "147-163",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uprobe_cpu_buffer"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "con",
            "structtrace_uprobe",
            "consumer"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\tint ret = 0;\n\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\ttu->nhit++;\n\n\tudd.tu = tu;\n\tudd.bp_addr = instruction_pointer(regs);\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\tret |= uprobe_trace_func(tu, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\tret |= uprobe_perf_func(tu, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_uprobe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1203-1237",
    "snippet": "static int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_uprobe *tu = event->data;\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(tu, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(tu, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(tu, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(tu, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(tu, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(tu, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_perf_close",
          "args": [
            "tu",
            "data"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1038-1058",
          "snippet": "static int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\tuprobe_filter_event(tu, event);\n\t} else {\n\t\ttu->filter.nr_systemwide--;\n\t\tdone = tu->filter.nr_systemwide;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\tif (!done)\n\t\treturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\tuprobe_filter_event(tu, event);\n\t} else {\n\t\ttu->filter.nr_systemwide--;\n\t\tdone = tu->filter.nr_systemwide;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\tif (!done)\n\t\treturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_perf_open",
          "args": [
            "tu",
            "data"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1060-1092",
          "snippet": "static int uprobe_perf_open(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\tint err;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\tuprobe_filter_event(tu, event);\n\t\tlist_add(&event->hw.tp_list, &tu->filter.perf_events);\n\t} else {\n\t\tdone = tu->filter.nr_systemwide;\n\t\ttu->filter.nr_systemwide++;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\terr = 0;\n\tif (!done) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err)\n\t\t\tuprobe_perf_close(tu, event);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_perf_open(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\tint err;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\tuprobe_filter_event(tu, event);\n\t\tlist_add(&event->hw.tp_list, &tu->filter.perf_events);\n\t} else {\n\t\tdone = tu->filter.nr_systemwide;\n\t\ttu->filter.nr_systemwide++;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\terr = 0;\n\tif (!done) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err)\n\t\t\tuprobe_perf_close(tu, event);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_event_disable",
          "args": [
            "tu",
            "NULL"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "probe_event_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "966-995",
          "snippet": "static void\nprobe_event_disable(struct trace_uprobe *tu, struct trace_event_file *file)\n{\n\tif (!trace_probe_is_enabled(&tu->tp))\n\t\treturn;\n\n\tif (file) {\n\t\tstruct event_file_link *link;\n\n\t\tlink = find_event_file_link(&tu->tp, file);\n\t\tif (!link)\n\t\t\treturn;\n\n\t\tlist_del_rcu(&link->list);\n\t\t/* synchronize with u{,ret}probe_trace_func */\n\t\tsynchronize_rcu();\n\t\tkfree(link);\n\n\t\tif (!list_empty(&tu->tp.files))\n\t\t\treturn;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\ttu->inode = NULL;\n\ttu->tp.flags &= file ? ~TP_FLAG_TRACE : ~TP_FLAG_PROFILE;\n\n\tuprobe_buffer_disable();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void\nprobe_event_disable(struct trace_uprobe *tu, struct trace_event_file *file)\n{\n\tif (!trace_probe_is_enabled(&tu->tp))\n\t\treturn;\n\n\tif (file) {\n\t\tstruct event_file_link *link;\n\n\t\tlink = find_event_file_link(&tu->tp, file);\n\t\tif (!link)\n\t\t\treturn;\n\n\t\tlist_del_rcu(&link->list);\n\t\t/* synchronize with u{,ret}probe_trace_func */\n\t\tsynchronize_rcu();\n\t\tkfree(link);\n\n\t\tif (!list_empty(&tu->tp.files))\n\t\t\treturn;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\ttu->inode = NULL;\n\ttu->tp.flags &= file ? ~TP_FLAG_TRACE : ~TP_FLAG_PROFILE;\n\n\tuprobe_buffer_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_event_enable",
          "args": [
            "tu",
            "NULL",
            "uprobe_perf_filter"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "probe_event_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "902-964",
          "snippet": "static int\nprobe_event_enable(struct trace_uprobe *tu, struct trace_event_file *file,\n\t\t   filter_func_t filter)\n{\n\tbool enabled = trace_probe_is_enabled(&tu->tp);\n\tstruct event_file_link *link = NULL;\n\tint ret;\n\n\tif (file) {\n\t\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\t\treturn -EINTR;\n\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn -ENOMEM;\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tu->tp.files);\n\n\t\ttu->tp.flags |= TP_FLAG_TRACE;\n\t} else {\n\t\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\t\treturn -EINTR;\n\n\t\ttu->tp.flags |= TP_FLAG_PROFILE;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\tif (tu->ref_ctr_offset) {\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\t} else {\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\t}\n\n\tif (ret)\n\t\tgoto err_buffer;\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file) {\n\t\tlist_del(&link->list);\n\t\tkfree(link);\n\t\ttu->tp.flags &= ~TP_FLAG_TRACE;\n\t} else {\n\t\ttu->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int\nprobe_event_enable(struct trace_uprobe *tu, struct trace_event_file *file,\n\t\t   filter_func_t filter)\n{\n\tbool enabled = trace_probe_is_enabled(&tu->tp);\n\tstruct event_file_link *link = NULL;\n\tint ret;\n\n\tif (file) {\n\t\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\t\treturn -EINTR;\n\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn -ENOMEM;\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tu->tp.files);\n\n\t\ttu->tp.flags |= TP_FLAG_TRACE;\n\t} else {\n\t\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\t\treturn -EINTR;\n\n\t\ttu->tp.flags |= TP_FLAG_PROFILE;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\tif (tu->ref_ctr_offset) {\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\t} else {\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\t}\n\n\tif (ret)\n\t\tgoto err_buffer;\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file) {\n\t\tlist_del(&link->list);\n\t\tkfree(link);\n\t\ttu->tp.flags &= ~TP_FLAG_TRACE;\n\t} else {\n\t\ttu->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_uprobe *tu = event->data;\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(tu, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(tu, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(tu, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(tu, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(tu, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(tu, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_get_uprobe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1180-1200",
    "snippet": "int bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tbool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = event->tp_event->data;\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_probe_event",
          "args": [
            "pevent",
            "group"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "find_probe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "268-278",
          "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static LIST_HEAD(uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic LIST_HEAD(uprobe_list);\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "event->tp_event"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nint bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tbool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = event->tp_event->data;\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\treturn 0;\n}"
  },
  {
    "function_name": "uretprobe_perf_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1173-1178",
    "snippet": "static void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_perf_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1108-1159",
          "snippet": "static void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}"
  },
  {
    "function_name": "uprobe_perf_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1162-1171",
    "snippet": "static int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_perf_func",
          "args": [
            "tu",
            "0",
            "regs",
            "ucb",
            "dsize"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1108-1159",
          "snippet": "static void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_perf_filter",
          "args": [
            "&tu->consumer",
            "0",
            "current->mm"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1094-1106",
          "snippet": "static bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tread_lock(&tu->filter.rwlock);\n\tret = __uprobe_perf_filter(&tu->filter, mm);\n\tread_unlock(&tu->filter.rwlock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tread_lock(&tu->filter.rwlock);\n\tret = __uprobe_perf_filter(&tu->filter, mm);\n\tread_unlock(&tu->filter.rwlock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}"
  },
  {
    "function_name": "__uprobe_perf_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1108-1159",
    "snippet": "static void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "size",
            "rctx",
            "call->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data + len",
            "0",
            "size - esize - len"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "ucb->buf",
            "tu->tp.size + dsize"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "false"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "true"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "388-410",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "call->perf_events"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "size > PERF_MAX_TRACE_SIZE",
            "\"profile buffer not large enough\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "regs"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "37-79",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "call"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = &tu->tp.call;\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "uprobe_perf_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1094-1106",
    "snippet": "static bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tread_lock(&tu->filter.rwlock);\n\tret = __uprobe_perf_filter(&tu->filter, mm);\n\tread_unlock(&tu->filter.rwlock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tu->filter.rwlock"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_perf_filter",
          "args": [
            "&tu->filter",
            "mm"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1016-1030",
          "snippet": "static bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tu->filter.rwlock"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "uc",
            "structtrace_uprobe",
            "consumer"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tread_lock(&tu->filter.rwlock);\n\tret = __uprobe_perf_filter(&tu->filter, mm);\n\tread_unlock(&tu->filter.rwlock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_perf_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1060-1092",
    "snippet": "static int uprobe_perf_open(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\tint err;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\tuprobe_filter_event(tu, event);\n\t\tlist_add(&event->hw.tp_list, &tu->filter.perf_events);\n\t} else {\n\t\tdone = tu->filter.nr_systemwide;\n\t\ttu->filter.nr_systemwide++;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\terr = 0;\n\tif (!done) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err)\n\t\t\tuprobe_perf_close(tu, event);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_perf_close",
          "args": [
            "tu",
            "event"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_perf_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1038-1058",
          "snippet": "static int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\tuprobe_filter_event(tu, event);\n\t} else {\n\t\ttu->filter.nr_systemwide--;\n\t\tdone = tu->filter.nr_systemwide;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\tif (!done)\n\t\treturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\tuprobe_filter_event(tu, event);\n\t} else {\n\t\ttu->filter.nr_systemwide--;\n\t\tdone = tu->filter.nr_systemwide;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\tif (!done)\n\t\treturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_apply",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer",
            "true"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1175-1195",
          "snippet": "int uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&tu->filter.rwlock"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->hw.tp_list",
            "&tu->filter.perf_events"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_filter_event",
          "args": [
            "tu",
            "event"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_filter_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1032-1036",
          "snippet": "static inline bool\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(&tu->filter, event->hw.target->mm);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(&tu->filter, event->hw.target->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&tu->filter.rwlock"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_perf_open(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\tint err;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\t/*\n\t\t * event->parent != NULL means copy_process(), we can avoid\n\t\t * uprobe_apply(). current->mm must be probed and we can rely\n\t\t * on dup_mmap() which preserves the already installed bp's.\n\t\t *\n\t\t * attr.enable_on_exec means that exec/mmap will install the\n\t\t * breakpoints we need.\n\t\t */\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\tuprobe_filter_event(tu, event);\n\t\tlist_add(&event->hw.tp_list, &tu->filter.perf_events);\n\t} else {\n\t\tdone = tu->filter.nr_systemwide;\n\t\ttu->filter.nr_systemwide++;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\terr = 0;\n\tif (!done) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err)\n\t\t\tuprobe_perf_close(tu, event);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "uprobe_perf_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1038-1058",
    "snippet": "static int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\tuprobe_filter_event(tu, event);\n\t} else {\n\t\ttu->filter.nr_systemwide--;\n\t\tdone = tu->filter.nr_systemwide;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\tif (!done)\n\t\treturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_apply",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer",
            "false"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1175-1195",
          "snippet": "int uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&tu->filter.rwlock"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_filter_event",
          "args": [
            "tu",
            "event"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_filter_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1032-1036",
          "snippet": "static inline bool\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(&tu->filter, event->hw.target->mm);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(&tu->filter, event->hw.target->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->hw.tp_list"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&tu->filter.rwlock"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&tu->filter.rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = tu->filter.nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\tuprobe_filter_event(tu, event);\n\t} else {\n\t\ttu->filter.nr_systemwide--;\n\t\tdone = tu->filter.nr_systemwide;\n\t}\n\twrite_unlock(&tu->filter.rwlock);\n\n\tif (!done)\n\t\treturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "uprobe_filter_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1032-1036",
    "snippet": "static inline bool\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(&tu->filter, event->hw.target->mm);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_perf_filter",
          "args": [
            "&tu->filter",
            "event->hw.target->mm"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_perf_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1016-1030",
          "snippet": "static bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(&tu->filter, event->hw.target->mm);\n}"
  },
  {
    "function_name": "__uprobe_perf_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "1016-1030",
    "snippet": "static bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "event",
            "&filter->perf_events",
            "hw.tp_list"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "uprobe_event_define_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "997-1013",
    "snippet": "static int uprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret, size;\n\tstruct uprobe_trace_entry_head field;\n\tstruct trace_uprobe *tu = event_call->data;\n\n\tif (is_ret_probe(tu)) {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\n\t\tDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(true);\n\t} else {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(false);\n\t}\n\n\treturn traceprobe_define_arg_fields(event_call, size, &tu->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "size",
            "&tu->tp"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "639-662",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "false"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "true"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret, size;\n\tstruct uprobe_trace_entry_head field;\n\tstruct trace_uprobe *tu = event_call->data;\n\n\tif (is_ret_probe(tu)) {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\n\t\tDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(true);\n\t} else {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(false);\n\t}\n\n\treturn traceprobe_define_arg_fields(event_call, size, &tu->tp);\n}"
  },
  {
    "function_name": "probe_event_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "966-995",
    "snippet": "static void\nprobe_event_disable(struct trace_uprobe *tu, struct trace_event_file *file)\n{\n\tif (!trace_probe_is_enabled(&tu->tp))\n\t\treturn;\n\n\tif (file) {\n\t\tstruct event_file_link *link;\n\n\t\tlink = find_event_file_link(&tu->tp, file);\n\t\tif (!link)\n\t\t\treturn;\n\n\t\tlist_del_rcu(&link->list);\n\t\t/* synchronize with u{,ret}probe_trace_func */\n\t\tsynchronize_rcu();\n\t\tkfree(link);\n\n\t\tif (!list_empty(&tu->tp.files))\n\t\t\treturn;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\ttu->inode = NULL;\n\ttu->tp.flags &= file ? ~TP_FLAG_TRACE : ~TP_FLAG_PROFILE;\n\n\tuprobe_buffer_disable();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_disable",
          "args": [],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "756-770",
          "snippet": "static void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;",
            "static int uprobe_buffer_refcnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_unregister",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1077-1089",
          "snippet": "void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_filter_is_empty(&tu->filter)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_filter_is_empty",
          "args": [
            "&tu->filter"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_filter_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "202-205",
          "snippet": "static inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tu->tp.files"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&link->list"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file_link",
          "args": [
            "&tu->tp",
            "file"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "258-268",
          "snippet": "static inline struct event_file_link *\nfind_event_file_link(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry(link, &tp->files, list)\n\t\tif (link->file == file)\n\t\t\treturn link;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct event_file_link *\nfind_event_file_link(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry(link, &tp->files, list)\n\t\tif (link->file == file)\n\t\t\treturn link;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tu->tp"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void\nprobe_event_disable(struct trace_uprobe *tu, struct trace_event_file *file)\n{\n\tif (!trace_probe_is_enabled(&tu->tp))\n\t\treturn;\n\n\tif (file) {\n\t\tstruct event_file_link *link;\n\n\t\tlink = find_event_file_link(&tu->tp, file);\n\t\tif (!link)\n\t\t\treturn;\n\n\t\tlist_del_rcu(&link->list);\n\t\t/* synchronize with u{,ret}probe_trace_func */\n\t\tsynchronize_rcu();\n\t\tkfree(link);\n\n\t\tif (!list_empty(&tu->tp.files))\n\t\t\treturn;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\ttu->inode = NULL;\n\ttu->tp.flags &= file ? ~TP_FLAG_TRACE : ~TP_FLAG_PROFILE;\n\n\tuprobe_buffer_disable();\n}"
  },
  {
    "function_name": "probe_event_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "902-964",
    "snippet": "static int\nprobe_event_enable(struct trace_uprobe *tu, struct trace_event_file *file,\n\t\t   filter_func_t filter)\n{\n\tbool enabled = trace_probe_is_enabled(&tu->tp);\n\tstruct event_file_link *link = NULL;\n\tint ret;\n\n\tif (file) {\n\t\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\t\treturn -EINTR;\n\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn -ENOMEM;\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tu->tp.files);\n\n\t\ttu->tp.flags |= TP_FLAG_TRACE;\n\t} else {\n\t\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\t\treturn -EINTR;\n\n\t\ttu->tp.flags |= TP_FLAG_PROFILE;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\tif (tu->ref_ctr_offset) {\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\t} else {\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\t}\n\n\tif (ret)\n\t\tgoto err_buffer;\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file) {\n\t\tlist_del(&link->list);\n\t\tkfree(link);\n\t\ttu->tp.flags &= ~TP_FLAG_TRACE;\n\t} else {\n\t\ttu->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->list"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_disable",
          "args": [],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "756-770",
          "snippet": "static void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;",
            "static int uprobe_buffer_refcnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_register",
          "args": [
            "tu->inode",
            "tu->offset",
            "&tu->consumer"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "trace_uprobe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1203-1237",
          "snippet": "static int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_uprobe *tu = event->data;\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(tu, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(tu, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(tu, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(tu, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(tu, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(tu, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_uprobe *tu = event->data;\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(tu, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(tu, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(tu, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(tu, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(tu, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(tu, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_register_refctr",
          "args": [
            "tu->inode",
            "tu->offset",
            "tu->ref_ctr_offset",
            "&tu->consumer"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_register_refctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1161-1165",
          "snippet": "int uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "tu->path.dentry"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_buffer_enable",
          "args": [],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "741-754",
          "snippet": "static int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int uprobe_buffer_refcnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int uprobe_buffer_refcnt;\n\nstatic int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_filter_is_empty(&tu->filter)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_filter_is_empty",
          "args": [
            "&tu->filter"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_filter_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "202-205",
          "snippet": "static inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&link->list",
            "&tu->tp.files"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*link)",
            "GFP_KERNEL"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tu->tp"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int\nprobe_event_enable(struct trace_uprobe *tu, struct trace_event_file *file,\n\t\t   filter_func_t filter)\n{\n\tbool enabled = trace_probe_is_enabled(&tu->tp);\n\tstruct event_file_link *link = NULL;\n\tint ret;\n\n\tif (file) {\n\t\tif (tu->tp.flags & TP_FLAG_PROFILE)\n\t\t\treturn -EINTR;\n\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn -ENOMEM;\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tu->tp.files);\n\n\t\ttu->tp.flags |= TP_FLAG_TRACE;\n\t} else {\n\t\tif (tu->tp.flags & TP_FLAG_TRACE)\n\t\t\treturn -EINTR;\n\n\t\ttu->tp.flags |= TP_FLAG_PROFILE;\n\t}\n\n\tWARN_ON(!uprobe_filter_is_empty(&tu->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\tif (tu->ref_ctr_offset) {\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\t} else {\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\t}\n\n\tif (ret)\n\t\tgoto err_buffer;\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file) {\n\t\tlist_del(&link->list);\n\t\tkfree(link);\n\t\ttu->tp.flags &= ~TP_FLAG_TRACE;\n\t} else {\n\t\ttu->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "print_uprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "866-896",
    "snippet": "static enum print_line_t\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_uprobe *tu;\n\tu8 *data;\n\n\tentry = (struct uprobe_trace_entry_head *)iter->ent;\n\ttu = container_of(event, struct trace_uprobe, tp.call.event);\n\n\tif (is_ret_probe(tu)) {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx <- 0x%lx)\",\n\t\t\t\t trace_event_name(&tu->tp.call),\n\t\t\t\t entry->vaddr[1], entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx)\",\n\t\t\t\t trace_event_name(&tu->tp.call),\n\t\t\t\t entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tif (print_probe_args(s, tu->tp.args, tu->tp.nr_args, data, entry) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tu->tp.args",
            "tu->tp.nr_args",
            "data",
            "entry"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-216",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "false"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: (0x%lx)\"",
            "trace_event_name(&tu->tp.call)",
            "entry->vaddr[0]"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tu->tp.call"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "true"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tu->tp.call"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_uprobe",
            "tp.call.event"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic enum print_line_t\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_uprobe *tu;\n\tu8 *data;\n\n\tentry = (struct uprobe_trace_entry_head *)iter->ent;\n\ttu = container_of(event, struct trace_uprobe, tp.call.event);\n\n\tif (is_ret_probe(tu)) {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx <- 0x%lx)\",\n\t\t\t\t trace_event_name(&tu->tp.call),\n\t\t\t\t entry->vaddr[1], entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx)\",\n\t\t\t\t trace_event_name(&tu->tp.call),\n\t\t\t\t entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tif (print_probe_args(s, tu->tp.args, tu->tp.nr_args, data, entry) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "uretprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "853-863",
    "snippet": "static void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_trace_func",
          "args": [
            "tu",
            "func",
            "regs",
            "ucb",
            "dsize",
            "link->file"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "794-834",
          "snippet": "static void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = &tu->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type, size, 0, 0);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry, 0, 0);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = &tu->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type, size, 0, 0);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "link",
            "&tu->tp.files",
            "list"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "uprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "837-851",
    "snippet": "static int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_trace_func",
          "args": [
            "tu",
            "0",
            "regs",
            "ucb",
            "dsize",
            "link->file"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "794-834",
          "snippet": "static void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = &tu->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type, size, 0, 0);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry, 0, 0);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = &tu->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type, size, 0, 0);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "link",
            "&tu->tp.files",
            "list"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(link, &tu->tp.files, list)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__uprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "794-834",
    "snippet": "static void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = &tu->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type, size, 0, 0);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry, 0, 0);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);",
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "0",
            "0"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1323-1336",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "ucb->buf",
            "tu->tp.size + dsize"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "false"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATAOF_TRACE_ENTRY",
          "args": [
            "entry",
            "true"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "trace_file",
            "call->event.type",
            "size",
            "0",
            "0"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2274-2312",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct ring_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_ENTRY",
          "args": [
            "is_ret_probe(tu)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tu->tp.size + dsize > PAGE_SIZE"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "call != trace_file->event_call"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = &tu->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type, size, 0, 0);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry, 0, 0);\n}"
  },
  {
    "function_name": "uprobe_buffer_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "789-792",
    "snippet": "static void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ucb->mutex"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}"
  },
  {
    "function_name": "uprobe_buffer_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "772-787",
    "snippet": "static struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ucb->mutex"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t/*\n\t * Use per-cpu buffers for fastest access, but we might migrate\n\t * so the mutex makes sure we have sole access to it.\n\t */\n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}"
  },
  {
    "function_name": "uprobe_buffer_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "756-770",
    "snippet": "static void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;",
      "static int uprobe_buffer_refcnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&event_mutex)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&event_mutex"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}"
  },
  {
    "function_name": "uprobe_buffer_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "741-754",
    "snippet": "static int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int uprobe_buffer_refcnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_buffer_init",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_buffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "709-739",
          "snippet": "static int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&event_mutex)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&event_mutex"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int uprobe_buffer_refcnt;\n\nstatic int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_buffer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "709-739",
    "snippet": "static int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "uprobe_cpu_buffer"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kexec_core.c",
          "lines": "339-347",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/frame.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/frame.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "uprobe_cpu_buffer",
            "cpu"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "cpu_to_node(cpu)",
            "GFP_KERNEL",
            "0"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structuprobe_cpu_buffer"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\n\nstatic int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "profile_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "689-692",
    "snippet": "static int profile_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &profile_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations profile_seq_op = {\n\t.start\t= probes_seq_start,\n\t.next\t= probes_seq_next,\n\t.stop\t= probes_seq_stop,\n\t.show\t= probes_profile_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&profile_seq_op"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations profile_seq_op = {\n\t.start\t= probes_seq_start,\n\t.next\t= probes_seq_next,\n\t.stop\t= probes_seq_stop,\n\t.show\t= probes_profile_seq_show\n};\n\nstatic int profile_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &profile_seq_op);\n}"
  },
  {
    "function_name": "probes_profile_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "673-680",
    "snippet": "static int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_uprobe *tu = v;\n\n\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,\n\t\t\ttrace_event_name(&tu->tp.call), tu->nhit);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %s %-44s %15lu\\n\"",
            "tu->filename",
            "trace_event_name(&tu->tp.call)",
            "tu->nhit"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tu->tp.call"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_uprobe *tu = v;\n\n\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,\n\t\t\ttrace_event_name(&tu->tp.call), tu->nhit);\n\treturn 0;\n}"
  },
  {
    "function_name": "probes_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "657-661",
    "snippet": "static ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos, create_trace_uprobe);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_trace_uprobe"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8407-8470",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos, create_trace_uprobe);\n}"
  },
  {
    "function_name": "probes_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "644-655",
    "snippet": "static int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = cleanup_all_probes();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations probes_seq_op = {\n\t.start\t= probes_seq_start,\n\t.next\t= probes_seq_next,\n\t.stop\t= probes_seq_stop,\n\t.show\t= probes_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&probes_seq_op"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_all_probes",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_all_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "584-598",
          "snippet": "static int cleanup_all_probes(void)\n{\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\tmutex_lock(&uprobe_lock);\n\twhile (!list_empty(&uprobe_list)) {\n\t\ttu = list_entry(uprobe_list.next, struct trace_uprobe, list);\n\t\tret = unregister_trace_uprobe(tu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&uprobe_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static DEFINE_MUTEX(uprobe_lock);",
            "static LIST_HEAD(uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic DEFINE_MUTEX(uprobe_lock);\nstatic LIST_HEAD(uprobe_list);\n\nstatic int cleanup_all_probes(void)\n{\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\tmutex_lock(&uprobe_lock);\n\twhile (!list_empty(&uprobe_list)) {\n\t\ttu = list_entry(uprobe_list.next, struct trace_uprobe, list);\n\t\tret = unregister_trace_uprobe(tu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&uprobe_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations probes_seq_op = {\n\t.start\t= probes_seq_start,\n\t.next\t= probes_seq_next,\n\t.stop\t= probes_seq_stop,\n\t.show\t= probes_seq_show\n};\n\nstatic int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = cleanup_all_probes();\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}"
  },
  {
    "function_name": "probes_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "617-635",
    "snippet": "static int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_uprobe *tu = v;\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, tu->tp.call.class->system,\n\t\t\ttrace_event_name(&tu->tp.call), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s=%s\"",
            "tu->tp.args[i].name",
            "tu->tp.args[i].comm"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tu->tp.call"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ret_probe",
          "args": [
            "tu"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "is_ret_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "207-210",
          "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_uprobe *tu = v;\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, tu->tp.call.class->system,\n\t\t\ttrace_event_name(&tu->tp.call), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "probes_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "612-615",
    "snippet": "static void probes_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&uprobe_lock);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(uprobe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(uprobe_lock);\n\nstatic void probes_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&uprobe_lock);\n}"
  },
  {
    "function_name": "probes_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "607-610",
    "snippet": "static void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &uprobe_list, pos);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&uprobe_list",
            "pos"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(uprobe_list);\n\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &uprobe_list, pos);\n}"
  },
  {
    "function_name": "probes_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "601-605",
    "snippet": "static void *probes_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&uprobe_lock);\n\treturn seq_list_start(&uprobe_list, *pos);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(uprobe_lock);",
      "static LIST_HEAD(uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&uprobe_list",
            "*pos"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(uprobe_lock);\nstatic LIST_HEAD(uprobe_list);\n\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&uprobe_lock);\n\treturn seq_list_start(&uprobe_list, *pos);\n}"
  },
  {
    "function_name": "cleanup_all_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "584-598",
    "snippet": "static int cleanup_all_probes(void)\n{\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\tmutex_lock(&uprobe_lock);\n\twhile (!list_empty(&uprobe_list)) {\n\t\ttu = list_entry(uprobe_list.next, struct trace_uprobe, list);\n\t\tret = unregister_trace_uprobe(tu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&uprobe_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static DEFINE_MUTEX(uprobe_lock);",
      "static LIST_HEAD(uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "281-292",
          "snippet": "static int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "uprobe_list.next",
            "structtrace_uprobe",
            "list"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&uprobe_list"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic DEFINE_MUTEX(uprobe_lock);\nstatic LIST_HEAD(uprobe_list);\n\nstatic int cleanup_all_probes(void)\n{\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\tmutex_lock(&uprobe_lock);\n\twhile (!list_empty(&uprobe_list)) {\n\t\ttu = list_entry(uprobe_list.next, struct trace_uprobe, list);\n\t\tret = unregister_trace_uprobe(tu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&uprobe_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "create_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "365-582",
    "snippet": "static int create_trace_uprobe(int argc, char **argv)\n{\n\tstruct trace_uprobe *tu;\n\tchar *arg, *event, *group, *filename, *rctr, *rctr_end;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tstruct path path;\n\tunsigned long offset, ref_ctr_offset;\n\tbool is_delete, is_return;\n\tint i, ret;\n\n\tret = 0;\n\tis_delete = false;\n\tis_return = false;\n\tevent = NULL;\n\tgroup = NULL;\n\tref_ctr_offset = 0;\n\n\t/* argc must be >= 1 */\n\tif (argv[0][0] == '-')\n\t\tis_delete = true;\n\telse if (argv[0][0] == 'r')\n\t\tis_return = true;\n\telse if (argv[0][0] != 'p') {\n\t\tpr_info(\"Probe definition must be started with 'p', 'r' or '-'.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argv[0][1] == ':') {\n\t\tevent = &argv[0][2];\n\t\targ = strchr(event, '/');\n\n\t\tif (arg) {\n\t\t\tgroup = event;\n\t\t\tevent = arg + 1;\n\t\t\tevent[-1] = '\\0';\n\n\t\t\tif (strlen(group) == 0) {\n\t\t\t\tpr_info(\"Group name is not specified\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (strlen(event) == 0) {\n\t\t\tpr_info(\"Event name is not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!group)\n\t\tgroup = UPROBE_EVENT_SYSTEM;\n\n\tif (is_delete) {\n\t\tint ret;\n\n\t\tif (!event) {\n\t\t\tpr_info(\"Delete command needs an event name.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&uprobe_lock);\n\t\ttu = find_probe_event(event, group);\n\n\t\tif (!tu) {\n\t\t\tmutex_unlock(&uprobe_lock);\n\t\t\tpr_info(\"Event %s/%s doesn't exist.\\n\", group, event);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t/* delete an event */\n\t\tret = unregister_trace_uprobe(tu);\n\t\tmutex_unlock(&uprobe_lock);\n\t\treturn ret;\n\t}\n\n\tif (argc < 2) {\n\t\tpr_info(\"Probe point is not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* Find the last occurrence, in case the path contains ':' too. */\n\targ = strrchr(argv[1], ':');\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\t*arg++ = '\\0';\n\tfilename = argv[1];\n\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_address_parse;\n\t}\n\n\t/* Parse reference counter offset if specified. */\n\trctr = strchr(arg, '(');\n\tif (rctr) {\n\t\trctr_end = strchr(rctr, ')');\n\t\tif (rctr > rctr_end || *(rctr_end + 1) != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tpr_info(\"Invalid reference counter offset.\\n\");\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\t*rctr++ = '\\0';\n\t\t*rctr_end = '\\0';\n\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);\n\t\tif (ret) {\n\t\t\tpr_info(\"Invalid reference counter offset.\\n\");\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t/* Parse uprobe offset. */\n\tret = kstrtoul(arg, 0, &offset);\n\tif (ret)\n\t\tgoto fail_address_parse;\n\n\targc -= 2;\n\targv += 2;\n\n\t/* setup a probe */\n\tif (!event) {\n\t\tchar *tail;\n\t\tchar *ptr;\n\n\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);\n\t\tif (!tail) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\tptr = strpbrk(tail, \".-_\");\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);\n\t\tevent = buf;\n\t\tkfree(tail);\n\t}\n\n\ttu = alloc_trace_uprobe(group, event, argc, is_return);\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\", (int)PTR_ERR(tu));\n\t\tret = PTR_ERR(tu);\n\t\tgoto fail_address_parse;\n\t}\n\ttu->offset = offset;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->path = path;\n\ttu->filename = kstrdup(filename, GFP_KERNEL);\n\n\tif (!tu->filename) {\n\t\tpr_info(\"Failed to allocate filename.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* parse arguments */\n\tret = 0;\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\tstruct probe_arg *parg = &tu->tp.args[i];\n\n\t\t/* Increment count for freeing args in error case */\n\t\ttu->tp.nr_args++;\n\n\t\t/* Parse argument name */\n\t\targ = strchr(argv[i], '=');\n\t\tif (arg) {\n\t\t\t*arg++ = '\\0';\n\t\t\tparg->name = kstrdup(argv[i], GFP_KERNEL);\n\t\t} else {\n\t\t\targ = argv[i];\n\t\t\t/* If argument name is omitted, set \"argN\" */\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"arg%d\", i + 1);\n\t\t\tparg->name = kstrdup(buf, GFP_KERNEL);\n\t\t}\n\n\t\tif (!parg->name) {\n\t\t\tpr_info(\"Failed to allocate argument[%d] name.\\n\", i);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!is_good_name(parg->name)) {\n\t\t\tpr_info(\"Invalid argument[%d] name: %s\\n\", i, parg->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (traceprobe_conflict_field_name(parg->name, tu->tp.args, i)) {\n\t\t\tpr_info(\"Argument[%d] name '%s' conflicts with \"\n\t\t\t\t\"another field.\\n\", i, argv[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Parse fetch argument */\n\t\tret = traceprobe_parse_probe_arg(arg, &tu->tp.size, parg,\n\t\t\t\t\tis_return ? TPARG_FL_RETURN : 0);\n\t\tif (ret) {\n\t\t\tpr_info(\"Parse error at argument[%d]. (%d)\\n\", i, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = register_trace_uprobe(tu);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ret;\n\nfail_address_parse:\n\tpath_put(&path);\n\n\tpr_info(\"Failed to parse address or file.\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define UPROBE_EVENT_SYSTEM\t\"uprobes\""
    ],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static DEFINE_MUTEX(uprobe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to parse address or file.\\n\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "254-266",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "register_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "324-357",
          "snippet": "static int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&uprobe_lock);\n\n\t/* register as an event */\n\told_tu = find_old_trace_uprobe(tu);\n\tif (IS_ERR(old_tu)) {\n\t\tret = PTR_ERR(old_tu);\n\t\tgoto end;\n\t}\n\n\tif (old_tu) {\n\t\t/* delete old event */\n\t\tret = unregister_trace_uprobe(old_tu);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tlist_add_tail(&tu->list, &uprobe_list);\n\nend:\n\tmutex_unlock(&uprobe_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static DEFINE_MUTEX(uprobe_lock);",
            "static LIST_HEAD(uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic DEFINE_MUTEX(uprobe_lock);\nstatic LIST_HEAD(uprobe_list);\n\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&uprobe_lock);\n\n\t/* register as an event */\n\told_tu = find_old_trace_uprobe(tu);\n\tif (IS_ERR(old_tu)) {\n\t\tret = PTR_ERR(old_tu);\n\t\tgoto end;\n\t}\n\n\tif (old_tu) {\n\t\t/* delete old event */\n\t\tret = unregister_trace_uprobe(old_tu);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tlist_add_tail(&tu->list, &uprobe_list);\n\nend:\n\tmutex_unlock(&uprobe_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Parse error at argument[%d]. (%d)\\n\"",
            "i",
            "ret"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_probe_arg",
          "args": [
            "arg",
            "&tu->tp.size",
            "parg",
            "is_return ? TPARG_FL_RETURN : 0"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "351-491",
          "snippet": "int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2;\n\tint ret, len;\n\n\tif (strlen(arg) > MAX_ARGSTR_LEN) {\n\t\tpr_info(\"Argument is too long.: %s\\n\",  arg);\n\t\treturn -ENOSPC;\n\t}\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm) {\n\t\tpr_info(\"Failed to allocate memory for command '%s'.\\n\", arg);\n\t\treturn -ENOMEM;\n\t}\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2 = '\\0';\n\t\t\tparg->count = simple_strtoul(t2 + 1, &t2, 0);\n\t\t\tif (strcmp(t2, \"]\") || parg->count == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (parg->count > MAX_ARRAY_LEN)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\t/*\n\t * The default type of $comm should be \"string\", and it can't be\n\t * dereferenced.\n\t */\n\tif (!t && strcmp(arg, \"$comm\") == 0)\n\t\tparg->type = find_fetch_type(\"string\");\n\telse\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\tpr_info(\"Unsupported type: %s\\n\", t);\n\t\treturn -EINVAL;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kzalloc(sizeof(*code) * FETCH_INSN_MAX, GFP_KERNEL);\n\tif (!code)\n\t\treturn -ENOMEM;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_IMM &&\n\t\t    code->op != FETCH_OP_COMM) {\n\t\t\tpr_info(\"string only accepts memory or address.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (code->op != FETCH_OP_DEREF || parg->count) {\n\t\t\t/*\n\t\t\t * IMM and COMM is pointing actual address, those must\n\t\t\t * be kept, and if parg->count != 0, this is an array\n\t\t\t * of string pointers instead of string address itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tcode->op = FETCH_OP_ST_STRING;\t/* In DEREF case, replace it */\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING) {\n\t\t\tpr_info(\"array only accepts memory or address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\t/* Shrink down the code buffer */\n\tparg->code = kzalloc(sizeof(*code) * (code - tmp + 1), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nint traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2;\n\tint ret, len;\n\n\tif (strlen(arg) > MAX_ARGSTR_LEN) {\n\t\tpr_info(\"Argument is too long.: %s\\n\",  arg);\n\t\treturn -ENOSPC;\n\t}\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm) {\n\t\tpr_info(\"Failed to allocate memory for command '%s'.\\n\", arg);\n\t\treturn -ENOMEM;\n\t}\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2 = '\\0';\n\t\t\tparg->count = simple_strtoul(t2 + 1, &t2, 0);\n\t\t\tif (strcmp(t2, \"]\") || parg->count == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (parg->count > MAX_ARRAY_LEN)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\t/*\n\t * The default type of $comm should be \"string\", and it can't be\n\t * dereferenced.\n\t */\n\tif (!t && strcmp(arg, \"$comm\") == 0)\n\t\tparg->type = find_fetch_type(\"string\");\n\telse\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\tpr_info(\"Unsupported type: %s\\n\", t);\n\t\treturn -EINVAL;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kzalloc(sizeof(*code) * FETCH_INSN_MAX, GFP_KERNEL);\n\tif (!code)\n\t\treturn -ENOMEM;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_IMM &&\n\t\t    code->op != FETCH_OP_COMM) {\n\t\t\tpr_info(\"string only accepts memory or address.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (code->op != FETCH_OP_DEREF || parg->count) {\n\t\t\t/*\n\t\t\t * IMM and COMM is pointing actual address, those must\n\t\t\t * be kept, and if parg->count != 0, this is an array\n\t\t\t * of string pointers instead of string address itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tcode->op = FETCH_OP_ST_STRING;\t/* In DEREF case, replace it */\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING) {\n\t\t\tpr_info(\"array only accepts memory or address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\t/* Shrink down the code buffer */\n\tparg->code = kzalloc(sizeof(*code) * (code - tmp + 1), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Argument[%d] name '%s' conflicts with \"\n\t\t\t\t\"another field.\\n\"",
            "i",
            "argv[i]"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_conflict_field_name",
          "args": [
            "parg->name",
            "tu->tp.args",
            "i"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_conflict_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "494-508",
          "snippet": "int traceprobe_conflict_field_name(const char *name,\n\t\t\t       struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};\n\nint traceprobe_conflict_field_name(const char *name,\n\t\t\t       struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Invalid argument[%d] name: %s\\n\"",
            "i",
            "parg->name"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "parg->name"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "247-256",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate argument[%d] name.\\n\"",
            "i"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"arg%d\"",
            "i + 1"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "argv[i]",
            "GFP_KERNEL"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[i]",
            "'='"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate filename.\\n\""
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filename",
            "GFP_KERNEL"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tu"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate trace_uprobe.(%d)\\n\"",
            "(int)PTR_ERR(tu)"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tu"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tu"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_uprobe",
          "args": [
            "group",
            "event",
            "argc",
            "is_return"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "215-252",
          "snippet": "static struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\n\tif (!event || !is_good_name(event))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!group || !is_good_name(group))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttu->tp.call.class = &tu->tp.class;\n\ttu->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tu->tp.call.name)\n\t\tgoto error;\n\n\ttu->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tu->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tu->list);\n\tINIT_LIST_HEAD(&tu->tp.files);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(&tu->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu->tp.call.name);\n\tkfree(tu);\n\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\n\tif (!event || !is_good_name(event))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!group || !is_good_name(group))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttu->tp.call.class = &tu->tp.class;\n\ttu->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tu->tp.call.name)\n\t\tgoto error;\n\n\ttu->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tu->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tu->list);\n\tINIT_LIST_HEAD(&tu->tp.files);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(&tu->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu->tp.call.name);\n\tkfree(tu);\n\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tail"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"%c_%s_0x%lx\"",
            "'p'",
            "tail",
            "offset"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "tail",
            "\".-_\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "kbasename(filename)",
            "GFP_KERNEL"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "filename"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg",
            "0",
            "&offset"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Invalid reference counter offset.\\n\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "rctr",
            "0",
            "&ref_ctr_offset"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Invalid reference counter offset.\\n\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "rctr",
            "')'"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'('"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "path.dentry"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "filename",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[1]",
            "':'"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Probe point is not specified.\\n\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "281-292",
          "snippet": "static int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Event %s/%s doesn't exist.\\n\"",
            "group",
            "event"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_probe_event",
          "args": [
            "event",
            "group"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "find_probe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "268-278",
          "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static LIST_HEAD(uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic LIST_HEAD(uprobe_list);\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Delete command needs an event name.\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Event name is not specified\\n\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "event"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Group name is not specified\\n\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "event",
            "'/'"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Probe definition must be started with 'p', 'r' or '-'.\\n\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic DEFINE_MUTEX(uprobe_lock);\n\nstatic int create_trace_uprobe(int argc, char **argv)\n{\n\tstruct trace_uprobe *tu;\n\tchar *arg, *event, *group, *filename, *rctr, *rctr_end;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tstruct path path;\n\tunsigned long offset, ref_ctr_offset;\n\tbool is_delete, is_return;\n\tint i, ret;\n\n\tret = 0;\n\tis_delete = false;\n\tis_return = false;\n\tevent = NULL;\n\tgroup = NULL;\n\tref_ctr_offset = 0;\n\n\t/* argc must be >= 1 */\n\tif (argv[0][0] == '-')\n\t\tis_delete = true;\n\telse if (argv[0][0] == 'r')\n\t\tis_return = true;\n\telse if (argv[0][0] != 'p') {\n\t\tpr_info(\"Probe definition must be started with 'p', 'r' or '-'.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (argv[0][1] == ':') {\n\t\tevent = &argv[0][2];\n\t\targ = strchr(event, '/');\n\n\t\tif (arg) {\n\t\t\tgroup = event;\n\t\t\tevent = arg + 1;\n\t\t\tevent[-1] = '\\0';\n\n\t\t\tif (strlen(group) == 0) {\n\t\t\t\tpr_info(\"Group name is not specified\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (strlen(event) == 0) {\n\t\t\tpr_info(\"Event name is not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!group)\n\t\tgroup = UPROBE_EVENT_SYSTEM;\n\n\tif (is_delete) {\n\t\tint ret;\n\n\t\tif (!event) {\n\t\t\tpr_info(\"Delete command needs an event name.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&uprobe_lock);\n\t\ttu = find_probe_event(event, group);\n\n\t\tif (!tu) {\n\t\t\tmutex_unlock(&uprobe_lock);\n\t\t\tpr_info(\"Event %s/%s doesn't exist.\\n\", group, event);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t/* delete an event */\n\t\tret = unregister_trace_uprobe(tu);\n\t\tmutex_unlock(&uprobe_lock);\n\t\treturn ret;\n\t}\n\n\tif (argc < 2) {\n\t\tpr_info(\"Probe point is not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* Find the last occurrence, in case the path contains ':' too. */\n\targ = strrchr(argv[1], ':');\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\t*arg++ = '\\0';\n\tfilename = argv[1];\n\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_address_parse;\n\t}\n\n\t/* Parse reference counter offset if specified. */\n\trctr = strchr(arg, '(');\n\tif (rctr) {\n\t\trctr_end = strchr(rctr, ')');\n\t\tif (rctr > rctr_end || *(rctr_end + 1) != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tpr_info(\"Invalid reference counter offset.\\n\");\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\t*rctr++ = '\\0';\n\t\t*rctr_end = '\\0';\n\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);\n\t\tif (ret) {\n\t\t\tpr_info(\"Invalid reference counter offset.\\n\");\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t/* Parse uprobe offset. */\n\tret = kstrtoul(arg, 0, &offset);\n\tif (ret)\n\t\tgoto fail_address_parse;\n\n\targc -= 2;\n\targv += 2;\n\n\t/* setup a probe */\n\tif (!event) {\n\t\tchar *tail;\n\t\tchar *ptr;\n\n\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);\n\t\tif (!tail) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\tptr = strpbrk(tail, \".-_\");\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);\n\t\tevent = buf;\n\t\tkfree(tail);\n\t}\n\n\ttu = alloc_trace_uprobe(group, event, argc, is_return);\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\", (int)PTR_ERR(tu));\n\t\tret = PTR_ERR(tu);\n\t\tgoto fail_address_parse;\n\t}\n\ttu->offset = offset;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->path = path;\n\ttu->filename = kstrdup(filename, GFP_KERNEL);\n\n\tif (!tu->filename) {\n\t\tpr_info(\"Failed to allocate filename.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t/* parse arguments */\n\tret = 0;\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\tstruct probe_arg *parg = &tu->tp.args[i];\n\n\t\t/* Increment count for freeing args in error case */\n\t\ttu->tp.nr_args++;\n\n\t\t/* Parse argument name */\n\t\targ = strchr(argv[i], '=');\n\t\tif (arg) {\n\t\t\t*arg++ = '\\0';\n\t\t\tparg->name = kstrdup(argv[i], GFP_KERNEL);\n\t\t} else {\n\t\t\targ = argv[i];\n\t\t\t/* If argument name is omitted, set \"argN\" */\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"arg%d\", i + 1);\n\t\t\tparg->name = kstrdup(buf, GFP_KERNEL);\n\t\t}\n\n\t\tif (!parg->name) {\n\t\t\tpr_info(\"Failed to allocate argument[%d] name.\\n\", i);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!is_good_name(parg->name)) {\n\t\t\tpr_info(\"Invalid argument[%d] name: %s\\n\", i, parg->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (traceprobe_conflict_field_name(parg->name, tu->tp.args, i)) {\n\t\t\tpr_info(\"Argument[%d] name '%s' conflicts with \"\n\t\t\t\t\"another field.\\n\", i, argv[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Parse fetch argument */\n\t\tret = traceprobe_parse_probe_arg(arg, &tu->tp.size, parg,\n\t\t\t\t\tis_return ? TPARG_FL_RETURN : 0);\n\t\tif (ret) {\n\t\t\tpr_info(\"Parse error at argument[%d]. (%d)\\n\", i, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = register_trace_uprobe(tu);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ret;\n\nfail_address_parse:\n\tpath_put(&path);\n\n\tpr_info(\"Failed to parse address or file.\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "324-357",
    "snippet": "static int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&uprobe_lock);\n\n\t/* register as an event */\n\told_tu = find_old_trace_uprobe(tu);\n\tif (IS_ERR(old_tu)) {\n\t\tret = PTR_ERR(old_tu);\n\t\tgoto end;\n\t}\n\n\tif (old_tu) {\n\t\t/* delete old event */\n\t\tret = unregister_trace_uprobe(old_tu);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tlist_add_tail(&tu->list, &uprobe_list);\n\nend:\n\tmutex_unlock(&uprobe_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static DEFINE_MUTEX(uprobe_lock);",
      "static LIST_HEAD(uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tu->list",
            "&uprobe_list"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register probe event(%d)\\n\"",
            "ret"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_uprobe_event",
          "args": [
            "tu"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_uprobe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1355-1366",
          "snippet": "static int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\t/* tu->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tu->tp.call);\n\tif (ret)\n\t\treturn ret;\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\t/* tu->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tu->tp.call);\n\tif (ret)\n\t\treturn ret;\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_uprobe",
          "args": [
            "old_tu"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "281-292",
          "snippet": "static int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old_tu"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old_tu"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_old_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "find_old_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "303-321",
          "snippet": "static struct trace_uprobe *find_old_trace_uprobe(struct trace_uprobe *new)\n{\n\tstruct trace_uprobe *tmp, *old = NULL;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\told = find_probe_event(trace_event_name(&new->tp.call),\n\t\t\t\tnew->tp.call.class->system);\n\n\tlist_for_each_entry(tmp, &uprobe_list, list) {\n\t\tif ((old ? old != tmp : true) &&\n\t\t    new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(uprobe_list);\n\nstatic struct trace_uprobe *find_old_trace_uprobe(struct trace_uprobe *new)\n{\n\tstruct trace_uprobe *tmp, *old = NULL;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\told = find_probe_event(trace_event_name(&new->tp.call),\n\t\t\t\tnew->tp.call.class->system);\n\n\tlist_for_each_entry(tmp, &uprobe_list, list) {\n\t\tif ((old ? old != tmp : true) &&\n\t\t    new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uprobe_lock"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic DEFINE_MUTEX(uprobe_lock);\nstatic LIST_HEAD(uprobe_list);\n\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&uprobe_lock);\n\n\t/* register as an event */\n\told_tu = find_old_trace_uprobe(tu);\n\tif (IS_ERR(old_tu)) {\n\t\tret = PTR_ERR(old_tu);\n\t\tgoto end;\n\t}\n\n\tif (old_tu) {\n\t\t/* delete old event */\n\t\tret = unregister_trace_uprobe(old_tu);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tlist_add_tail(&tu->list, &uprobe_list);\n\nend:\n\tmutex_unlock(&uprobe_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_old_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "303-321",
    "snippet": "static struct trace_uprobe *find_old_trace_uprobe(struct trace_uprobe *new)\n{\n\tstruct trace_uprobe *tmp, *old = NULL;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\told = find_probe_event(trace_event_name(&new->tp.call),\n\t\t\t\tnew->tp.call.class->system);\n\n\tlist_for_each_entry(tmp, &uprobe_list, list) {\n\t\tif ((old ? old != tmp : true) &&\n\t\t    new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\treturn old;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Reference counter offset mismatch.\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "tmp->path.dentry"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&uprobe_list",
            "list"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_probe_event",
          "args": [
            "trace_event_name(&new->tp.call)",
            "new->tp.call.class->system"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "find_probe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "268-278",
          "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);",
            "static LIST_HEAD(uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic LIST_HEAD(uprobe_list);\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&new->tp.call"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_real_inode",
          "args": [
            "new->path.dentry"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(uprobe_list);\n\nstatic struct trace_uprobe *find_old_trace_uprobe(struct trace_uprobe *new)\n{\n\tstruct trace_uprobe *tmp, *old = NULL;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\told = find_probe_event(trace_event_name(&new->tp.call),\n\t\t\t\tnew->tp.call.class->system);\n\n\tlist_for_each_entry(tmp, &uprobe_list, list) {\n\t\tif ((old ? old != tmp : true) &&\n\t\t    new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\treturn old;\n}"
  },
  {
    "function_name": "unregister_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "281-292",
    "snippet": "static int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_uprobe",
          "args": [
            "tu"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "254-266",
          "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tu->list"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_uprobe_event",
          "args": [
            "tu"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_uprobe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1355-1366",
          "snippet": "static int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\t/* tu->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tu->tp.call);\n\tif (ret)\n\t\treturn ret;\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\t/* tu->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tu->tp.call);\n\tif (ret)\n\t\treturn ret;\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del(&tu->list);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_probe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "268-278",
    "snippet": "static struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);",
      "static LIST_HEAD(uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tu->tp.call.class->system",
            "group"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trace_event_name(&tu->tp.call)",
            "event"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tu->tp.call"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tu",
            "&uprobe_list",
            "list"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\nstatic LIST_HEAD(uprobe_list);\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct trace_uprobe *tu;\n\n\tlist_for_each_entry(tu, &uprobe_list, list)\n\t\tif (strcmp(trace_event_name(&tu->tp.call), event) == 0 &&\n\t\t    strcmp(tu->tp.call.class->system, group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "254-266",
    "snippet": "static void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tu"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&tu->path"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_free_probe_arg",
          "args": [
            "&tu->tp.args[i]"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_free_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "510-523",
          "snippet": "void traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint i;\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tu->tp.args[i]);\n\n\tpath_put(&tu->path);\n\tkfree(tu->tp.call.class->system);\n\tkfree(tu->tp.call.name);\n\tkfree(tu->filename);\n\tkfree(tu);\n}"
  },
  {
    "function_name": "alloc_trace_uprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "215-252",
    "snippet": "static struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\n\tif (!event || !is_good_name(event))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!group || !is_good_name(group))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttu->tp.call.class = &tu->tp.class;\n\ttu->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tu->tp.call.name)\n\t\tgoto error;\n\n\ttu->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tu->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tu->list);\n\tINIT_LIST_HEAD(&tu->tp.files);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(&tu->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu->tp.call.name);\n\tkfree(tu);\n\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tu"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_uprobe_filter",
          "args": [
            "&tu->filter"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_uprobe_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "193-200",
          "snippet": "NOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tu->tp.files"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tu->list"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "group",
            "GFP_KERNEL"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event",
            "GFP_KERNEL"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SIZEOF_TRACE_UPROBE(nargs)",
            "GFP_KERNEL"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_UPROBE",
          "args": [
            "nargs"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "group"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "247-256",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\n\tif (!event || !is_good_name(event))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!group || !is_good_name(group))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttu->tp.call.class = &tu->tp.class;\n\ttu->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tu->tp.call.name)\n\t\tgoto error;\n\n\ttu->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tu->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tu->list);\n\tINIT_LIST_HEAD(&tu->tp.files);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(&tu->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu->tp.call.name);\n\tkfree(tu);\n\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "is_ret_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "207-210",
    "snippet": "static inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}"
  },
  {
    "function_name": "uprobe_filter_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "202-205",
    "snippet": "static inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&filter->perf_events"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}"
  },
  {
    "function_name": "init_trace_uprobe_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "193-200",
    "snippet": "NOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&filter->perf_events"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&filter->rwlock"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}"
  },
  {
    "function_name": "process_fetch_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "160-192",
    "snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = get_user_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = user_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_FOFFS:\n\t\tval = translate_user_vaddr(code->immediate);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn_bottom",
          "args": [
            "code",
            "val",
            "dest",
            "base"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "66-144",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\twhile (code->op == FETCH_OP_DEREF) {\n\t\tlval = val;\n\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\tsizeof(val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t}\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret += fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\twhile (code->op == FETCH_OP_DEREF) {\n\t\tlval = val;\n\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\tsizeof(val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t}\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret += fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "translate_user_vaddr",
          "args": [
            "code->immediate"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "translate_user_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "148-157",
          "snippet": "static unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regs_return_value",
          "args": [
            "regs"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_stack_nth",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_stack_nth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "87-98",
          "snippet": "static unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
            "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\n\nstatic unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regs_get_register",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\n\nstatic int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = get_user_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = user_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_FOFFS:\n\t\tval = translate_user_vaddr(code->immediate);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}"
  },
  {
    "function_name": "translate_user_vaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "148-157",
    "snippet": "static unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_uprobe_event(struct trace_uprobe *tu);",
      "static int unregister_uprobe_event(struct trace_uprobe *tu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}"
  },
  {
    "function_name": "fetch_store_strlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "137-146",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "vaddr",
            "MAX_STRING_SIZE"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
  },
  {
    "function_name": "fetch_store_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "114-134",
    "snippet": "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tlong ret;\n\tu32 loc = *(u32 *)dest;\n\tint maxlen  = get_loc_len(loc);\n\tu8 *dst = get_loc_data(dest, base);\n\tvoid __user *src = (void __force __user *) addr;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\tret = strncpy_from_user(dst, src, maxlen);\n\tif (ret >= 0) {\n\t\tif (ret == maxlen)\n\t\t\tdst[ret - 1] = '\\0';\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "(void *)dst - base"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "dst",
            "src",
            "maxlen"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "loc"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tlong ret;\n\tu32 loc = *(u32 *)dest;\n\tint maxlen  = get_loc_len(loc);\n\tu8 *dst = get_loc_data(dest, base);\n\tvoid __user *src = (void __force __user *) addr;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\tret = strncpy_from_user(dst, src, maxlen);\n\tif (ret >= 0) {\n\t\tif (ret == maxlen)\n\t\t\tdst[ret - 1] = '\\0';\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "probe_mem_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "103-109",
    "snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\tvoid __user *vaddr = (void __force __user *)src;\n\n\treturn copy_from_user(dest, vaddr, size) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "dest",
            "vaddr",
            "size"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\tvoid __user *vaddr = (void __force __user *)src;\n\n\treturn copy_from_user(dest, vaddr, size) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "get_user_stack_nth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "87-98",
    "snippet": "static unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);",
      "static int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ret",
            "(void __force __user *) addr",
            "sizeof(ret)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_stack_addr",
          "args": [
            "addr",
            "n"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_stack_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "81-84",
          "snippet": "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\n\nstatic unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "adjust_stack_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "81-84",
    "snippet": "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}"
  },
  {
    "function_name": "adjust_stack_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
    "lines": "76-79",
    "snippet": "static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr - (n * sizeof(long));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/string.h>",
      "#include <linux/namei.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr - (n * sizeof(long));\n}"
  }
]