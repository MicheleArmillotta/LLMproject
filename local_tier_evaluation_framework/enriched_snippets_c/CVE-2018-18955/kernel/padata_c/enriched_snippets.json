[
  {
    "function_name": "padata_driver_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "1107-1110",
    "snippet": "static __exit void padata_driver_exit(void)\n{\n\tcpuhp_remove_multi_state(hp_online);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_remove_multi_state",
          "args": [
            "hp_online"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic __exit void padata_driver_exit(void)\n{\n\tcpuhp_remove_multi_state(hp_online);\n}"
  },
  {
    "function_name": "padata_driver_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "1093-1104",
    "snippet": "static __init int padata_driver_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"padata:online\",\n\t\t\t\t      padata_cpu_online,\n\t\t\t\t      padata_cpu_prep_down);\n\tif (ret < 0)\n\t\treturn ret;\n\thp_online = ret;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_setup_state_multi",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"padata:online\"",
            "padata_cpu_online",
            "padata_cpu_prep_down"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic __init int padata_driver_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"padata:online\",\n\t\t\t\t      padata_cpu_online,\n\t\t\t\t      padata_cpu_prep_down);\n\tif (ret < 0)\n\t\treturn ret;\n\thp_online = ret;\n\treturn 0;\n}"
  },
  {
    "function_name": "padata_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "1085-1088",
    "snippet": "void padata_free(struct padata_instance *pinst)\n{\n\tkobject_put(&pinst->kobj);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&pinst->kobj"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nvoid padata_free(struct padata_instance *pinst)\n{\n\tkobject_put(&pinst->kobj);\n}"
  },
  {
    "function_name": "padata_alloc_possible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "1073-1077",
    "snippet": "struct padata_instance *padata_alloc_possible(struct workqueue_struct *wq)\n{\n\tlockdep_assert_cpus_held();\n\treturn padata_alloc(wq, cpu_possible_mask, cpu_possible_mask);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_alloc",
          "args": [
            "wq",
            "cpu_possible_mask",
            "cpu_possible_mask"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "1012-1062",
          "snippet": "static struct padata_instance *padata_alloc(struct workqueue_struct *wq,\n\t\t\t\t\t    const struct cpumask *pcpumask,\n\t\t\t\t\t    const struct cpumask *cbcpumask)\n{\n\tstruct padata_instance *pinst;\n\tstruct parallel_data *pd = NULL;\n\n\tpinst = kzalloc(sizeof(struct padata_instance), GFP_KERNEL);\n\tif (!pinst)\n\t\tgoto err;\n\n\tif (!alloc_cpumask_var(&pinst->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_inst;\n\tif (!alloc_cpumask_var(&pinst->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pinst->cpumask.pcpu);\n\t\tgoto err_free_inst;\n\t}\n\tif (!padata_validate_cpumask(pinst, pcpumask) ||\n\t    !padata_validate_cpumask(pinst, cbcpumask))\n\t\tgoto err_free_masks;\n\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\tgoto err_free_masks;\n\n\trcu_assign_pointer(pinst->pd, pd);\n\n\tpinst->wq = wq;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpinst->flags = 0;\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&pinst->cpumask_change_notifier);\n\tkobject_init(&pinst->kobj, &padata_attr_type);\n\tmutex_init(&pinst->lock);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_add_instance_nocalls_cpuslocked(hp_online, &pinst->node);\n#endif\n\treturn pinst;\n\nerr_free_masks:\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\nerr_free_inst:\n\tkfree(pinst);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobj_type padata_attr_type = {\n\t.sysfs_ops = &padata_sysfs_ops,\n\t.default_attrs = padata_default_attrs,\n\t.release = padata_sysfs_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct kobj_type padata_attr_type = {\n\t.sysfs_ops = &padata_sysfs_ops,\n\t.default_attrs = padata_default_attrs,\n\t.release = padata_sysfs_release,\n};\n\nstatic struct padata_instance *padata_alloc(struct workqueue_struct *wq,\n\t\t\t\t\t    const struct cpumask *pcpumask,\n\t\t\t\t\t    const struct cpumask *cbcpumask)\n{\n\tstruct padata_instance *pinst;\n\tstruct parallel_data *pd = NULL;\n\n\tpinst = kzalloc(sizeof(struct padata_instance), GFP_KERNEL);\n\tif (!pinst)\n\t\tgoto err;\n\n\tif (!alloc_cpumask_var(&pinst->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_inst;\n\tif (!alloc_cpumask_var(&pinst->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pinst->cpumask.pcpu);\n\t\tgoto err_free_inst;\n\t}\n\tif (!padata_validate_cpumask(pinst, pcpumask) ||\n\t    !padata_validate_cpumask(pinst, cbcpumask))\n\t\tgoto err_free_masks;\n\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\tgoto err_free_masks;\n\n\trcu_assign_pointer(pinst->pd, pd);\n\n\tpinst->wq = wq;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpinst->flags = 0;\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&pinst->cpumask_change_notifier);\n\tkobject_init(&pinst->kobj, &padata_attr_type);\n\tmutex_init(&pinst->lock);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_add_instance_nocalls_cpuslocked(hp_online, &pinst->node);\n#endif\n\treturn pinst;\n\nerr_free_masks:\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\nerr_free_inst:\n\tkfree(pinst);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstruct padata_instance *padata_alloc_possible(struct workqueue_struct *wq)\n{\n\tlockdep_assert_cpus_held();\n\treturn padata_alloc(wq, cpu_possible_mask, cpu_possible_mask);\n}"
  },
  {
    "function_name": "padata_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "1012-1062",
    "snippet": "static struct padata_instance *padata_alloc(struct workqueue_struct *wq,\n\t\t\t\t\t    const struct cpumask *pcpumask,\n\t\t\t\t\t    const struct cpumask *cbcpumask)\n{\n\tstruct padata_instance *pinst;\n\tstruct parallel_data *pd = NULL;\n\n\tpinst = kzalloc(sizeof(struct padata_instance), GFP_KERNEL);\n\tif (!pinst)\n\t\tgoto err;\n\n\tif (!alloc_cpumask_var(&pinst->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_inst;\n\tif (!alloc_cpumask_var(&pinst->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pinst->cpumask.pcpu);\n\t\tgoto err_free_inst;\n\t}\n\tif (!padata_validate_cpumask(pinst, pcpumask) ||\n\t    !padata_validate_cpumask(pinst, cbcpumask))\n\t\tgoto err_free_masks;\n\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\tgoto err_free_masks;\n\n\trcu_assign_pointer(pinst->pd, pd);\n\n\tpinst->wq = wq;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpinst->flags = 0;\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&pinst->cpumask_change_notifier);\n\tkobject_init(&pinst->kobj, &padata_attr_type);\n\tmutex_init(&pinst->lock);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_add_instance_nocalls_cpuslocked(hp_online, &pinst->node);\n#endif\n\treturn pinst;\n\nerr_free_masks:\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\nerr_free_inst:\n\tkfree(pinst);\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobj_type padata_attr_type = {\n\t.sysfs_ops = &padata_sysfs_ops,\n\t.default_attrs = padata_default_attrs,\n\t.release = padata_sysfs_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pinst"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.cbcpu"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.pcpu"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_state_add_instance_nocalls_cpuslocked",
          "args": [
            "hp_online",
            "&pinst->node"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&pinst->lock"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_init",
          "args": [
            "&pinst->kobj",
            "&padata_attr_type"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCKING_INIT_NOTIFIER_HEAD",
          "args": [
            "&pinst->cpumask_change_notifier"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.cbcpu",
            "cbcpumask"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.pcpu",
            "pcpumask"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "pinst->pd",
            "pd"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_alloc_pd",
          "args": [
            "pinst",
            "pcpumask",
            "cbcpumask"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "467-506",
          "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "cbcpumask"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "623-633",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.pcpu"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pinst->cpumask.cbcpu",
            "GFP_KERNEL"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pinst->cpumask.pcpu",
            "GFP_KERNEL"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct padata_instance)",
            "GFP_KERNEL"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct kobj_type padata_attr_type = {\n\t.sysfs_ops = &padata_sysfs_ops,\n\t.default_attrs = padata_default_attrs,\n\t.release = padata_sysfs_release,\n};\n\nstatic struct padata_instance *padata_alloc(struct workqueue_struct *wq,\n\t\t\t\t\t    const struct cpumask *pcpumask,\n\t\t\t\t\t    const struct cpumask *cbcpumask)\n{\n\tstruct padata_instance *pinst;\n\tstruct parallel_data *pd = NULL;\n\n\tpinst = kzalloc(sizeof(struct padata_instance), GFP_KERNEL);\n\tif (!pinst)\n\t\tgoto err;\n\n\tif (!alloc_cpumask_var(&pinst->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_inst;\n\tif (!alloc_cpumask_var(&pinst->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pinst->cpumask.pcpu);\n\t\tgoto err_free_inst;\n\t}\n\tif (!padata_validate_cpumask(pinst, pcpumask) ||\n\t    !padata_validate_cpumask(pinst, cbcpumask))\n\t\tgoto err_free_masks;\n\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\tgoto err_free_masks;\n\n\trcu_assign_pointer(pinst->pd, pd);\n\n\tpinst->wq = wq;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpinst->flags = 0;\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&pinst->cpumask_change_notifier);\n\tkobject_init(&pinst->kobj, &padata_attr_type);\n\tmutex_init(&pinst->lock);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_add_instance_nocalls_cpuslocked(hp_online, &pinst->node);\n#endif\n\treturn pinst;\n\nerr_free_masks:\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\nerr_free_inst:\n\tkfree(pinst);\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "padata_sysfs_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "976-989",
    "snippet": "static ssize_t padata_sysfs_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->store(pinst, attr, buf, count);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pentry->store",
          "args": [
            "pinst",
            "attr",
            "buf",
            "count"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr2pentry",
          "args": [
            "attr"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj2pinst",
          "args": [
            "kobj"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic ssize_t padata_sysfs_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->store(pinst, attr, buf, count);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "padata_sysfs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "961-974",
    "snippet": "static ssize_t padata_sysfs_show(struct kobject *kobj,\n\t\t\t\t struct attribute *attr, char *buf)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->show(pinst, attr, buf);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pentry->show",
          "args": [
            "pinst",
            "attr",
            "buf"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr2pentry",
          "args": [
            "attr"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj2pinst",
          "args": [
            "kobj"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic ssize_t padata_sysfs_show(struct kobject *kobj,\n\t\t\t\t struct attribute *attr, char *buf)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->show(pinst, attr, buf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "store_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "913-938",
    "snippet": "static ssize_t store_cpumask(struct padata_instance *pinst,\n\t\t\t     struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tcpumask_var_t new_cpumask;\n\tssize_t ret;\n\tint mask_type;\n\n\tif (!alloc_cpumask_var(&new_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmask_type = !strcmp(attr->name, \"serial_cpumask\") ?\n\t\tPADATA_CPU_SERIAL : PADATA_CPU_PARALLEL;\n\tret = padata_set_cpumask(pinst, mask_type, new_cpumask);\n\tif (!ret)\n\t\tret = count;\n\nout:\n\tfree_cpumask_var(new_cpumask);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_cpumask"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_set_cpumask",
          "args": [
            "pinst",
            "mask_type",
            "new_cpumask"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "padata_set_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "677-706",
          "snippet": "int padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tmutex_lock(&pinst->lock);\n\tget_online_cpus();\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tput_online_cpus();\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nint padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tmutex_lock(&pinst->lock);\n\tget_online_cpus();\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tput_online_cpus();\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attr->name",
            "\"serial_cpumask\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_parse",
          "args": [
            "buf",
            "count",
            "cpumask_bits(new_cpumask)",
            "nr_cpumask_bits"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "new_cpumask"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_cpumask",
            "GFP_KERNEL"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic ssize_t store_cpumask(struct padata_instance *pinst,\n\t\t\t     struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tcpumask_var_t new_cpumask;\n\tssize_t ret;\n\tint mask_type;\n\n\tif (!alloc_cpumask_var(&new_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmask_type = !strcmp(attr->name, \"serial_cpumask\") ?\n\t\tPADATA_CPU_SERIAL : PADATA_CPU_PARALLEL;\n\tret = padata_set_cpumask(pinst, mask_type, new_cpumask);\n\tif (!ret)\n\t\tret = count;\n\nout:\n\tfree_cpumask_var(new_cpumask);\n\treturn ret;\n}"
  },
  {
    "function_name": "show_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "895-911",
    "snippet": "static ssize_t show_cpumask(struct padata_instance *pinst,\n\t\t\t    struct attribute *attr,  char *buf)\n{\n\tstruct cpumask *cpumask;\n\tssize_t len;\n\n\tmutex_lock(&pinst->lock);\n\tif (!strcmp(attr->name, \"serial_cpumask\"))\n\t\tcpumask = pinst->cpumask.cbcpu;\n\telse\n\t\tcpumask = pinst->cpumask.pcpu;\n\n\tlen = snprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t       nr_cpu_ids, cpumask_bits(cpumask));\n\tmutex_unlock(&pinst->lock);\n\treturn len < PAGE_SIZE ? len : -EINVAL;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%*pb\\n\"",
            "nr_cpu_ids",
            "cpumask_bits(cpumask)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "cpumask"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attr->name",
            "\"serial_cpumask\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic ssize_t show_cpumask(struct padata_instance *pinst,\n\t\t\t    struct attribute *attr,  char *buf)\n{\n\tstruct cpumask *cpumask;\n\tssize_t len;\n\n\tmutex_lock(&pinst->lock);\n\tif (!strcmp(attr->name, \"serial_cpumask\"))\n\t\tcpumask = pinst->cpumask.cbcpu;\n\telse\n\t\tcpumask = pinst->cpumask.pcpu;\n\n\tlen = snprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t       nr_cpu_ids, cpumask_bits(cpumask));\n\tmutex_unlock(&pinst->lock);\n\treturn len < PAGE_SIZE ? len : -EINVAL;\n}"
  },
  {
    "function_name": "padata_sysfs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "882-886",
    "snippet": "static void padata_sysfs_release(struct kobject *kobj)\n{\n\tstruct padata_instance *pinst = kobj2pinst(kobj);\n\t__padata_free(pinst);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_free",
          "args": [
            "pinst"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "864-875",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobj2pinst",
          "args": [
            "kobj"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_sysfs_release(struct kobject *kobj)\n{\n\tstruct padata_instance *pinst = kobj2pinst(kobj);\n\t__padata_free(pinst);\n}"
  },
  {
    "function_name": "__padata_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "864-875",
    "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pinst"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.cbcpu"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.pcpu"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_free_pd",
          "args": [
            "pinst->pd"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "padata_free_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "508-515",
          "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->pqueue);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->pqueue);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_stop",
          "args": [
            "pinst"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "padata_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "736-741",
          "snippet": "void padata_stop(struct padata_instance *pinst)\n{\n\tmutex_lock(&pinst->lock);\n\t__padata_stop(pinst);\n\tmutex_unlock(&pinst->lock);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nvoid padata_stop(struct padata_instance *pinst)\n{\n\tmutex_lock(&pinst->lock);\n\t__padata_stop(pinst);\n\tmutex_unlock(&pinst->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_state_remove_instance_nocalls",
          "args": [
            "hp_online",
            "&pinst->node"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->node);\n#endif\n\n\tpadata_stop(pinst);\n\tpadata_free_pd(pinst->pd);\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tkfree(pinst);\n}"
  },
  {
    "function_name": "padata_cpu_prep_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "846-859",
    "snippet": "static int padata_cpu_prep_down(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_remove_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_remove_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_remove_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "766-788",
          "snippet": "static int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd = NULL;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.cbcpu);\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.pcpu);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd = NULL;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.cbcpu);\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.pcpu);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pinst_has_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "pinst_has_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "825-829",
          "snippet": "static inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "node",
            "structpadata_instance",
            "node"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_cpu_prep_down(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_remove_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "padata_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "831-844",
    "snippet": "static int padata_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_add_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_add_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_add_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "746-764",
          "snippet": "static int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pinst_has_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "pinst_has_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "825-829",
          "snippet": "static inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "node",
            "structpadata_instance",
            "node"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_add_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pinst_has_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "825-829",
    "snippet": "static inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pinst->cpumask.cbcpu"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pinst->cpumask.pcpu"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}"
  },
  {
    "function_name": "padata_remove_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "801-822",
    "snippet": "int padata_remove_cpu(struct padata_instance *pinst, int cpu, int mask)\n{\n\tint err;\n\n\tif (!(mask & (PADATA_CPU_SERIAL | PADATA_CPU_PARALLEL)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pinst->lock);\n\n\tget_online_cpus();\n\tif (mask & PADATA_CPU_SERIAL)\n\t\tcpumask_clear_cpu(cpu, pinst->cpumask.cbcpu);\n\tif (mask & PADATA_CPU_PARALLEL)\n\t\tcpumask_clear_cpu(cpu, pinst->cpumask.pcpu);\n\n\terr = __padata_remove_cpu(pinst, cpu);\n\tput_online_cpus();\n\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_remove_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_remove_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "766-788",
          "snippet": "static int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd = NULL;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.cbcpu);\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.pcpu);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd = NULL;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.cbcpu);\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.pcpu);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "pinst->cpumask.pcpu"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "pinst->cpumask.cbcpu"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nint padata_remove_cpu(struct padata_instance *pinst, int cpu, int mask)\n{\n\tint err;\n\n\tif (!(mask & (PADATA_CPU_SERIAL | PADATA_CPU_PARALLEL)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pinst->lock);\n\n\tget_online_cpus();\n\tif (mask & PADATA_CPU_SERIAL)\n\t\tcpumask_clear_cpu(cpu, pinst->cpumask.cbcpu);\n\tif (mask & PADATA_CPU_PARALLEL)\n\t\tcpumask_clear_cpu(cpu, pinst->cpumask.pcpu);\n\n\terr = __padata_remove_cpu(pinst, cpu);\n\tput_online_cpus();\n\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__padata_remove_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "766-788",
    "snippet": "static int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd = NULL;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.cbcpu);\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.pcpu);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "pd->cpumask.pcpu"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_replace",
          "args": [
            "pinst",
            "pd"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "562-588",
          "snippet": "static void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_alloc_pd",
          "args": [
            "pinst",
            "pinst->cpumask.pcpu",
            "pinst->cpumask.cbcpu"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "467-506",
          "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_stop",
          "args": [
            "pinst"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "547-559",
          "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "pinst->cpumask.cbcpu"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "623-633",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd = NULL;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.cbcpu);\n\t\tcpumask_clear_cpu(cpu, pd->cpumask.pcpu);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__padata_add_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "746-764",
    "snippet": "static int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_start",
          "args": [
            "pinst"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "542-545",
          "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "pinst->cpumask.cbcpu"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "623-633",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_replace",
          "args": [
            "pinst",
            "pd"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "562-588",
          "snippet": "static void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_alloc_pd",
          "args": [
            "pinst",
            "pinst->cpumask.pcpu",
            "pinst->cpumask.cbcpu"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "467-506",
          "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tstruct parallel_data *pd;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tpd = padata_alloc_pd(pinst, pinst->cpumask.pcpu,\n\t\t\t\t     pinst->cpumask.cbcpu);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tpadata_replace(pinst, pd);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "padata_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "736-741",
    "snippet": "void padata_stop(struct padata_instance *pinst)\n{\n\tmutex_lock(&pinst->lock);\n\t__padata_stop(pinst);\n\tmutex_unlock(&pinst->lock);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_stop",
          "args": [
            "pinst"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "547-559",
          "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nvoid padata_stop(struct padata_instance *pinst)\n{\n\tmutex_lock(&pinst->lock);\n\t__padata_stop(pinst);\n\tmutex_unlock(&pinst->lock);\n}"
  },
  {
    "function_name": "padata_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "714-728",
    "snippet": "int padata_start(struct padata_instance *pinst)\n{\n\tint err = 0;\n\n\tmutex_lock(&pinst->lock);\n\n\tif (pinst->flags & PADATA_INVALID)\n\t\terr = -EINVAL;\n\n\t __padata_start(pinst);\n\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_start",
          "args": [
            "pinst"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "542-545",
          "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nint padata_start(struct padata_instance *pinst)\n{\n\tint err = 0;\n\n\tmutex_lock(&pinst->lock);\n\n\tif (pinst->flags & PADATA_INVALID)\n\t\terr = -EINVAL;\n\n\t __padata_start(pinst);\n\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_set_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "677-706",
    "snippet": "int padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tmutex_lock(&pinst->lock);\n\tget_online_cpus();\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tput_online_cpus();\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_set_cpumasks",
          "args": [
            "pinst",
            "parallel_mask",
            "serial_mask"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_set_cpumasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "635-666",
          "snippet": "static int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tstruct parallel_data *pd;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpadata_replace(pinst, pd);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tstruct parallel_data *pd;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpadata_replace(pinst, pd);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nint padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tmutex_lock(&pinst->lock);\n\tget_online_cpus();\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tput_online_cpus();\n\tmutex_unlock(&pinst->lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__padata_set_cpumasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "635-666",
    "snippet": "static int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tstruct parallel_data *pd;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpadata_replace(pinst, pd);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_start",
          "args": [
            "pinst"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "542-545",
          "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_replace",
          "args": [
            "pinst",
            "pd"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "562-588",
          "snippet": "static void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.cbcpu",
            "cbcpumask"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.pcpu",
            "pcpumask"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_alloc_pd",
          "args": [
            "pinst",
            "pcpumask",
            "cbcpumask"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "467-506",
          "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_stop",
          "args": [
            "pinst"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "547-559",
          "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "cbcpumask"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "623-633",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tstruct parallel_data *pd;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tpd = padata_alloc_pd(pinst, pcpumask, cbcpumask);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\tpadata_replace(pinst, pd);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "padata_validate_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "623-633",
    "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "cpumask",
            "cpu_online_mask"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
  },
  {
    "function_name": "padata_unregister_cpumask_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "612-618",
    "snippet": "int padata_unregister_cpumask_notifier(struct padata_instance *pinst,\n\t\t\t\t       struct notifier_block *nblock)\n{\n\treturn blocking_notifier_chain_unregister(\n\t\t&pinst->cpumask_change_notifier,\n\t\tnblock);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&pinst->cpumask_change_notifier",
            "nblock"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "266-283",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nint padata_unregister_cpumask_notifier(struct padata_instance *pinst,\n\t\t\t\t       struct notifier_block *nblock)\n{\n\treturn blocking_notifier_chain_unregister(\n\t\t&pinst->cpumask_change_notifier,\n\t\tnblock);\n}"
  },
  {
    "function_name": "padata_register_cpumask_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "597-602",
    "snippet": "int padata_register_cpumask_notifier(struct padata_instance *pinst,\n\t\t\t\t     struct notifier_block *nblock)\n{\n\treturn blocking_notifier_chain_register(&pinst->cpumask_change_notifier,\n\t\t\t\t\t\tnblock);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&pinst->cpumask_change_notifier",
            "nblock"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "213-230",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nint padata_register_cpumask_notifier(struct padata_instance *pinst,\n\t\t\t\t     struct notifier_block *nblock)\n{\n\treturn blocking_notifier_chain_register(&pinst->cpumask_change_notifier,\n\t\t\t\t\t\tnblock);\n}"
  },
  {
    "function_name": "padata_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "562-588",
    "snippet": "static void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&pinst->cpumask_change_notifier",
            "notification_mask",
            "&pd_new->cpumask"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "325-329",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_free_pd",
          "args": [
            "pd_old"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "padata_free_pd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "508-515",
          "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->pqueue);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->pqueue);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_flush_queues",
          "args": [
            "pd_old"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "padata_flush_queues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "518-540",
          "snippet": "static void padata_flush_queues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\t\tflush_work(&pqueue->work);\n\t}\n\n\tdel_timer_sync(&pd->timer);\n\n\tif (atomic_read(&pd->reorder_objects))\n\t\tpadata_reorder(pd);\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tflush_work(&squeue->work);\n\t}\n\n\tBUG_ON(atomic_read(&pd->refcnt) != 0);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_flush_queues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\t\tflush_work(&pqueue->work);\n\t}\n\n\tdel_timer_sync(&pd->timer);\n\n\tif (atomic_read(&pd->reorder_objects))\n\t\tpadata_reorder(pd);\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tflush_work(&squeue->work);\n\t}\n\n\tBUG_ON(atomic_read(&pd->refcnt) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "pd_old->cpumask.cbcpu",
            "pd_new->cpumask.cbcpu"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "pd_old->cpumask.pcpu",
            "pd_new->cpumask.pcpu"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "pinst->pd",
            "pd_new"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_replace(struct padata_instance *pinst,\n\t\t\t   struct parallel_data *pd_new)\n{\n\tstruct parallel_data *pd_old = pinst->pd;\n\tint notification_mask = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\trcu_assign_pointer(pinst->pd, pd_new);\n\n\tsynchronize_rcu();\n\n\tif (!cpumask_equal(pd_old->cpumask.pcpu, pd_new->cpumask.pcpu))\n\t\tnotification_mask |= PADATA_CPU_PARALLEL;\n\tif (!cpumask_equal(pd_old->cpumask.cbcpu, pd_new->cpumask.cbcpu))\n\t\tnotification_mask |= PADATA_CPU_SERIAL;\n\n\tpadata_flush_queues(pd_old);\n\tpadata_free_pd(pd_old);\n\n\tif (notification_mask)\n\t\tblocking_notifier_call_chain(&pinst->cpumask_change_notifier,\n\t\t\t\t\t     notification_mask,\n\t\t\t\t\t     &pd_new->cpumask);\n\n\tpinst->flags &= ~PADATA_RESET;\n}"
  },
  {
    "function_name": "__padata_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "547-559",
    "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_flush_queues",
          "args": [
            "pinst->pd"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "padata_flush_queues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "518-540",
          "snippet": "static void padata_flush_queues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\t\tflush_work(&pqueue->work);\n\t}\n\n\tdel_timer_sync(&pd->timer);\n\n\tif (atomic_read(&pd->reorder_objects))\n\t\tpadata_reorder(pd);\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tflush_work(&squeue->work);\n\t}\n\n\tBUG_ON(atomic_read(&pd->refcnt) != 0);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_flush_queues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\t\tflush_work(&pqueue->work);\n\t}\n\n\tdel_timer_sync(&pd->timer);\n\n\tif (atomic_read(&pd->reorder_objects))\n\t\tpadata_reorder(pd);\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tflush_work(&squeue->work);\n\t}\n\n\tBUG_ON(atomic_read(&pd->refcnt) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n\n\tget_online_cpus();\n\tpadata_flush_queues(pinst->pd);\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "__padata_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "542-545",
    "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
  },
  {
    "function_name": "padata_flush_queues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "518-540",
    "snippet": "static void padata_flush_queues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\t\tflush_work(&pqueue->work);\n\t}\n\n\tdel_timer_sync(&pd->timer);\n\n\tif (atomic_read(&pd->reorder_objects))\n\t\tpadata_reorder(pd);\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tflush_work(&squeue->work);\n\t}\n\n\tBUG_ON(atomic_read(&pd->refcnt) != 0);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&pd->refcnt) != 0"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pd->refcnt"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&squeue->work"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->squeue",
            "cpu"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_reorder",
          "args": [
            "pd"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "padata_reorder_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "292-325",
          "snippet": "static void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pd->reorder_objects"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&pd->timer"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->pqueue",
            "cpu"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "pd->cpumask.pcpu"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_flush_queues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\t\tflush_work(&pqueue->work);\n\t}\n\n\tdel_timer_sync(&pd->timer);\n\n\tif (atomic_read(&pd->reorder_objects))\n\t\tpadata_reorder(pd);\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tflush_work(&squeue->work);\n\t}\n\n\tBUG_ON(atomic_read(&pd->refcnt) != 0);\n}"
  },
  {
    "function_name": "padata_free_pd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "508-515",
    "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->pqueue);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pd"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pd->squeue"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pd->cpumask.cbcpu"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->pqueue);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
  },
  {
    "function_name": "padata_alloc_pd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "467-506",
    "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pd"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pd->pqueue"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pd->lock"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pd->refcnt",
            "0"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pd->reorder_objects",
            "0"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pd->seq_nr",
            "-1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&pd->timer",
            "padata_reorder_timer",
            "0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_init_squeues",
          "args": [
            "pd"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "padata_init_squeues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "426-437",
          "snippet": "static void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_init_pqueues",
          "args": [
            "pd"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "padata_init_pqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "440-464",
          "snippet": "static void padata_init_pqueues(struct parallel_data *pd)\n{\n\tint cpu_index, cpu;\n\tstruct padata_parallel_queue *pqueue;\n\n\tcpu_index = 0;\n\tfor_each_possible_cpu(cpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\n\t\tif (!cpumask_test_cpu(cpu, pd->cpumask.pcpu)) {\n\t\t\tpqueue->cpu_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpqueue->pd = pd;\n\t\tpqueue->cpu_index = cpu_index;\n\t\tcpu_index++;\n\n\t\t__padata_list_init(&pqueue->reorder);\n\t\t__padata_list_init(&pqueue->parallel);\n\t\tINIT_WORK(&pqueue->work, padata_parallel_worker);\n\t\tINIT_WORK(&pqueue->reorder_work, invoke_padata_reorder);\n\t\tatomic_set(&pqueue->num_obj, 0);\n\t}\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_init_pqueues(struct parallel_data *pd)\n{\n\tint cpu_index, cpu;\n\tstruct padata_parallel_queue *pqueue;\n\n\tcpu_index = 0;\n\tfor_each_possible_cpu(cpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\n\t\tif (!cpumask_test_cpu(cpu, pd->cpumask.pcpu)) {\n\t\t\tpqueue->cpu_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpqueue->pd = pd;\n\t\tpqueue->cpu_index = cpu_index;\n\t\tcpu_index++;\n\n\t\t__padata_list_init(&pqueue->reorder);\n\t\t__padata_list_init(&pqueue->parallel);\n\t\tINIT_WORK(&pqueue->work, padata_parallel_worker);\n\t\tINIT_WORK(&pqueue->reorder_work, invoke_padata_reorder);\n\t\tatomic_set(&pqueue->num_obj, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_setup_cpumasks",
          "args": [
            "pd",
            "pcpumask",
            "cbcpumask"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "padata_setup_cpumasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "402-417",
          "snippet": "static int padata_setup_cpumasks(struct parallel_data *pd,\n\t\t\t\t const struct cpumask *pcpumask,\n\t\t\t\t const struct cpumask *cbcpumask)\n{\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_and(pd->cpumask.pcpu, pcpumask, cpu_online_mask);\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pd->cpumask.pcpu);\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_and(pd->cpumask.cbcpu, cbcpumask, cpu_online_mask);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_setup_cpumasks(struct parallel_data *pd,\n\t\t\t\t const struct cpumask *pcpumask,\n\t\t\t\t const struct cpumask *cbcpumask)\n{\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_and(pd->cpumask.pcpu, pcpumask, cpu_online_mask);\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pd->cpumask.pcpu);\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_and(pd->cpumask.cbcpu, cbcpumask, cpu_online_mask);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpadata_serial_queue"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct parallel_data)",
            "GFP_KERNEL"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_instance *pinst,\n\t\t\t\t\t     const struct cpumask *pcpumask,\n\t\t\t\t\t     const struct cpumask *cbcpumask)\n{\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->pqueue = alloc_percpu(struct padata_parallel_queue);\n\tif (!pd->pqueue)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_pqueue;\n\tif (padata_setup_cpumasks(pd, pcpumask, cbcpumask) < 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\ttimer_setup(&pd->timer, padata_reorder_timer, 0);\n\tatomic_set(&pd->seq_nr, -1);\n\tatomic_set(&pd->reorder_objects, 0);\n\tatomic_set(&pd->refcnt, 0);\n\tpd->pinst = pinst;\n\tspin_lock_init(&pd->lock);\n\n\treturn pd;\n\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_pqueue:\n\tfree_percpu(pd->pqueue);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "padata_init_pqueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "440-464",
    "snippet": "static void padata_init_pqueues(struct parallel_data *pd)\n{\n\tint cpu_index, cpu;\n\tstruct padata_parallel_queue *pqueue;\n\n\tcpu_index = 0;\n\tfor_each_possible_cpu(cpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\n\t\tif (!cpumask_test_cpu(cpu, pd->cpumask.pcpu)) {\n\t\t\tpqueue->cpu_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpqueue->pd = pd;\n\t\tpqueue->cpu_index = cpu_index;\n\t\tcpu_index++;\n\n\t\t__padata_list_init(&pqueue->reorder);\n\t\t__padata_list_init(&pqueue->parallel);\n\t\tINIT_WORK(&pqueue->work, padata_parallel_worker);\n\t\tINIT_WORK(&pqueue->reorder_work, invoke_padata_reorder);\n\t\tatomic_set(&pqueue->num_obj, 0);\n\t}\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pqueue->num_obj",
            "0"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pqueue->reorder_work",
            "invoke_padata_reorder"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pqueue->work",
            "padata_parallel_worker"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_list_init",
          "args": [
            "&pqueue->parallel"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "419-423",
          "snippet": "static void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pd->cpumask.pcpu"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->pqueue",
            "cpu"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_init_pqueues(struct parallel_data *pd)\n{\n\tint cpu_index, cpu;\n\tstruct padata_parallel_queue *pqueue;\n\n\tcpu_index = 0;\n\tfor_each_possible_cpu(cpu) {\n\t\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\n\t\tif (!cpumask_test_cpu(cpu, pd->cpumask.pcpu)) {\n\t\t\tpqueue->cpu_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpqueue->pd = pd;\n\t\tpqueue->cpu_index = cpu_index;\n\t\tcpu_index++;\n\n\t\t__padata_list_init(&pqueue->reorder);\n\t\t__padata_list_init(&pqueue->parallel);\n\t\tINIT_WORK(&pqueue->work, padata_parallel_worker);\n\t\tINIT_WORK(&pqueue->reorder_work, invoke_padata_reorder);\n\t\tatomic_set(&pqueue->num_obj, 0);\n\t}\n}"
  },
  {
    "function_name": "padata_init_squeues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "426-437",
    "snippet": "static void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&squeue->work",
            "padata_serial_worker"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_list_init",
          "args": [
            "&squeue->serial"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "419-423",
          "snippet": "static void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->squeue",
            "cpu"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}"
  },
  {
    "function_name": "__padata_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "419-423",
    "snippet": "static void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pd_list->lock"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pd_list->list"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}"
  },
  {
    "function_name": "padata_setup_cpumasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "402-417",
    "snippet": "static int padata_setup_cpumasks(struct parallel_data *pd,\n\t\t\t\t const struct cpumask *pcpumask,\n\t\t\t\t const struct cpumask *cbcpumask)\n{\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_and(pd->cpumask.pcpu, pcpumask, cpu_online_mask);\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pd->cpumask.pcpu);\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_and(pd->cpumask.cbcpu, cbcpumask, cpu_online_mask);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "pd->cpumask.cbcpu",
            "cbcpumask",
            "cpu_online_mask"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pd->cpumask.cbcpu",
            "GFP_KERNEL"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "pd->cpumask.pcpu",
            "pcpumask",
            "cpu_online_mask"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pd->cpumask.pcpu",
            "GFP_KERNEL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_setup_cpumasks(struct parallel_data *pd,\n\t\t\t\t const struct cpumask *pcpumask,\n\t\t\t\t const struct cpumask *cbcpumask)\n{\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_and(pd->cpumask.pcpu, pcpumask, cpu_online_mask);\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pd->cpumask.pcpu);\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_and(pd->cpumask.cbcpu, cbcpumask, cpu_online_mask);\n\treturn 0;\n}"
  },
  {
    "function_name": "padata_do_serial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "363-399",
    "snippet": "void padata_do_serial(struct padata_priv *padata)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct parallel_data *pd;\n\tint reorder_via_wq = 0;\n\n\tpd = padata->pd;\n\n\tcpu = get_cpu();\n\n\t/* We need to run on the same CPU padata_do_parallel(.., padata, ..)\n\t * was called on -- or, at least, enqueue the padata object into the\n\t * correct per-cpu queue.\n\t */\n\tif (cpu != padata->cpu) {\n\t\treorder_via_wq = 1;\n\t\tcpu = padata->cpu;\n\t}\n\n\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\n\tspin_lock(&pqueue->reorder.lock);\n\tatomic_inc(&pd->reorder_objects);\n\tlist_add_tail(&padata->list, &pqueue->reorder.list);\n\tspin_unlock(&pqueue->reorder.lock);\n\n\tput_cpu();\n\n\t/* If we're running on the wrong CPU, call padata_reorder() via a\n\t * kernel worker.\n\t */\n\tif (reorder_via_wq)\n\t\tqueue_work_on(cpu, pd->pinst->wq, &pqueue->reorder_work);\n\telse\n\t\tpadata_reorder(pd);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_reorder",
          "args": [
            "pd"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "padata_reorder_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "292-325",
          "snippet": "static void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "pd->pinst->wq",
            "&pqueue->reorder_work"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1477-1492",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pqueue->reorder.lock"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&padata->list",
            "&pqueue->reorder.list"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pd->reorder_objects"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pqueue->reorder.lock"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->pqueue",
            "cpu"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nvoid padata_do_serial(struct padata_priv *padata)\n{\n\tint cpu;\n\tstruct padata_parallel_queue *pqueue;\n\tstruct parallel_data *pd;\n\tint reorder_via_wq = 0;\n\n\tpd = padata->pd;\n\n\tcpu = get_cpu();\n\n\t/* We need to run on the same CPU padata_do_parallel(.., padata, ..)\n\t * was called on -- or, at least, enqueue the padata object into the\n\t * correct per-cpu queue.\n\t */\n\tif (cpu != padata->cpu) {\n\t\treorder_via_wq = 1;\n\t\tcpu = padata->cpu;\n\t}\n\n\tpqueue = per_cpu_ptr(pd->pqueue, cpu);\n\n\tspin_lock(&pqueue->reorder.lock);\n\tatomic_inc(&pd->reorder_objects);\n\tlist_add_tail(&padata->list, &pqueue->reorder.list);\n\tspin_unlock(&pqueue->reorder.lock);\n\n\tput_cpu();\n\n\t/* If we're running on the wrong CPU, call padata_reorder() via a\n\t * kernel worker.\n\t */\n\tif (reorder_via_wq)\n\t\tqueue_work_on(cpu, pd->pinst->wq, &pqueue->reorder_work);\n\telse\n\t\tpadata_reorder(pd);\n}"
  },
  {
    "function_name": "padata_serial_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "327-353",
    "snippet": "static void padata_serial_worker(struct work_struct *serial_work)\n{\n\tstruct padata_serial_queue *squeue;\n\tstruct parallel_data *pd;\n\tLIST_HEAD(local_list);\n\n\tlocal_bh_disable();\n\tsqueue = container_of(serial_work, struct padata_serial_queue, work);\n\tpd = squeue->pd;\n\n\tspin_lock(&squeue->serial.lock);\n\tlist_replace_init(&squeue->serial.list, &local_list);\n\tspin_unlock(&squeue->serial.lock);\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct padata_priv *padata;\n\n\t\tpadata = list_entry(local_list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\n\t\tpadata->serial(padata);\n\t\tatomic_dec(&pd->refcnt);\n\t}\n\tlocal_bh_enable();\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pd->refcnt"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata->serial",
          "args": [
            "padata"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&padata->list"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "local_list.next",
            "structpadata_priv",
            "list"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&local_list"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&squeue->serial.list",
            "&local_list"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "serial_work",
            "structpadata_serial_queue",
            "work"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "local_list"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_serial_worker(struct work_struct *serial_work)\n{\n\tstruct padata_serial_queue *squeue;\n\tstruct parallel_data *pd;\n\tLIST_HEAD(local_list);\n\n\tlocal_bh_disable();\n\tsqueue = container_of(serial_work, struct padata_serial_queue, work);\n\tpd = squeue->pd;\n\n\tspin_lock(&squeue->serial.lock);\n\tlist_replace_init(&squeue->serial.list, &local_list);\n\tspin_unlock(&squeue->serial.lock);\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct padata_priv *padata;\n\n\t\tpadata = list_entry(local_list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\n\t\tpadata->serial(padata);\n\t\tatomic_dec(&pd->refcnt);\n\t}\n\tlocal_bh_enable();\n}"
  },
  {
    "function_name": "padata_reorder_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "292-325",
    "snippet": "static void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_reorder",
          "args": [
            "pd"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "padata_reorder_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "292-325",
          "snippet": "static void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "target_cpu",
            "pinst->wq",
            "&pqueue->reorder_work"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1477-1492",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->pqueue",
            "target_cpu"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_index_to_cpu",
          "args": [
            "pd",
            "pd->processed % weight"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "padata_index_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "38-47",
          "snippet": "static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "pd",
            "t",
            "timer"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}"
  },
  {
    "function_name": "invoke_padata_reorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "280-290",
    "snippet": "static void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct padata_parallel_queue *pqueue;\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpqueue = container_of(work, struct padata_parallel_queue, reorder_work);\n\tpd = pqueue->pd;\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_reorder",
          "args": [
            "pd"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "padata_reorder_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "292-325",
          "snippet": "static void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_reorder_timer(struct timer_list *t)\n{\n\tstruct parallel_data *pd = from_timer(pd, t, timer);\n\tunsigned int weight;\n\tint target_cpu, cpu;\n\n\tcpu = get_cpu();\n\n\t/* We don't lock pd here to not interfere with parallel processing\n\t * padata_reorder() calls on other CPUs. We just need any CPU out of\n\t * the cpumask.pcpu set. It would be nice if it's the right one but\n\t * it doesn't matter if we're off to the next one by using an outdated\n\t * pd->processed value.\n\t */\n\tweight = cpumask_weight(pd->cpumask.pcpu);\n\ttarget_cpu = padata_index_to_cpu(pd, pd->processed % weight);\n\n\t/* ensure to call the reorder callback on the correct CPU */\n\tif (cpu != target_cpu) {\n\t\tstruct padata_parallel_queue *pqueue;\n\t\tstruct padata_instance *pinst;\n\n\t\t/* The timer function is serialized wrt itself -- no locking\n\t\t * needed.\n\t\t */\n\t\tpinst = pd->pinst;\n\t\tpqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\t\tqueue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);\n\t} else {\n\t\tpadata_reorder(pd);\n\t}\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structpadata_parallel_queue",
            "reorder_work"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct padata_parallel_queue *pqueue;\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpqueue = container_of(work, struct padata_parallel_queue, reorder_work);\n\tpd = pqueue->pd;\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}"
  },
  {
    "function_name": "padata_reorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "212-278",
    "snippet": "static void padata_reorder(struct parallel_data *pd)\n{\n\tint cb_cpu;\n\tstruct padata_priv *padata;\n\tstruct padata_serial_queue *squeue;\n\tstruct padata_instance *pinst = pd->pinst;\n\n\t/*\n\t * We need to ensure that only one cpu can work on dequeueing of\n\t * the reorder queue the time. Calculating in which percpu reorder\n\t * queue the next object will arrive takes some time. A spinlock\n\t * would be highly contended. Also it is not clear in which order\n\t * the objects arrive to the reorder queues. So a cpu could wait to\n\t * get the lock just to notice that there is nothing to do at the\n\t * moment. Therefore we use a trylock and let the holder of the lock\n\t * care for all the objects enqueued during the holdtime of the lock.\n\t */\n\tif (!spin_trylock_bh(&pd->lock))\n\t\treturn;\n\n\twhile (1) {\n\t\tpadata = padata_get_next(pd);\n\n\t\t/*\n\t\t * If the next object that needs serialization is parallel\n\t\t * processed by another cpu and is still on it's way to the\n\t\t * cpu's reorder queue, nothing to do for now.\n\t\t */\n\t\tif (PTR_ERR(padata) == -EINPROGRESS)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This cpu has to do the parallel processing of the next\n\t\t * object. It's waiting in the cpu's parallelization queue,\n\t\t * so exit immediately.\n\t\t */\n\t\tif (PTR_ERR(padata) == -ENODATA) {\n\t\t\tdel_timer(&pd->timer);\n\t\t\tspin_unlock_bh(&pd->lock);\n\t\t\treturn;\n\t\t}\n\n\t\tcb_cpu = padata->cb_cpu;\n\t\tsqueue = per_cpu_ptr(pd->squeue, cb_cpu);\n\n\t\tspin_lock(&squeue->serial.lock);\n\t\tlist_add_tail(&padata->list, &squeue->serial.list);\n\t\tspin_unlock(&squeue->serial.lock);\n\n\t\tqueue_work_on(cb_cpu, pinst->wq, &squeue->work);\n\t}\n\n\tspin_unlock_bh(&pd->lock);\n\n\t/*\n\t * The next object that needs serialization might have arrived to\n\t * the reorder queues in the meantime, we will be called again\n\t * from the timer function if no one else cares for it.\n\t */\n\tif (atomic_read(&pd->reorder_objects)\n\t\t\t&& !(pinst->flags & PADATA_RESET))\n\t\tmod_timer(&pd->timer, jiffies + HZ);\n\telse\n\t\tdel_timer(&pd->timer);\n\n\treturn;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&pd->timer"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pd->timer",
            "jiffies + HZ"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pd->reorder_objects"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&pd->lock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cb_cpu",
            "pinst->wq",
            "&squeue->work"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1477-1492",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&padata->list",
            "&squeue->serial.list"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->squeue",
            "cb_cpu"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "padata"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "padata"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_get_next",
          "args": [
            "pd"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "padata_get_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "166-210",
          "snippet": "static struct padata_priv *padata_get_next(struct parallel_data *pd)\n{\n\tint cpu, num_cpus;\n\tunsigned int next_nr, next_index;\n\tstruct padata_parallel_queue *next_queue;\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\n\tnum_cpus = cpumask_weight(pd->cpumask.pcpu);\n\n\t/*\n\t * Calculate the percpu reorder queue and the sequence\n\t * number of the next object.\n\t */\n\tnext_nr = pd->processed;\n\tnext_index = next_nr % num_cpus;\n\tcpu = padata_index_to_cpu(pd, next_index);\n\tnext_queue = per_cpu_ptr(pd->pqueue, cpu);\n\n\treorder = &next_queue->reorder;\n\n\tspin_lock(&reorder->lock);\n\tif (!list_empty(&reorder->list)) {\n\t\tpadata = list_entry(reorder->list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\t\tatomic_dec(&pd->reorder_objects);\n\n\t\tpd->processed++;\n\n\t\tspin_unlock(&reorder->lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&reorder->lock);\n\n\tif (__this_cpu_read(pd->pqueue->cpu_index) == next_queue->cpu_index) {\n\t\tpadata = ERR_PTR(-ENODATA);\n\t\tgoto out;\n\t}\n\n\tpadata = ERR_PTR(-EINPROGRESS);\nout:\n\treturn padata;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct padata_priv *padata_get_next(struct parallel_data *pd)\n{\n\tint cpu, num_cpus;\n\tunsigned int next_nr, next_index;\n\tstruct padata_parallel_queue *next_queue;\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\n\tnum_cpus = cpumask_weight(pd->cpumask.pcpu);\n\n\t/*\n\t * Calculate the percpu reorder queue and the sequence\n\t * number of the next object.\n\t */\n\tnext_nr = pd->processed;\n\tnext_index = next_nr % num_cpus;\n\tcpu = padata_index_to_cpu(pd, next_index);\n\tnext_queue = per_cpu_ptr(pd->pqueue, cpu);\n\n\treorder = &next_queue->reorder;\n\n\tspin_lock(&reorder->lock);\n\tif (!list_empty(&reorder->list)) {\n\t\tpadata = list_entry(reorder->list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\t\tatomic_dec(&pd->reorder_objects);\n\n\t\tpd->processed++;\n\n\t\tspin_unlock(&reorder->lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&reorder->lock);\n\n\tif (__this_cpu_read(pd->pqueue->cpu_index) == next_queue->cpu_index) {\n\t\tpadata = ERR_PTR(-ENODATA);\n\t\tgoto out;\n\t}\n\n\tpadata = ERR_PTR(-EINPROGRESS);\nout:\n\treturn padata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock_bh",
          "args": [
            "&pd->lock"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_reorder(struct parallel_data *pd)\n{\n\tint cb_cpu;\n\tstruct padata_priv *padata;\n\tstruct padata_serial_queue *squeue;\n\tstruct padata_instance *pinst = pd->pinst;\n\n\t/*\n\t * We need to ensure that only one cpu can work on dequeueing of\n\t * the reorder queue the time. Calculating in which percpu reorder\n\t * queue the next object will arrive takes some time. A spinlock\n\t * would be highly contended. Also it is not clear in which order\n\t * the objects arrive to the reorder queues. So a cpu could wait to\n\t * get the lock just to notice that there is nothing to do at the\n\t * moment. Therefore we use a trylock and let the holder of the lock\n\t * care for all the objects enqueued during the holdtime of the lock.\n\t */\n\tif (!spin_trylock_bh(&pd->lock))\n\t\treturn;\n\n\twhile (1) {\n\t\tpadata = padata_get_next(pd);\n\n\t\t/*\n\t\t * If the next object that needs serialization is parallel\n\t\t * processed by another cpu and is still on it's way to the\n\t\t * cpu's reorder queue, nothing to do for now.\n\t\t */\n\t\tif (PTR_ERR(padata) == -EINPROGRESS)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This cpu has to do the parallel processing of the next\n\t\t * object. It's waiting in the cpu's parallelization queue,\n\t\t * so exit immediately.\n\t\t */\n\t\tif (PTR_ERR(padata) == -ENODATA) {\n\t\t\tdel_timer(&pd->timer);\n\t\t\tspin_unlock_bh(&pd->lock);\n\t\t\treturn;\n\t\t}\n\n\t\tcb_cpu = padata->cb_cpu;\n\t\tsqueue = per_cpu_ptr(pd->squeue, cb_cpu);\n\n\t\tspin_lock(&squeue->serial.lock);\n\t\tlist_add_tail(&padata->list, &squeue->serial.list);\n\t\tspin_unlock(&squeue->serial.lock);\n\n\t\tqueue_work_on(cb_cpu, pinst->wq, &squeue->work);\n\t}\n\n\tspin_unlock_bh(&pd->lock);\n\n\t/*\n\t * The next object that needs serialization might have arrived to\n\t * the reorder queues in the meantime, we will be called again\n\t * from the timer function if no one else cares for it.\n\t */\n\tif (atomic_read(&pd->reorder_objects)\n\t\t\t&& !(pinst->flags & PADATA_RESET))\n\t\tmod_timer(&pd->timer, jiffies + HZ);\n\telse\n\t\tdel_timer(&pd->timer);\n\n\treturn;\n}"
  },
  {
    "function_name": "padata_get_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "166-210",
    "snippet": "static struct padata_priv *padata_get_next(struct parallel_data *pd)\n{\n\tint cpu, num_cpus;\n\tunsigned int next_nr, next_index;\n\tstruct padata_parallel_queue *next_queue;\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\n\tnum_cpus = cpumask_weight(pd->cpumask.pcpu);\n\n\t/*\n\t * Calculate the percpu reorder queue and the sequence\n\t * number of the next object.\n\t */\n\tnext_nr = pd->processed;\n\tnext_index = next_nr % num_cpus;\n\tcpu = padata_index_to_cpu(pd, next_index);\n\tnext_queue = per_cpu_ptr(pd->pqueue, cpu);\n\n\treorder = &next_queue->reorder;\n\n\tspin_lock(&reorder->lock);\n\tif (!list_empty(&reorder->list)) {\n\t\tpadata = list_entry(reorder->list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\t\tatomic_dec(&pd->reorder_objects);\n\n\t\tpd->processed++;\n\n\t\tspin_unlock(&reorder->lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&reorder->lock);\n\n\tif (__this_cpu_read(pd->pqueue->cpu_index) == next_queue->cpu_index) {\n\t\tpadata = ERR_PTR(-ENODATA);\n\t\tgoto out;\n\t}\n\n\tpadata = ERR_PTR(-EINPROGRESS);\nout:\n\treturn padata;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINPROGRESS"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODATA"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "pd->pqueue->cpu_index"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&reorder->lock"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pd->reorder_objects"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&padata->list"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "reorder->list.next",
            "structpadata_priv",
            "list"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reorder->list"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&reorder->lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->pqueue",
            "cpu"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_index_to_cpu",
          "args": [
            "pd",
            "next_index"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "padata_index_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "38-47",
          "snippet": "static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic struct padata_priv *padata_get_next(struct parallel_data *pd)\n{\n\tint cpu, num_cpus;\n\tunsigned int next_nr, next_index;\n\tstruct padata_parallel_queue *next_queue;\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\n\tnum_cpus = cpumask_weight(pd->cpumask.pcpu);\n\n\t/*\n\t * Calculate the percpu reorder queue and the sequence\n\t * number of the next object.\n\t */\n\tnext_nr = pd->processed;\n\tnext_index = next_nr % num_cpus;\n\tcpu = padata_index_to_cpu(pd, next_index);\n\tnext_queue = per_cpu_ptr(pd->pqueue, cpu);\n\n\treorder = &next_queue->reorder;\n\n\tspin_lock(&reorder->lock);\n\tif (!list_empty(&reorder->list)) {\n\t\tpadata = list_entry(reorder->list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\t\tatomic_dec(&pd->reorder_objects);\n\n\t\tpd->processed++;\n\n\t\tspin_unlock(&reorder->lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&reorder->lock);\n\n\tif (__this_cpu_read(pd->pqueue->cpu_index) == next_queue->cpu_index) {\n\t\tpadata = ERR_PTR(-ENODATA);\n\t\tgoto out;\n\t}\n\n\tpadata = ERR_PTR(-EINPROGRESS);\nout:\n\treturn padata;\n}"
  },
  {
    "function_name": "padata_do_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "104-148",
    "snippet": "int padata_do_parallel(struct padata_instance *pinst,\n\t\t       struct padata_priv *padata, int cb_cpu)\n{\n\tint target_cpu, err;\n\tstruct padata_parallel_queue *queue;\n\tstruct parallel_data *pd;\n\n\trcu_read_lock_bh();\n\n\tpd = rcu_dereference_bh(pinst->pd);\n\n\terr = -EINVAL;\n\tif (!(pinst->flags & PADATA_INIT) || pinst->flags & PADATA_INVALID)\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(cb_cpu, pd->cpumask.cbcpu))\n\t\tgoto out;\n\n\terr =  -EBUSY;\n\tif ((pinst->flags & PADATA_RESET))\n\t\tgoto out;\n\n\tif (atomic_read(&pd->refcnt) >= MAX_OBJ_NUM)\n\t\tgoto out;\n\n\terr = 0;\n\tatomic_inc(&pd->refcnt);\n\tpadata->pd = pd;\n\tpadata->cb_cpu = cb_cpu;\n\n\ttarget_cpu = padata_cpu_hash(pd);\n\tpadata->cpu = target_cpu;\n\tqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\n\tspin_lock(&queue->parallel.lock);\n\tlist_add_tail(&padata->list, &queue->parallel.list);\n\tspin_unlock(&queue->parallel.lock);\n\n\tqueue_work_on(target_cpu, pinst->wq, &queue->work);\n\nout:\n\trcu_read_unlock_bh();\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define MAX_OBJ_NUM 1000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_bh",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "target_cpu",
            "pinst->wq",
            "&queue->work"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1477-1492",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&queue->parallel.lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&padata->list",
            "&queue->parallel.list"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&queue->parallel.lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->pqueue",
            "target_cpu"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_cpu_hash",
          "args": [
            "pd"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "padata_cpu_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "49-63",
          "snippet": "static int padata_cpu_hash(struct parallel_data *pd)\n{\n\tunsigned int seq_nr;\n\tint cpu_index;\n\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\n\tseq_nr = atomic_inc_return(&pd->seq_nr);\n\tcpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_cpu_hash(struct parallel_data *pd)\n{\n\tunsigned int seq_nr;\n\tint cpu_index;\n\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\n\tseq_nr = atomic_inc_return(&pd->seq_nr);\n\tcpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pd->refcnt"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pd->refcnt"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cb_cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_bh",
          "args": [
            "pinst->pd"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\n#define MAX_OBJ_NUM 1000\n\nint padata_do_parallel(struct padata_instance *pinst,\n\t\t       struct padata_priv *padata, int cb_cpu)\n{\n\tint target_cpu, err;\n\tstruct padata_parallel_queue *queue;\n\tstruct parallel_data *pd;\n\n\trcu_read_lock_bh();\n\n\tpd = rcu_dereference_bh(pinst->pd);\n\n\terr = -EINVAL;\n\tif (!(pinst->flags & PADATA_INIT) || pinst->flags & PADATA_INVALID)\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(cb_cpu, pd->cpumask.cbcpu))\n\t\tgoto out;\n\n\terr =  -EBUSY;\n\tif ((pinst->flags & PADATA_RESET))\n\t\tgoto out;\n\n\tif (atomic_read(&pd->refcnt) >= MAX_OBJ_NUM)\n\t\tgoto out;\n\n\terr = 0;\n\tatomic_inc(&pd->refcnt);\n\tpadata->pd = pd;\n\tpadata->cb_cpu = cb_cpu;\n\n\ttarget_cpu = padata_cpu_hash(pd);\n\tpadata->cpu = target_cpu;\n\tqueue = per_cpu_ptr(pd->pqueue, target_cpu);\n\n\tspin_lock(&queue->parallel.lock);\n\tlist_add_tail(&padata->list, &queue->parallel.list);\n\tspin_unlock(&queue->parallel.lock);\n\n\tqueue_work_on(target_cpu, pinst->wq, &queue->work);\n\nout:\n\trcu_read_unlock_bh();\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_parallel_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "65-90",
    "snippet": "static void padata_parallel_worker(struct work_struct *parallel_work)\n{\n\tstruct padata_parallel_queue *pqueue;\n\tLIST_HEAD(local_list);\n\n\tlocal_bh_disable();\n\tpqueue = container_of(parallel_work,\n\t\t\t      struct padata_parallel_queue, work);\n\n\tspin_lock(&pqueue->parallel.lock);\n\tlist_replace_init(&pqueue->parallel.list, &local_list);\n\tspin_unlock(&pqueue->parallel.lock);\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct padata_priv *padata;\n\n\t\tpadata = list_entry(local_list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\n\t\tpadata->parallel(padata);\n\t}\n\n\tlocal_bh_enable();\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata->parallel",
          "args": [
            "padata"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&padata->list"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "local_list.next",
            "structpadata_priv",
            "list"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&local_list"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pqueue->parallel.lock"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&pqueue->parallel.list",
            "&local_list"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pqueue->parallel.lock"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "parallel_work",
            "structpadata_parallel_queue",
            "work"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "local_list"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic void padata_parallel_worker(struct work_struct *parallel_work)\n{\n\tstruct padata_parallel_queue *pqueue;\n\tLIST_HEAD(local_list);\n\n\tlocal_bh_disable();\n\tpqueue = container_of(parallel_work,\n\t\t\t      struct padata_parallel_queue, work);\n\n\tspin_lock(&pqueue->parallel.lock);\n\tlist_replace_init(&pqueue->parallel.list, &local_list);\n\tspin_unlock(&pqueue->parallel.lock);\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct padata_priv *padata;\n\n\t\tpadata = list_entry(local_list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\n\t\tpadata->parallel(padata);\n\t}\n\n\tlocal_bh_enable();\n}"
  },
  {
    "function_name": "padata_cpu_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "49-63",
    "snippet": "static int padata_cpu_hash(struct parallel_data *pd)\n{\n\tunsigned int seq_nr;\n\tint cpu_index;\n\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\n\tseq_nr = atomic_inc_return(&pd->seq_nr);\n\tcpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_index_to_cpu",
          "args": [
            "pd",
            "cpu_index"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "padata_index_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
          "lines": "38-47",
          "snippet": "static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&pd->seq_nr"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_cpu_hash(struct parallel_data *pd)\n{\n\tunsigned int seq_nr;\n\tint cpu_index;\n\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\n\tseq_nr = atomic_inc_return(&pd->seq_nr);\n\tcpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}"
  },
  {
    "function_name": "padata_index_to_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/padata.c",
    "lines": "38-47",
    "snippet": "static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "target_cpu",
            "pd->cpumask.pcpu"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n\nstatic int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}"
  }
]