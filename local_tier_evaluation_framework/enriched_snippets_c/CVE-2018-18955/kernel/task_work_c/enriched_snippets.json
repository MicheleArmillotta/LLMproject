[
  {
    "function_name": "task_work_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/task_work.c",
    "lines": "90-118",
    "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\tdo {\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\thead = !work && (task->flags & PF_EXITING) ?\n\t\t\t\t&work_exited : NULL;\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (!work)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
    "includes": [
      "#include <linux/tracehook.h>",
      "#include <linux/task_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callback_head work_exited;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "work->func",
          "args": [
            "work"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&task->pi_lock"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&task->task_works",
            "work",
            "head"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "task->task_works"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&task->pi_lock"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/tracehook.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\tdo {\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\thead = !work && (task->flags & PF_EXITING) ?\n\t\t\t\t&work_exited : NULL;\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (!work)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
  },
  {
    "function_name": "task_work_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/task_work.c",
    "lines": "55-80",
    "snippet": "struct callback_head *\ntask_work_cancel(struct task_struct *task, task_work_func_t func)\n{\n\tstruct callback_head **pprev = &task->task_works;\n\tstruct callback_head *work;\n\tunsigned long flags;\n\n\tif (likely(!task->task_works))\n\t\treturn NULL;\n\t/*\n\t * If cmpxchg() fails we continue without updating pprev.\n\t * Either we raced with task_work_add() which added the\n\t * new entry before this work, we will find it again. Or\n\t * we raced with task_work_run(), *pprev == NULL/exited.\n\t */\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\twhile ((work = READ_ONCE(*pprev))) {\n\t\tif (work->func != func)\n\t\t\tpprev = &work->next;\n\t\telse if (cmpxchg(pprev, work, work->next) == work)\n\t\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\treturn work;\n}",
    "includes": [
      "#include <linux/tracehook.h>",
      "#include <linux/task_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&task->pi_lock",
            "flags"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "pprev",
            "work",
            "work->next"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pprev"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&task->pi_lock",
            "flags"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!task->task_works"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracehook.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstruct callback_head *\ntask_work_cancel(struct task_struct *task, task_work_func_t func)\n{\n\tstruct callback_head **pprev = &task->task_works;\n\tstruct callback_head *work;\n\tunsigned long flags;\n\n\tif (likely(!task->task_works))\n\t\treturn NULL;\n\t/*\n\t * If cmpxchg() fails we continue without updating pprev.\n\t * Either we raced with task_work_add() which added the\n\t * new entry before this work, we will find it again. Or\n\t * we raced with task_work_run(), *pprev == NULL/exited.\n\t */\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\twhile ((work = READ_ONCE(*pprev))) {\n\t\tif (work->func != func)\n\t\t\tpprev = &work->next;\n\t\telse if (cmpxchg(pprev, work, work->next) == work)\n\t\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\treturn work;\n}"
  },
  {
    "function_name": "task_work_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/task_work.c",
    "lines": "27-42",
    "snippet": "int\ntask_work_add(struct task_struct *task, struct callback_head *work, bool notify)\n{\n\tstruct callback_head *head;\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tif (notify)\n\t\tset_notify_resume(task);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/tracehook.h>",
      "#include <linux/task_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callback_head work_exited;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_notify_resume",
          "args": [
            "task"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&task->task_works",
            "head",
            "work"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head == &work_exited"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "task->task_works"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracehook.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nint\ntask_work_add(struct task_struct *task, struct callback_head *work, bool notify)\n{\n\tstruct callback_head *head;\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tif (notify)\n\t\tset_notify_resume(task);\n\treturn 0;\n}"
  }
]