[
  {
    "function_name": "init_timer_list_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "373-382",
    "snippet": "static int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create_seq_private(\"timer_list\", 0400, NULL, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter), NULL);\n\tif (!pe)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations timer_list_sops = {\n\t.start = timer_list_start,\n\t.next = timer_list_next,\n\t.stop = timer_list_stop,\n\t.show = timer_list_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq_private",
          "args": [
            "\"timer_list\"",
            "0400",
            "NULL",
            "&timer_list_sops",
            "sizeof(struct timer_list_iter)",
            "NULL"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic const struct seq_operations timer_list_sops = {\n\t.start = timer_list_start,\n\t.next = timer_list_next,\n\t.stop = timer_list_stop,\n\t.show = timer_list_show,\n};\n\nstatic int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create_seq_private(\"timer_list\", 0400, NULL, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter), NULL);\n\tif (!pe)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "timer_list_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "362-364",
    "snippet": "static void timer_list_stop(struct seq_file *seq, void *v)\n{\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_stop(struct seq_file *seq, void *v)\n{\n}"
  },
  {
    "function_name": "timer_list_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "355-360",
    "snippet": "static void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_iter",
          "args": [
            "iter",
            "1"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "move_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "325-342",
          "snippet": "static void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}"
  },
  {
    "function_name": "timer_list_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "344-353",
    "snippet": "static void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_iter",
          "args": [
            "iter",
            "*offset"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "move_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "325-342",
          "snippet": "static void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}"
  },
  {
    "function_name": "move_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "325-342",
    "snippet": "static void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "iter->cpu",
            "cpu_online_mask"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}"
  },
  {
    "function_name": "sysrq_timer_list_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "307-323",
    "snippet": "void sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_list_show_tickdevices_header",
          "args": [
            "NULL"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_show_tickdevices_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "267-279",
          "snippet": "static void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_list_header",
          "args": [
            "NULL",
            "now"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "282-288",
          "snippet": "static inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.8\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.8\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nvoid sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}"
  },
  {
    "function_name": "timer_list_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "290-305",
    "snippet": "static int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_list_show_tickdevices_header",
          "args": [
            "m"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_show_tickdevices_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "267-279",
          "snippet": "static void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cpu",
          "args": [
            "m",
            "iter->cpu",
            "iter->now"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "135-194",
          "snippet": "static void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_list_header",
          "args": [
            "m",
            "iter->now"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "282-288",
          "snippet": "static inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.8\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.8\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "timer_list_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "282-288",
    "snippet": "static inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.8\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.8\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "timer_list_show_tickdevices_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "267-279",
    "snippet": "static void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "tick_get_broadcast_oneshot_mask()"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_oneshot_mask",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_oneshot_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "527-530",
          "snippet": "struct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "tick_get_broadcast_mask()"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_mask",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "57-60",
          "snippet": "struct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstruct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_tickdevice",
          "args": [
            "m",
            "tick_get_broadcast_device()",
            "-1"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "print_tickdevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "197-265",
          "snippet": "static void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: \");\n\tprint_name_offset(m, dev->set_next_event);\n\tSEQ_printf(m, \"\\n\");\n\n\tif (dev->set_state_shutdown) {\n\t\tSEQ_printf(m, \" shutdown: \");\n\t\tprint_name_offset(m, dev->set_state_shutdown);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_periodic) {\n\t\tSEQ_printf(m, \" periodic: \");\n\t\tprint_name_offset(m, dev->set_state_periodic);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot) {\n\t\tSEQ_printf(m, \" oneshot:  \");\n\t\tprint_name_offset(m, dev->set_state_oneshot);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot_stopped) {\n\t\tSEQ_printf(m, \" oneshot stopped: \");\n\t\tprint_name_offset(m, dev->set_state_oneshot_stopped);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->tick_resume) {\n\t\tSEQ_printf(m, \" resume:   \");\n\t\tprint_name_offset(m, dev->tick_resume);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tSEQ_printf(m, \" event_handler:  \");\n\tprint_name_offset(m, dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: \");\n\tprint_name_offset(m, dev->set_next_event);\n\tSEQ_printf(m, \"\\n\");\n\n\tif (dev->set_state_shutdown) {\n\t\tSEQ_printf(m, \" shutdown: \");\n\t\tprint_name_offset(m, dev->set_state_shutdown);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_periodic) {\n\t\tSEQ_printf(m, \" periodic: \");\n\t\tprint_name_offset(m, dev->set_state_periodic);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot) {\n\t\tSEQ_printf(m, \" oneshot:  \");\n\t\tprint_name_offset(m, dev->set_state_oneshot);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot_stopped) {\n\t\tSEQ_printf(m, \" oneshot stopped: \");\n\t\tprint_name_offset(m, dev->set_state_oneshot_stopped);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->tick_resume) {\n\t\tSEQ_printf(m, \" resume:   \");\n\t\tprint_name_offset(m, dev->tick_resume);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tSEQ_printf(m, \" event_handler:  \");\n\tprint_name_offset(m, dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_device",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "52-55",
          "snippet": "struct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstruct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}"
  },
  {
    "function_name": "print_tickdevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "197-265",
    "snippet": "static void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: \");\n\tprint_name_offset(m, dev->set_next_event);\n\tSEQ_printf(m, \"\\n\");\n\n\tif (dev->set_state_shutdown) {\n\t\tSEQ_printf(m, \" shutdown: \");\n\t\tprint_name_offset(m, dev->set_state_shutdown);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_periodic) {\n\t\tSEQ_printf(m, \" periodic: \");\n\t\tprint_name_offset(m, dev->set_state_periodic);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot) {\n\t\tSEQ_printf(m, \" oneshot:  \");\n\t\tprint_name_offset(m, dev->set_state_oneshot);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot_stopped) {\n\t\tSEQ_printf(m, \" oneshot stopped: \");\n\t\tprint_name_offset(m, dev->set_state_oneshot_stopped);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->tick_resume) {\n\t\tSEQ_printf(m, \" resume:   \");\n\t\tprint_name_offset(m, dev->tick_resume);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tSEQ_printf(m, \" event_handler:  \");\n\tprint_name_offset(m, dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_name_offset",
          "args": [
            "m",
            "dev->event_handler"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "print_name_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "50-58",
          "snippet": "static void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "dev->next_event"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "40-43",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: \");\n\tprint_name_offset(m, dev->set_next_event);\n\tSEQ_printf(m, \"\\n\");\n\n\tif (dev->set_state_shutdown) {\n\t\tSEQ_printf(m, \" shutdown: \");\n\t\tprint_name_offset(m, dev->set_state_shutdown);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_periodic) {\n\t\tSEQ_printf(m, \" periodic: \");\n\t\tprint_name_offset(m, dev->set_state_periodic);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot) {\n\t\tSEQ_printf(m, \" oneshot:  \");\n\t\tprint_name_offset(m, dev->set_state_oneshot);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->set_state_oneshot_stopped) {\n\t\tSEQ_printf(m, \" oneshot stopped: \");\n\t\tprint_name_offset(m, dev->set_state_oneshot_stopped);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tif (dev->tick_resume) {\n\t\tSEQ_printf(m, \" resume:   \");\n\t\tprint_name_offset(m, dev->tick_resume);\n\t\tSEQ_printf(m, \"\\n\");\n\t}\n\n\tSEQ_printf(m, \" event_handler:  \");\n\tprint_name_offset(m, dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "print_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "135-194",
    "snippet": "static void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_expires"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "next_timer"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "last_jiffies"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "iowait_sleeptime"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_sleeptime"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_exittime"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_waketime"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_entrytime"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "idle_sleeps"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "idle_calls"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "idle_jiffies"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "tick_stopped"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "last_tick"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nohz_mode"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_tick_sched",
          "args": [
            "cpu"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_tick_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "43-46",
          "snippet": "struct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstruct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "max_hang_time"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_hangs"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_retries"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_events"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "hres_active"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "expires_next"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_base",
          "args": [
            "m",
            "cpu_base->clock_base + i",
            "now"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "print_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "116-133",
          "snippet": "static void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   \");\n\tprint_name_offset(m, base->get_time);\n\tSEQ_printf(m,   \"\\n\");\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   \");\n\tprint_name_offset(m, base->get_time);\n\tSEQ_printf(m,   \"\\n\");\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "cpu"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "print_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "116-133",
    "snippet": "static void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   \");\n\tprint_name_offset(m, base->get_time);\n\tSEQ_printf(m,   \"\\n\");\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_active_timers",
          "args": [
            "m",
            "base",
            "now + ktime_to_ns(base->offset)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "print_active_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "77-114",
          "snippet": "static void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "base->offset"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"active timers:\\n\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "base->offset"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_name_offset",
          "args": [
            "m",
            "base->get_time"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "print_name_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "50-58",
          "snippet": "static void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   \");\n\tprint_name_offset(m, base->get_time);\n\tSEQ_printf(m,   \"\\n\");\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}"
  },
  {
    "function_name": "print_active_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "77-114",
    "snippet": "static void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->cpu_base->lock",
            "flags"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_timer",
          "args": [
            "m",
            "timer",
            "&tmp",
            "i",
            "now"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "print_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "60-75",
          "snippet": "static void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "curr",
            "structhrtimer",
            "node"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_iterate_next",
          "args": [
            "curr"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->cpu_base->lock",
            "flags"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}"
  },
  {
    "function_name": "print_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "60-75",
    "snippet": "static void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\"",
            "(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer))",
            "(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer))",
            "(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now)",
            "(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now)"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_expires(timer)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_softexpires(timer)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_softexpires",
          "args": [
            "timer"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_expires(timer)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_softexpires(timer)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_softexpires",
          "args": [
            "timer"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_name_offset",
          "args": [
            "m",
            "timer->function"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "print_name_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "50-58",
          "snippet": "static void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}"
  },
  {
    "function_name": "print_name_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "50-58",
    "snippet": "static void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"%s\"",
            "symname"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
          "lines": "36-48",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_symbol_name",
          "args": [
            "(unsigned long)sym",
            "symname"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_symbol_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "313-329",
          "snippet": "int lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\treturn 0;\n\t}\n\t/* See if it's in a module. */\n\treturn lookup_module_symbol_name(addr, symname);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\treturn 0;\n\t}\n\t/* See if it's in a module. */\n\treturn lookup_module_symbol_name(addr, symname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_name_offset(struct seq_file *m, void *sym)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name((unsigned long)sym, symname) < 0)\n\t\tSEQ_printf(m, \"<%pK>\", sym);\n\telse\n\t\tSEQ_printf(m, \"%s\", symname);\n}"
  },
  {
    "function_name": "SEQ_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer_list.c",
    "lines": "36-48",
    "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "fmt",
            "args"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/internal.h",
          "lines": "66-66",
          "snippet": "int vprintk_func(const char *fmt, va_list args) { return 0; }",
          "includes": [
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu.h>\n\nint vprintk_func(const char *fmt, va_list args) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "seq_vprintf",
          "args": [
            "m",
            "fmt",
            "args"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "144-160",
          "snippet": "void trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
  }
]