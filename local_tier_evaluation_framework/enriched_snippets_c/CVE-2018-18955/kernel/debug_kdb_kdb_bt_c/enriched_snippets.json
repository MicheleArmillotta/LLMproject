[
  {
    "function_name": "kdb_bt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "105-211",
    "snippet": "int\nkdb_bt(int argc, const char **argv)\n{\n\tint diag;\n\tint argcount = 5;\n\tint btaprompt = 1;\n\tint nextarg;\n\tunsigned long addr;\n\tlong offset;\n\n\t/* Prompt after each proc in bta */\n\tkdbgetintenv(\"BTAPROMPT\", &btaprompt);\n\n\tif (strcmp(argv[0], \"bta\") == 0) {\n\t\tstruct task_struct *g, *p;\n\t\tunsigned long cpu;\n\t\tunsigned long mask = kdb_task_state_string(argc ? argv[1] :\n\t\t\t\t\t\t\t   NULL);\n\t\tif (argc == 0)\n\t\t\tkdb_ps_suppressed();\n\t\t/* Run the active tasks first */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tp = kdb_curr_task(cpu);\n\t\t\tif (kdb_bt1(p, mask, argcount, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Now the inactive tasks */\n\t\tkdb_do_each_thread(g, p) {\n\t\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\t\treturn 0;\n\t\t\tif (task_curr(p))\n\t\t\t\tcontinue;\n\t\t\tif (kdb_bt1(p, mask, argcount, btaprompt))\n\t\t\t\treturn 0;\n\t\t} kdb_while_each_thread(g, p);\n\t} else if (strcmp(argv[0], \"btp\") == 0) {\n\t\tstruct task_struct *p;\n\t\tunsigned long pid;\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &pid);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\tif (p) {\n\t\t\tkdb_set_current_task(p);\n\t\t\treturn kdb_bt1(p, ~0UL, argcount, 0);\n\t\t}\n\t\tkdb_printf(\"No process with pid == %ld found\\n\", pid);\n\t\treturn 0;\n\t} else if (strcmp(argv[0], \"btt\") == 0) {\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tkdb_set_current_task((struct task_struct *)addr);\n\t\treturn kdb_bt1((struct task_struct *)addr, ~0UL, argcount, 0);\n\t} else if (strcmp(argv[0], \"btc\") == 0) {\n\t\tunsigned long cpu = ~0;\n\t\tstruct task_struct *save_current_task = kdb_current_task;\n\t\tchar buf[80];\n\t\tif (argc > 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tif (argc == 1) {\n\t\t\tdiag = kdbgetularg((char *)argv[1], &cpu);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t\t/* Recursive use of kdb_parse, do not use argv after\n\t\t * this point */\n\t\targv = NULL;\n\t\tif (cpu != ~0) {\n\t\t\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\t\t\tkdb_printf(\"no process for cpu %ld\\n\", cpu);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsprintf(buf, \"btt 0x%p\\n\", KDB_TSK(cpu));\n\t\t\tkdb_parse(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_printf(\"btc: cpu status: \");\n\t\tkdb_parse(\"cpu\\n\");\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tsprintf(buf, \"btt 0x%p\\n\", KDB_TSK(cpu));\n\t\t\tkdb_parse(buf);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t\tkdb_set_current_task(save_current_task);\n\t\treturn 0;\n\t} else {\n\t\tif (argc) {\n\t\t\tnextarg = 1;\n\t\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t\t     &offset, NULL);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t\tkdb_show_stack(kdb_current_task, (void *)addr);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn kdb_bt1(kdb_current_task, ~0UL, argcount, 0);\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_bt1",
          "args": [
            "kdb_current_task",
            "~0UL",
            "argcount",
            "0"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bt1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "80-103",
          "snippet": "static int\nkdb_bt1(struct task_struct *p, unsigned long mask,\n\tint argcount, int btaprompt)\n{\n\tchar buffer[2];\n\tif (kdb_getarea(buffer[0], (unsigned long)p) ||\n\t    kdb_getarea(buffer[0], (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_getstr(buffer, sizeof(buffer),\n\t\t\t   \"Enter <q> to end, <cr> to continue:\");\n\t\tif (buffer[0] == 'q') {\n\t\t\tkdb_printf(\"\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic int\nkdb_bt1(struct task_struct *p, unsigned long mask,\n\tint argcount, int btaprompt)\n{\n\tchar buffer[2];\n\tif (kdb_getarea(buffer[0], (unsigned long)p) ||\n\t    kdb_getarea(buffer[0], (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_getstr(buffer, sizeof(buffer),\n\t\t\t   \"Enter <q> to end, <cr> to continue:\");\n\t\tif (buffer[0] == 'q') {\n\t\t\tkdb_printf(\"\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_show_stack",
          "args": [
            "kdb_current_task",
            "(void *)addr"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-41",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_set_current_task",
          "args": [
            "save_current_task"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_set_current_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1142-1151",
          "snippet": "void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *kdb_current_task;",
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nvoid kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "buf"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "911-1091",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"btt 0x%p\\n\"",
            "KDB_TSK(cpu)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"btc: cpu status: \""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"btt 0x%p\\n\"",
            "KDB_TSK(cpu)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "(char *)argv[1]",
            "&cpu"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"btc\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"btt\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "pid",
            "&init_pid_ns"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "341-346",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"btp\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_while_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "p"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "816-819",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_do_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "cpu"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "190-198",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_ps_suppressed",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps_suppressed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2301-2328",
          "snippet": "void kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long mask_I = kdb_task_state_string(\"I\"),\n\t\t      mask_M = kdb_task_state_string(\"M\");\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask_I))\n\t\t\t++idle;\n\t}\n\tkdb_do_each_thread(g, p) {\n\t\tif (kdb_task_state(p, mask_M))\n\t\t\t++daemon;\n\t} kdb_while_each_thread(g, p);\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state I)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state M) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long mask_I = kdb_task_state_string(\"I\"),\n\t\t      mask_M = kdb_task_state_string(\"M\");\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask_I))\n\t\t\t++idle;\n\t}\n\tkdb_do_each_thread(g, p) {\n\t\tif (kdb_task_state(p, mask_M))\n\t\t\t++daemon;\n\t} kdb_while_each_thread(g, p);\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state I)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state M) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state_string",
          "args": [
            "argc ? argv[1] :\n\t\t\t\t\t\t\t   NULL"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "561-612",
          "snippet": "unsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))",
            "#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))",
            "#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))",
            "#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))\n#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))\n#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))\n#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"bta\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"BTAPROMPT\"",
            "&btaprompt"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "316-325",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nint\nkdb_bt(int argc, const char **argv)\n{\n\tint diag;\n\tint argcount = 5;\n\tint btaprompt = 1;\n\tint nextarg;\n\tunsigned long addr;\n\tlong offset;\n\n\t/* Prompt after each proc in bta */\n\tkdbgetintenv(\"BTAPROMPT\", &btaprompt);\n\n\tif (strcmp(argv[0], \"bta\") == 0) {\n\t\tstruct task_struct *g, *p;\n\t\tunsigned long cpu;\n\t\tunsigned long mask = kdb_task_state_string(argc ? argv[1] :\n\t\t\t\t\t\t\t   NULL);\n\t\tif (argc == 0)\n\t\t\tkdb_ps_suppressed();\n\t\t/* Run the active tasks first */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tp = kdb_curr_task(cpu);\n\t\t\tif (kdb_bt1(p, mask, argcount, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Now the inactive tasks */\n\t\tkdb_do_each_thread(g, p) {\n\t\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\t\treturn 0;\n\t\t\tif (task_curr(p))\n\t\t\t\tcontinue;\n\t\t\tif (kdb_bt1(p, mask, argcount, btaprompt))\n\t\t\t\treturn 0;\n\t\t} kdb_while_each_thread(g, p);\n\t} else if (strcmp(argv[0], \"btp\") == 0) {\n\t\tstruct task_struct *p;\n\t\tunsigned long pid;\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &pid);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\tif (p) {\n\t\t\tkdb_set_current_task(p);\n\t\t\treturn kdb_bt1(p, ~0UL, argcount, 0);\n\t\t}\n\t\tkdb_printf(\"No process with pid == %ld found\\n\", pid);\n\t\treturn 0;\n\t} else if (strcmp(argv[0], \"btt\") == 0) {\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tkdb_set_current_task((struct task_struct *)addr);\n\t\treturn kdb_bt1((struct task_struct *)addr, ~0UL, argcount, 0);\n\t} else if (strcmp(argv[0], \"btc\") == 0) {\n\t\tunsigned long cpu = ~0;\n\t\tstruct task_struct *save_current_task = kdb_current_task;\n\t\tchar buf[80];\n\t\tif (argc > 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tif (argc == 1) {\n\t\t\tdiag = kdbgetularg((char *)argv[1], &cpu);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t\t/* Recursive use of kdb_parse, do not use argv after\n\t\t * this point */\n\t\targv = NULL;\n\t\tif (cpu != ~0) {\n\t\t\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\t\t\tkdb_printf(\"no process for cpu %ld\\n\", cpu);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsprintf(buf, \"btt 0x%p\\n\", KDB_TSK(cpu));\n\t\t\tkdb_parse(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_printf(\"btc: cpu status: \");\n\t\tkdb_parse(\"cpu\\n\");\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tsprintf(buf, \"btt 0x%p\\n\", KDB_TSK(cpu));\n\t\t\tkdb_parse(buf);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t\tkdb_set_current_task(save_current_task);\n\t\treturn 0;\n\t} else {\n\t\tif (argc) {\n\t\t\tnextarg = 1;\n\t\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t\t     &offset, NULL);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t\tkdb_show_stack(kdb_current_task, (void *)addr);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn kdb_bt1(kdb_current_task, ~0UL, argcount, 0);\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_bt1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "80-103",
    "snippet": "static int\nkdb_bt1(struct task_struct *p, unsigned long mask,\n\tint argcount, int btaprompt)\n{\n\tchar buffer[2];\n\tif (kdb_getarea(buffer[0], (unsigned long)p) ||\n\t    kdb_getarea(buffer[0], (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_getstr(buffer, sizeof(buffer),\n\t\t\t   \"Enter <q> to end, <cr> to continue:\");\n\t\tif (buffer[0] == 'q') {\n\t\t\tkdb_printf(\"\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getstr",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"Enter <q> to end, <cr> to continue:\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "443-450",
          "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_show_stack",
          "args": [
            "p",
            "NULL"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-41",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_ps1",
          "args": [
            "p"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2335-2360",
          "snippet": "void kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state",
          "args": [
            "p",
            "mask"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "661-665",
          "snippet": "unsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nunsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "buffer[0]",
            "(unsigned long)(p+1)-1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "buffer[0]",
            "(unsigned long)p"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic int\nkdb_bt1(struct task_struct *p, unsigned long mask,\n\tint argcount, int btaprompt)\n{\n\tchar buffer[2];\n\tif (kdb_getarea(buffer[0], (unsigned long)p) ||\n\t    kdb_getarea(buffer[0], (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_getstr(buffer, sizeof(buffer),\n\t\t\t   \"Enter <q> to end, <cr> to continue:\");\n\t\tif (buffer[0] == 'q') {\n\t\t\tkdb_printf(\"\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_show_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
    "lines": "22-41",
    "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_stack",
          "args": [
            "p",
            "NULL"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-41",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kdb_set_current_task",
          "args": [
            "p"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_set_current_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1142-1151",
          "snippet": "void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *kdb_current_task;",
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nvoid kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}"
  }
]