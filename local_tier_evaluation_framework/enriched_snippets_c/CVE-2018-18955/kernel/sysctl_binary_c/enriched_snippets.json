[
  {
    "function_name": "do_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1382-1399",
    "snippet": "static ssize_t do_sysctl(int __user *args_name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tint name[CTL_MAXNAME];\n\tint i;\n\n\t/* Check args->nlen. */\n\tif (nlen < 0 || nlen > CTL_MAXNAME)\n\t\treturn -ENOTDIR;\n\t/* Read in the sysctl name for simplicity */\n\tfor (i = 0; i < nlen; i++)\n\t\tif (get_user(name[i], args_name + i))\n\t\t\treturn -EFAULT;\n\n\twarn_on_bintable(name, nlen);\n\n\treturn binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "binary_sysctl",
          "args": [
            "name",
            "nlen",
            "oldval",
            "oldlen",
            "newval",
            "newlen"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "binary_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
          "lines": "1322-1326",
          "snippet": "static ssize_t binary_sysctl(const int *name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/ctype.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/string.h>",
            "#include <linux/sunrpc/debug.h>",
            "#include \"../fs/xfs/xfs_sysctl.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t binary_sysctl(const int *name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_on_bintable",
          "args": [
            "name",
            "nlen"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "warn_on_bintable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
          "lines": "1369-1380",
          "snippet": "static void warn_on_bintable(const int *name, int nlen)\n{\n\tint i;\n\tu32 hash = FNV32_OFFSET;\n\n\tfor (i = 0; i < nlen; i++)\n\t\thash = (hash ^ name[i]) * FNV32_PRIME;\n\thash %= WARN_ONCE_HASH_SIZE;\n\tif (__test_and_set_bit(hash, warn_once_bitmap))\n\t\treturn;\n\tdeprecated_sysctl_warning(name, nlen);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/ctype.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/string.h>",
            "#include <linux/sunrpc/debug.h>",
            "#include \"../fs/xfs/xfs_sysctl.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [
            "#define FNV32_PRIME 0x01000193",
            "#define FNV32_OFFSET 2166136261U",
            "#define WARN_ONCE_HASH_SIZE (1<<WARN_ONCE_HASH_BITS)"
          ],
          "globals_used": [
            "static DECLARE_BITMAP(warn_once_bitmap, WARN_ONCE_HASH_SIZE);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\n#define FNV32_PRIME 0x01000193\n#define FNV32_OFFSET 2166136261U\n#define WARN_ONCE_HASH_SIZE (1<<WARN_ONCE_HASH_BITS)\n\nstatic DECLARE_BITMAP(warn_once_bitmap, WARN_ONCE_HASH_SIZE);\n\nstatic void warn_on_bintable(const int *name, int nlen)\n{\n\tint i;\n\tu32 hash = FNV32_OFFSET;\n\n\tfor (i = 0; i < nlen; i++)\n\t\thash = (hash ^ name[i]) * FNV32_PRIME;\n\thash %= WARN_ONCE_HASH_SIZE;\n\tif (__test_and_set_bit(hash, warn_once_bitmap))\n\t\treturn;\n\tdeprecated_sysctl_warning(name, nlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "name[i]",
            "args_name + i"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t do_sysctl(int __user *args_name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tint name[CTL_MAXNAME];\n\tint i;\n\n\t/* Check args->nlen. */\n\tif (nlen < 0 || nlen > CTL_MAXNAME)\n\t\treturn -ENOTDIR;\n\t/* Read in the sysctl name for simplicity */\n\tfor (i = 0; i < nlen; i++)\n\t\tif (get_user(name[i], args_name + i))\n\t\t\treturn -EFAULT;\n\n\twarn_on_bintable(name, nlen);\n\n\treturn binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);\n}"
  },
  {
    "function_name": "warn_on_bintable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1369-1380",
    "snippet": "static void warn_on_bintable(const int *name, int nlen)\n{\n\tint i;\n\tu32 hash = FNV32_OFFSET;\n\n\tfor (i = 0; i < nlen; i++)\n\t\thash = (hash ^ name[i]) * FNV32_PRIME;\n\thash %= WARN_ONCE_HASH_SIZE;\n\tif (__test_and_set_bit(hash, warn_once_bitmap))\n\t\treturn;\n\tdeprecated_sysctl_warning(name, nlen);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [
      "#define FNV32_PRIME 0x01000193",
      "#define FNV32_OFFSET 2166136261U",
      "#define WARN_ONCE_HASH_SIZE (1<<WARN_ONCE_HASH_BITS)"
    ],
    "globals_used": [
      "static DECLARE_BITMAP(warn_once_bitmap, WARN_ONCE_HASH_SIZE);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deprecated_sysctl_warning",
          "args": [
            "name",
            "nlen"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "deprecated_sysctl_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
          "lines": "1331-1351",
          "snippet": "static void deprecated_sysctl_warning(const int *name, int nlen)\n{\n\tint i;\n\n\t/*\n\t * CTL_KERN/KERN_VERSION is used by older glibc and cannot\n\t * ever go away.\n\t */\n\tif (nlen >= 2 && name[0] == CTL_KERN && name[1] == KERN_VERSION)\n\t\treturn;\n\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_INFO\n\t\t\t\"warning: process `%s' used the deprecated sysctl \"\n\t\t\t\"system call with \", current->comm);\n\t\tfor (i = 0; i < nlen; i++)\n\t\t\tprintk(KERN_CONT \"%d.\", name[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\treturn;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/ctype.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/string.h>",
            "#include <linux/sunrpc/debug.h>",
            "#include \"../fs/xfs/xfs_sysctl.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic void deprecated_sysctl_warning(const int *name, int nlen)\n{\n\tint i;\n\n\t/*\n\t * CTL_KERN/KERN_VERSION is used by older glibc and cannot\n\t * ever go away.\n\t */\n\tif (nlen >= 2 && name[0] == CTL_KERN && name[1] == KERN_VERSION)\n\t\treturn;\n\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_INFO\n\t\t\t\"warning: process `%s' used the deprecated sysctl \"\n\t\t\t\"system call with \", current->comm);\n\t\tfor (i = 0; i < nlen; i++)\n\t\t\tprintk(KERN_CONT \"%d.\", name[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "hash",
            "warn_once_bitmap"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\n#define FNV32_PRIME 0x01000193\n#define FNV32_OFFSET 2166136261U\n#define WARN_ONCE_HASH_SIZE (1<<WARN_ONCE_HASH_BITS)\n\nstatic DECLARE_BITMAP(warn_once_bitmap, WARN_ONCE_HASH_SIZE);\n\nstatic void warn_on_bintable(const int *name, int nlen)\n{\n\tint i;\n\tu32 hash = FNV32_OFFSET;\n\n\tfor (i = 0; i < nlen; i++)\n\t\thash = (hash ^ name[i]) * FNV32_PRIME;\n\thash %= WARN_ONCE_HASH_SIZE;\n\tif (__test_and_set_bit(hash, warn_once_bitmap))\n\t\treturn;\n\tdeprecated_sysctl_warning(name, nlen);\n}"
  },
  {
    "function_name": "deprecated_sysctl_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1331-1351",
    "snippet": "static void deprecated_sysctl_warning(const int *name, int nlen)\n{\n\tint i;\n\n\t/*\n\t * CTL_KERN/KERN_VERSION is used by older glibc and cannot\n\t * ever go away.\n\t */\n\tif (nlen >= 2 && name[0] == CTL_KERN && name[1] == KERN_VERSION)\n\t\treturn;\n\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_INFO\n\t\t\t\"warning: process `%s' used the deprecated sysctl \"\n\t\t\t\"system call with \", current->comm);\n\t\tfor (i = 0; i < nlen; i++)\n\t\t\tprintk(KERN_CONT \"%d.\", name[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\treturn;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%d.\"",
            "name[i]"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic void deprecated_sysctl_warning(const int *name, int nlen)\n{\n\tint i;\n\n\t/*\n\t * CTL_KERN/KERN_VERSION is used by older glibc and cannot\n\t * ever go away.\n\t */\n\tif (nlen >= 2 && name[0] == CTL_KERN && name[1] == KERN_VERSION)\n\t\treturn;\n\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_INFO\n\t\t\t\"warning: process `%s' used the deprecated sysctl \"\n\t\t\t\"system call with \", current->comm);\n\t\tfor (i = 0; i < nlen; i++)\n\t\t\tprintk(KERN_CONT \"%d.\", name[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "binary_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1322-1326",
    "snippet": "static ssize_t binary_sysctl(const int *name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t binary_sysctl(const int *name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "binary_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1277-1317",
    "snippet": "static ssize_t binary_sysctl(const int *name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tconst struct bin_table *table = NULL;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t result;\n\tchar *pathname;\n\tint flags;\n\n\tpathname = sysctl_getname(name, nlen, &table);\n\tresult = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\n\t/* How should the sysctl be accessed? */\n\tif (oldval && oldlen && newval && newlen) {\n\t\tflags = O_RDWR;\n\t} else if (newval && newlen) {\n\t\tflags = O_WRONLY;\n\t} else if (oldval && oldlen) {\n\t\tflags = O_RDONLY;\n\t} else {\n\t\tresult = 0;\n\t\tgoto out_putname;\n\t}\n\n\tmnt = task_active_pid_ns(current)->proc_mnt;\n\tfile = file_open_root(mnt->mnt_root, mnt, pathname, flags, 0);\n\tresult = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_putname;\n\n\tresult = table->convert(file, oldval, oldlen, newval, newlen);\n\n\tfput(file);\nout_putname:\n\t__putname(pathname);\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "pathname"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->convert",
          "args": [
            "file",
            "oldval",
            "oldlen",
            "newval",
            "newlen"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_open_root",
          "args": [
            "mnt->mnt_root",
            "mnt",
            "pathname",
            "flags",
            "0"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pathname"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pathname"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_getname",
          "args": [
            "name",
            "nlen",
            "&table"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_getname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
          "lines": "1259-1275",
          "snippet": "static char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)\n{\n\tchar *tmp, *result;\n\n\tresult = ERR_PTR(-ENOMEM);\n\ttmp = __getname();\n\tif (tmp) {\n\t\tconst struct bin_table *table = get_sysctl(name, nlen, tmp);\n\t\tresult = tmp;\n\t\t*tablep = table;\n\t\tif (IS_ERR(table)) {\n\t\t\t__putname(tmp);\n\t\t\tresult = ERR_CAST(table);\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/ctype.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/string.h>",
            "#include <linux/sunrpc/debug.h>",
            "#include \"../fs/xfs/xfs_sysctl.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)\n{\n\tchar *tmp, *result;\n\n\tresult = ERR_PTR(-ENOMEM);\n\ttmp = __getname();\n\tif (tmp) {\n\t\tconst struct bin_table *table = get_sysctl(name, nlen, tmp);\n\t\tresult = tmp;\n\t\t*tablep = table;\n\t\tif (IS_ERR(table)) {\n\t\t\t__putname(tmp);\n\t\t\tresult = ERR_CAST(table);\n\t\t}\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t binary_sysctl(const int *name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tconst struct bin_table *table = NULL;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t result;\n\tchar *pathname;\n\tint flags;\n\n\tpathname = sysctl_getname(name, nlen, &table);\n\tresult = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\n\t/* How should the sysctl be accessed? */\n\tif (oldval && oldlen && newval && newlen) {\n\t\tflags = O_RDWR;\n\t} else if (newval && newlen) {\n\t\tflags = O_WRONLY;\n\t} else if (oldval && oldlen) {\n\t\tflags = O_RDONLY;\n\t} else {\n\t\tresult = 0;\n\t\tgoto out_putname;\n\t}\n\n\tmnt = task_active_pid_ns(current)->proc_mnt;\n\tfile = file_open_root(mnt->mnt_root, mnt, pathname, flags, 0);\n\tresult = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_putname;\n\n\tresult = table->convert(file, oldval, oldlen, newval, newlen);\n\n\tfput(file);\nout_putname:\n\t__putname(pathname);\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "sysctl_getname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1259-1275",
    "snippet": "static char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)\n{\n\tchar *tmp, *result;\n\n\tresult = ERR_PTR(-ENOMEM);\n\ttmp = __getname();\n\tif (tmp) {\n\t\tconst struct bin_table *table = get_sysctl(name, nlen, tmp);\n\t\tresult = tmp;\n\t\t*tablep = table;\n\t\tif (IS_ERR(table)) {\n\t\t\t__putname(tmp);\n\t\t\tresult = ERR_CAST(table);\n\t\t}\n\t}\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "table"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "tmp"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "table"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sysctl",
          "args": [
            "name",
            "nlen",
            "tmp"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "get_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
          "lines": "1204-1257",
          "snippet": "static const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\n{\n\tconst struct bin_table *table = &bin_root_table[0];\n\tint ctl_name;\n\n\t/* The binary sysctl tables have a small maximum depth so\n\t * there is no danger of overflowing our path as it PATH_MAX\n\t * bytes long.\n\t */\n\tmemcpy(path, \"sys/\", 4);\n\tpath += 4;\n\nrepeat:\n\tif (!nlen)\n\t\treturn ERR_PTR(-ENOTDIR);\n\tctl_name = *name;\n\tname++;\n\tnlen--;\n\tfor ( ; table->convert; table++) {\n\t\tint len = 0;\n\n\t\t/*\n\t\t * For a wild card entry map from ifindex to network\n\t\t * device name.\n\t\t */\n\t\tif (!table->ctl_name) {\n#ifdef CONFIG_NET\n\t\t\tstruct net *net = current->nsproxy->net_ns;\n\t\t\tstruct net_device *dev;\n\t\t\tdev = dev_get_by_index(net, ctl_name);\n\t\t\tif (dev) {\n\t\t\t\tlen = strlen(dev->name);\n\t\t\t\tmemcpy(path, dev->name, len);\n\t\t\t\tdev_put(dev);\n\t\t\t}\n#endif\n\t\t/* Use the well known sysctl number to proc name mapping */\n\t\t} else if (ctl_name == table->ctl_name) {\n\t\t\tlen = strlen(table->procname);\n\t\t\tmemcpy(path, table->procname, len);\n\t\t}\n\t\tif (len) {\n\t\t\tpath += len;\n\t\t\tif (table->child) {\n\t\t\t\t*path++ = '/';\n\t\t\t\ttable = table->child;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\t*path = '\\0';\n\t\t\treturn table;\n\t\t}\n\t}\n\treturn ERR_PTR(-ENOTDIR);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/ctype.h>",
            "#include <linux/file.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/string.h>",
            "#include <linux/sunrpc/debug.h>",
            "#include \"../fs/xfs/xfs_sysctl.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\n{\n\tconst struct bin_table *table = &bin_root_table[0];\n\tint ctl_name;\n\n\t/* The binary sysctl tables have a small maximum depth so\n\t * there is no danger of overflowing our path as it PATH_MAX\n\t * bytes long.\n\t */\n\tmemcpy(path, \"sys/\", 4);\n\tpath += 4;\n\nrepeat:\n\tif (!nlen)\n\t\treturn ERR_PTR(-ENOTDIR);\n\tctl_name = *name;\n\tname++;\n\tnlen--;\n\tfor ( ; table->convert; table++) {\n\t\tint len = 0;\n\n\t\t/*\n\t\t * For a wild card entry map from ifindex to network\n\t\t * device name.\n\t\t */\n\t\tif (!table->ctl_name) {\n#ifdef CONFIG_NET\n\t\t\tstruct net *net = current->nsproxy->net_ns;\n\t\t\tstruct net_device *dev;\n\t\t\tdev = dev_get_by_index(net, ctl_name);\n\t\t\tif (dev) {\n\t\t\t\tlen = strlen(dev->name);\n\t\t\t\tmemcpy(path, dev->name, len);\n\t\t\t\tdev_put(dev);\n\t\t\t}\n#endif\n\t\t/* Use the well known sysctl number to proc name mapping */\n\t\t} else if (ctl_name == table->ctl_name) {\n\t\t\tlen = strlen(table->procname);\n\t\t\tmemcpy(path, table->procname, len);\n\t\t}\n\t\tif (len) {\n\t\t\tpath += len;\n\t\t\tif (table->child) {\n\t\t\t\t*path++ = '/';\n\t\t\t\ttable = table->child;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\t*path = '\\0';\n\t\t\treturn table;\n\t\t}\n\t}\n\treturn ERR_PTR(-ENOTDIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)\n{\n\tchar *tmp, *result;\n\n\tresult = ERR_PTR(-ENOMEM);\n\ttmp = __getname();\n\tif (tmp) {\n\t\tconst struct bin_table *table = get_sysctl(name, nlen, tmp);\n\t\tresult = tmp;\n\t\t*tablep = table;\n\t\tif (IS_ERR(table)) {\n\t\t\t__putname(tmp);\n\t\t\tresult = ERR_CAST(table);\n\t\t}\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "get_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1204-1257",
    "snippet": "static const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\n{\n\tconst struct bin_table *table = &bin_root_table[0];\n\tint ctl_name;\n\n\t/* The binary sysctl tables have a small maximum depth so\n\t * there is no danger of overflowing our path as it PATH_MAX\n\t * bytes long.\n\t */\n\tmemcpy(path, \"sys/\", 4);\n\tpath += 4;\n\nrepeat:\n\tif (!nlen)\n\t\treturn ERR_PTR(-ENOTDIR);\n\tctl_name = *name;\n\tname++;\n\tnlen--;\n\tfor ( ; table->convert; table++) {\n\t\tint len = 0;\n\n\t\t/*\n\t\t * For a wild card entry map from ifindex to network\n\t\t * device name.\n\t\t */\n\t\tif (!table->ctl_name) {\n#ifdef CONFIG_NET\n\t\t\tstruct net *net = current->nsproxy->net_ns;\n\t\t\tstruct net_device *dev;\n\t\t\tdev = dev_get_by_index(net, ctl_name);\n\t\t\tif (dev) {\n\t\t\t\tlen = strlen(dev->name);\n\t\t\t\tmemcpy(path, dev->name, len);\n\t\t\t\tdev_put(dev);\n\t\t\t}\n#endif\n\t\t/* Use the well known sysctl number to proc name mapping */\n\t\t} else if (ctl_name == table->ctl_name) {\n\t\t\tlen = strlen(table->procname);\n\t\t\tmemcpy(path, table->procname, len);\n\t\t}\n\t\tif (len) {\n\t\t\tpath += len;\n\t\t\tif (table->child) {\n\t\t\t\t*path++ = '/';\n\t\t\t\ttable = table->child;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\t*path = '\\0';\n\t\t\treturn table;\n\t\t}\n\t}\n\treturn ERR_PTR(-ENOTDIR);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "path",
            "table->procname",
            "len"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "table->procname"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_put",
          "args": [
            "dev"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_get_by_index",
          "args": [
            "net",
            "ctl_name"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\n{\n\tconst struct bin_table *table = &bin_root_table[0];\n\tint ctl_name;\n\n\t/* The binary sysctl tables have a small maximum depth so\n\t * there is no danger of overflowing our path as it PATH_MAX\n\t * bytes long.\n\t */\n\tmemcpy(path, \"sys/\", 4);\n\tpath += 4;\n\nrepeat:\n\tif (!nlen)\n\t\treturn ERR_PTR(-ENOTDIR);\n\tctl_name = *name;\n\tname++;\n\tnlen--;\n\tfor ( ; table->convert; table++) {\n\t\tint len = 0;\n\n\t\t/*\n\t\t * For a wild card entry map from ifindex to network\n\t\t * device name.\n\t\t */\n\t\tif (!table->ctl_name) {\n#ifdef CONFIG_NET\n\t\t\tstruct net *net = current->nsproxy->net_ns;\n\t\t\tstruct net_device *dev;\n\t\t\tdev = dev_get_by_index(net, ctl_name);\n\t\t\tif (dev) {\n\t\t\t\tlen = strlen(dev->name);\n\t\t\t\tmemcpy(path, dev->name, len);\n\t\t\t\tdev_put(dev);\n\t\t\t}\n#endif\n\t\t/* Use the well known sysctl number to proc name mapping */\n\t\t} else if (ctl_name == table->ctl_name) {\n\t\t\tlen = strlen(table->procname);\n\t\t\tmemcpy(path, table->procname, len);\n\t\t}\n\t\tif (len) {\n\t\t\tpath += len;\n\t\t\tif (table->child) {\n\t\t\t\t*path++ = '/';\n\t\t\t\ttable = table->child;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\t*path = '\\0';\n\t\t\treturn table;\n\t\t}\n\t}\n\treturn ERR_PTR(-ENOTDIR);\n}"
  },
  {
    "function_name": "bin_dn_node_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1136-1202",
    "snippet": "static ssize_t bin_dn_node_address(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\tif (oldval && oldlen) {\n\t\tchar buf[15], *nodep;\n\t\tunsigned long area, node;\n\t\t__le16 dnaddr;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buf, sizeof(buf) - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\t/* Convert the decnet address to binary */\n\t\tresult = -EIO;\n\t\tnodep = strchr(buf, '.');\n\t\tif (!nodep)\n\t\t\tgoto out;\n\t\t++nodep;\n\n\t\tarea = simple_strtoul(buf, NULL, 10);\n\t\tnode = simple_strtoul(nodep, NULL, 10);\n\n\t\tresult = -EIO;\n\t\tif ((area > 63)||(node > 1023))\n\t\t\tgoto out;\n\n\t\tdnaddr = cpu_to_le16((area << 10) | node);\n\n\t\tresult = -EFAULT;\n\t\tif (put_user(dnaddr, (__le16 __user *)oldval))\n\t\t\tgoto out;\n\n\t\tcopied = sizeof(dnaddr);\n\t}\n\n\tif (newval && newlen) {\n\t\t__le16 dnaddr;\n\t\tchar buf[15];\n\t\tint len;\n\t\tloff_t pos = 0;\n\n\t\tresult = -EINVAL;\n\t\tif (newlen != sizeof(dnaddr))\n\t\t\tgoto out;\n\n\t\tresult = -EFAULT;\n\t\tif (get_user(dnaddr, (__le16 __user *)newval))\n\t\t\tgoto out;\n\n\t\tlen = scnprintf(buf, sizeof(buf), \"%hu.%hu\",\n\t\t\t\tle16_to_cpu(dnaddr) >> 10,\n\t\t\t\tle16_to_cpu(dnaddr) & 0x3ff);\n\n\t\tresult = kernel_write(file, buf, len, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "file",
            "buf",
            "len",
            "&pos"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%hu.%hu\"",
            "le16_to_cpu(dnaddr) >> 10",
            "le16_to_cpu(dnaddr) & 0x3ff"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dnaddr"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dnaddr"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "dnaddr",
            "(__le16 __user *)newval"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "dnaddr",
            "(__le16 __user *)oldval"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(area << 10) | node"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "nodep",
            "NULL",
            "10"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "NULL",
            "10"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'.'"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "buf",
            "sizeof(buf) - 1",
            "&pos"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t bin_dn_node_address(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\tif (oldval && oldlen) {\n\t\tchar buf[15], *nodep;\n\t\tunsigned long area, node;\n\t\t__le16 dnaddr;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buf, sizeof(buf) - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\t/* Convert the decnet address to binary */\n\t\tresult = -EIO;\n\t\tnodep = strchr(buf, '.');\n\t\tif (!nodep)\n\t\t\tgoto out;\n\t\t++nodep;\n\n\t\tarea = simple_strtoul(buf, NULL, 10);\n\t\tnode = simple_strtoul(nodep, NULL, 10);\n\n\t\tresult = -EIO;\n\t\tif ((area > 63)||(node > 1023))\n\t\t\tgoto out;\n\n\t\tdnaddr = cpu_to_le16((area << 10) | node);\n\n\t\tresult = -EFAULT;\n\t\tif (put_user(dnaddr, (__le16 __user *)oldval))\n\t\t\tgoto out;\n\n\t\tcopied = sizeof(dnaddr);\n\t}\n\n\tif (newval && newlen) {\n\t\t__le16 dnaddr;\n\t\tchar buf[15];\n\t\tint len;\n\t\tloff_t pos = 0;\n\n\t\tresult = -EINVAL;\n\t\tif (newlen != sizeof(dnaddr))\n\t\t\tgoto out;\n\n\t\tresult = -EFAULT;\n\t\tif (get_user(dnaddr, (__le16 __user *)newval))\n\t\t\tgoto out;\n\n\t\tlen = scnprintf(buf, sizeof(buf), \"%hu.%hu\",\n\t\t\t\tle16_to_cpu(dnaddr) >> 10,\n\t\t\t\tle16_to_cpu(dnaddr) & 0x3ff);\n\n\t\tresult = kernel_write(file, buf, len, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "bin_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1101-1134",
    "snippet": "static ssize_t bin_uuid(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\t/* Only supports reads */\n\tif (oldval && oldlen) {\n\t\tchar buf[UUID_STRING_LEN + 1];\n\t\tuuid_t uuid;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buf, sizeof(buf) - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\tresult = -EIO;\n\t\tif (uuid_parse(buf, &uuid))\n\t\t\tgoto out;\n\n\t\tif (oldlen > 16)\n\t\t\toldlen = 16;\n\n\t\tresult = -EFAULT;\n\t\tif (copy_to_user(oldval, &uuid, oldlen))\n\t\t\tgoto out;\n\n\t\tcopied = oldlen;\n\t}\n\tresult = copied;\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "oldval",
            "&uuid",
            "oldlen"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_parse",
          "args": [
            "buf",
            "&uuid"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "buf",
            "sizeof(buf) - 1",
            "&pos"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t bin_uuid(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\t/* Only supports reads */\n\tif (oldval && oldlen) {\n\t\tchar buf[UUID_STRING_LEN + 1];\n\t\tuuid_t uuid;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buf, sizeof(buf) - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\tresult = -EIO;\n\t\tif (uuid_parse(buf, &uuid))\n\t\t\tgoto out;\n\n\t\tif (oldlen > 16)\n\t\t\toldlen = 16;\n\n\t\tresult = -EFAULT;\n\t\tif (copy_to_user(oldval, &uuid, oldlen))\n\t\t\tgoto out;\n\n\t\tcopied = oldlen;\n\t}\n\tresult = copied;\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "bin_ulongvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1028-1099",
    "snippet": "static ssize_t bin_ulongvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -ENOMEM;\n\tbuffer = kmalloc(BUFSZ, GFP_KERNEL);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned long __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buffer, BUFSZ - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -EFAULT;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned long __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tstr = buffer;\n\t\tend = str + BUFSZ;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -EFAULT;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [
      "#define BUFSZ 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "file",
            "buffer",
            "str - buffer",
            "&pos"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "str",
            "end - str",
            "\"%lu\\t\"",
            "value"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "value",
            "vec + i"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*str"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "value",
            "vec + i"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*str"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "10"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "buffer",
            "BUFSZ - 1",
            "&pos"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "BUFSZ",
            "GFP_KERNEL"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\n#define BUFSZ 256\n\nstatic ssize_t bin_ulongvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -ENOMEM;\n\tbuffer = kmalloc(BUFSZ, GFP_KERNEL);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned long __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buffer, BUFSZ - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -EFAULT;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned long __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tstr = buffer;\n\t\tend = str + BUFSZ;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -EFAULT;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "bin_intvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "955-1026",
    "snippet": "static ssize_t bin_intvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -ENOMEM;\n\tbuffer = kmalloc(BUFSZ, GFP_KERNEL);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buffer, BUFSZ - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -EFAULT;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tstr = buffer;\n\t\tend = str + BUFSZ;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -EFAULT;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [
      "#define BUFSZ 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "file",
            "buffer",
            "str - buffer",
            "&pos"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "str",
            "end - str",
            "\"%lu\\t\"",
            "value"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "value",
            "vec + i"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*str"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "value",
            "vec + i"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*str"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "10"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "buffer",
            "BUFSZ - 1",
            "&pos"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "BUFSZ",
            "GFP_KERNEL"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\n#define BUFSZ 256\n\nstatic ssize_t bin_intvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -ENOMEM;\n\tbuffer = kmalloc(BUFSZ, GFP_KERNEL);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tresult = kernel_read(file, buffer, BUFSZ - 1, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -EFAULT;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\t\tloff_t pos = 0;\n\n\t\tstr = buffer;\n\t\tend = str + BUFSZ;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -EFAULT;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "bin_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "912-953",
    "snippet": "static ssize_t bin_string(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\tif (oldval && oldlen) {\n\t\tchar __user *lastp;\n\t\tloff_t pos = 0;\n\t\tint ch;\n\n\t\tresult = vfs_read(file, oldval, oldlen, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tcopied = result;\n\t\tlastp = oldval + copied - 1;\n\n\t\tresult = -EFAULT;\n\t\tif (get_user(ch, lastp))\n\t\t\tgoto out;\n\n\t\t/* Trim off the trailing newline */\n\t\tif (ch == '\\n') {\n\t\t\tresult = -EFAULT;\n\t\t\tif (put_user('\\0', lastp))\n\t\t\t\tgoto out;\n\t\t\tcopied -= 1;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tloff_t pos = 0;\n\n\t\tresult = vfs_write(file, newval, newlen, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_write",
          "args": [
            "file",
            "newval",
            "newlen",
            "&pos"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "'\\0'",
            "lastp"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "ch",
            "lastp"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "file",
            "oldval",
            "oldlen",
            "&pos"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t bin_string(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\tif (oldval && oldlen) {\n\t\tchar __user *lastp;\n\t\tloff_t pos = 0;\n\t\tint ch;\n\n\t\tresult = vfs_read(file, oldval, oldlen, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tcopied = result;\n\t\tlastp = oldval + copied - 1;\n\n\t\tresult = -EFAULT;\n\t\tif (get_user(ch, lastp))\n\t\t\tgoto out;\n\n\t\t/* Trim off the trailing newline */\n\t\tif (ch == '\\n') {\n\t\t\tresult = -EFAULT;\n\t\t\tif (put_user('\\0', lastp))\n\t\t\t\tgoto out;\n\t\t\tcopied -= 1;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tloff_t pos = 0;\n\n\t\tresult = vfs_write(file, newval, newlen, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "bin_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "905-909",
    "snippet": "static ssize_t bin_dir(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\treturn -ENOTDIR;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic ssize_t bin_dir(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\treturn -ENOTDIR;\n}"
  },
  {
    "function_name": "sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1401-1428",
    "snippet": "SYSCALL_DEFINE1(sysctl, struct __sysctl_args __user *, args)\n{\n\tstruct __sysctl_args tmp;\n\tsize_t oldlen = 0;\n\tssize_t result;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.oldval && !tmp.oldlenp)\n\t\treturn -EFAULT;\n\n\tif (tmp.oldlenp && get_user(oldlen, tmp.oldlenp))\n\t\treturn -EFAULT;\n\n\tresult = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, oldlen,\n\t\t\t   tmp.newval, tmp.newlen);\n\n\tif (result >= 0) {\n\t\toldlen = result;\n\t\tresult = 0;\n\t}\n\n\tif (tmp.oldlenp && put_user(oldlen, tmp.oldlenp))\n\t\treturn -EFAULT;\n\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nSYSCALL_DEFINE1(sysctl, struct __sysctl_args __user *, args)\n{\n\tstruct __sysctl_args tmp;\n\tsize_t oldlen = 0;\n\tssize_t result;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.oldval && !tmp.oldlenp)\n\t\treturn -EFAULT;\n\n\tif (tmp.oldlenp && get_user(oldlen, tmp.oldlenp))\n\t\treturn -EFAULT;\n\n\tresult = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, oldlen,\n\t\t\t   tmp.newval, tmp.newlen);\n\n\tif (result >= 0) {\n\t\toldlen = result;\n\t\tresult = 0;\n\t}\n\n\tif (tmp.oldlenp && put_user(oldlen, tmp.oldlenp))\n\t\treturn -EFAULT;\n\n\treturn result;\n}"
  },
  {
    "function_name": "sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl_binary.c",
    "lines": "1443-1473",
    "snippet": "SYSCALL_DEFINE1(sysctl, struct compat_sysctl_args __user *, args)\n{\n\tstruct compat_sysctl_args tmp;\n\tcompat_size_t __user *compat_oldlenp;\n\tsize_t oldlen = 0;\n\tssize_t result;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.oldval && !tmp.oldlenp)\n\t\treturn -EFAULT;\n\n\tcompat_oldlenp = compat_ptr(tmp.oldlenp);\n\tif (compat_oldlenp && get_user(oldlen, compat_oldlenp))\n\t\treturn -EFAULT;\n\n\tresult = do_sysctl(compat_ptr(tmp.name), tmp.nlen,\n\t\t\t   compat_ptr(tmp.oldval), oldlen,\n\t\t\t   compat_ptr(tmp.newval), tmp.newlen);\n\n\tif (result >= 0) {\n\t\toldlen = result;\n\t\tresult = 0;\n\t}\n\n\tif (compat_oldlenp && put_user(oldlen, compat_oldlenp))\n\t\treturn -EFAULT;\n\n\treturn result;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/uuid.h>",
      "#include <linux/kernel.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/ctype.h>",
      "#include <linux/file.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/string.h>",
      "#include <linux/sunrpc/debug.h>",
      "#include \"../fs/xfs/xfs_sysctl.h\"",
      "#include <linux/sysctl.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/syscalls.h>\n#include <linux/string.h>\n#include <linux/sunrpc/debug.h>\n#include \"../fs/xfs/xfs_sysctl.h\"\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nSYSCALL_DEFINE1(sysctl, struct compat_sysctl_args __user *, args)\n{\n\tstruct compat_sysctl_args tmp;\n\tcompat_size_t __user *compat_oldlenp;\n\tsize_t oldlen = 0;\n\tssize_t result;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (tmp.oldval && !tmp.oldlenp)\n\t\treturn -EFAULT;\n\n\tcompat_oldlenp = compat_ptr(tmp.oldlenp);\n\tif (compat_oldlenp && get_user(oldlen, compat_oldlenp))\n\t\treturn -EFAULT;\n\n\tresult = do_sysctl(compat_ptr(tmp.name), tmp.nlen,\n\t\t\t   compat_ptr(tmp.oldval), oldlen,\n\t\t\t   compat_ptr(tmp.newval), tmp.newlen);\n\n\tif (result >= 0) {\n\t\toldlen = result;\n\t\tresult = 0;\n\t}\n\n\tif (compat_oldlenp && put_user(oldlen, compat_oldlenp))\n\t\treturn -EFAULT;\n\n\treturn result;\n}"
  }
]