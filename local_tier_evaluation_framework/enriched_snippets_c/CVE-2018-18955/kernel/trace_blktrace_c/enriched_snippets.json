[
  {
    "function_name": "blk_fill_rwbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1880-1919",
    "snippet": "void blk_fill_rwbs(char *rwbs, unsigned int op, int bytes)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_fill_rwbs(char *rwbs, unsigned int op, int bytes)\n{\n\tint i = 0;\n\n\tif (op & REQ_PREFLUSH)\n\t\trwbs[i++] = 'F';\n\n\tswitch (op & REQ_OP_MASK) {\n\tcase REQ_OP_WRITE:\n\tcase REQ_OP_WRITE_SAME:\n\t\trwbs[i++] = 'W';\n\t\tbreak;\n\tcase REQ_OP_DISCARD:\n\t\trwbs[i++] = 'D';\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\trwbs[i++] = 'D';\n\t\trwbs[i++] = 'E';\n\t\tbreak;\n\tcase REQ_OP_FLUSH:\n\t\trwbs[i++] = 'F';\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\trwbs[i++] = 'R';\n\t\tbreak;\n\tdefault:\n\t\trwbs[i++] = 'N';\n\t}\n\n\tif (op & REQ_FUA)\n\t\trwbs[i++] = 'F';\n\tif (op & REQ_RAHEAD)\n\t\trwbs[i++] = 'A';\n\tif (op & REQ_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (op & REQ_META)\n\t\trwbs[i++] = 'M';\n\n\trwbs[i] = '\\0';\n}"
  },
  {
    "function_name": "blk_trace_remove_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1871-1874",
    "snippet": "void blk_trace_remove_sysfs(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &blk_trace_attr_group);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "&dev->kobj",
            "&blk_trace_attr_group"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_trace_remove_sysfs(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &blk_trace_attr_group);\n}"
  },
  {
    "function_name": "blk_trace_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1866-1869",
    "snippet": "int blk_trace_init_sysfs(struct device *dev)\n{\n\treturn sysfs_create_group(&dev->kobj, &blk_trace_attr_group);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&dev->kobj",
            "&blk_trace_attr_group"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_init_sysfs(struct device *dev)\n{\n\treturn sysfs_create_group(&dev->kobj, &blk_trace_attr_group);\n}"
  },
  {
    "function_name": "sysfs_blk_trace_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1794-1864",
    "snippet": "static ssize_t sysfs_blk_trace_attr_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct block_device *bdev;\n\tstruct request_queue *q;\n\tstruct hd_struct *p;\n\tu64 value;\n\tssize_t ret = -EINVAL;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tif (attr == &dev_attr_act_mask) {\n\t\tif (kstrtoull(buf, 0, &value)) {\n\t\t\t/* Assume it is a list of trace category names */\n\t\t\tret = blk_trace_str2mask(buf);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = ret;\n\t\t}\n\t} else if (kstrtoull(buf, 0, &value))\n\t\tgoto out;\n\n\tret = -ENXIO;\n\n\tp = dev_to_part(dev);\n\tbdev = bdget(part_devt(p));\n\tif (bdev == NULL)\n\t\tgoto out;\n\n\tq = blk_trace_get_queue(bdev);\n\tif (q == NULL)\n\t\tgoto out_bdput;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tif (attr == &dev_attr_enable) {\n\t\tif (!!value == !!q->blk_trace) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\tif (value)\n\t\t\tret = blk_trace_setup_queue(q, bdev);\n\t\telse\n\t\t\tret = blk_trace_remove_queue(q);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tret = 0;\n\tif (q->blk_trace == NULL)\n\t\tret = blk_trace_setup_queue(q, bdev);\n\n\tif (ret == 0) {\n\t\tif (attr == &dev_attr_act_mask)\n\t\t\tq->blk_trace->act_mask = value;\n\t\telse if (attr == &dev_attr_pid)\n\t\t\tq->blk_trace->pid = value;\n\t\telse if (attr == &dev_attr_start_lba)\n\t\t\tq->blk_trace->start_lba = value;\n\t\telse if (attr == &dev_attr_end_lba)\n\t\t\tq->blk_trace->end_lba = value;\n\t}\n\nout_unlock_bdev:\n\tmutex_unlock(&q->blk_trace_mutex);\nout_bdput:\n\tbdput(bdev);\nout:\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_setup_queue",
          "args": [
            "q",
            "bdev"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_setup_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1604-1633",
          "snippet": "static int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto free_bt;\n\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto free_bt;\n\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_remove_queue",
          "args": [
            "q"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_remove_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1588-1599",
          "snippet": "static int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tput_probe_ref();\n\tblk_trace_free(bt);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tput_probe_ref();\n\tblk_trace_free(bt);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_get_queue",
          "args": [
            "bdev"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_get_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1743-1749",
          "snippet": "static struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->bd_disk == NULL)\n\t\treturn NULL;\n\n\treturn bdev_get_queue(bdev);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->bd_disk == NULL)\n\t\treturn NULL;\n\n\treturn bdev_get_queue(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "part_devt(p)"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_devt",
          "args": [
            "p"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_part",
          "args": [
            "dev"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&value"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_str2mask",
          "args": [
            "buf"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_str2mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1692-1725",
          "snippet": "static int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&value"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sysfs_blk_trace_attr_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct block_device *bdev;\n\tstruct request_queue *q;\n\tstruct hd_struct *p;\n\tu64 value;\n\tssize_t ret = -EINVAL;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\tif (attr == &dev_attr_act_mask) {\n\t\tif (kstrtoull(buf, 0, &value)) {\n\t\t\t/* Assume it is a list of trace category names */\n\t\t\tret = blk_trace_str2mask(buf);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = ret;\n\t\t}\n\t} else if (kstrtoull(buf, 0, &value))\n\t\tgoto out;\n\n\tret = -ENXIO;\n\n\tp = dev_to_part(dev);\n\tbdev = bdget(part_devt(p));\n\tif (bdev == NULL)\n\t\tgoto out;\n\n\tq = blk_trace_get_queue(bdev);\n\tif (q == NULL)\n\t\tgoto out_bdput;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tif (attr == &dev_attr_enable) {\n\t\tif (!!value == !!q->blk_trace) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\tif (value)\n\t\t\tret = blk_trace_setup_queue(q, bdev);\n\t\telse\n\t\t\tret = blk_trace_remove_queue(q);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tret = 0;\n\tif (q->blk_trace == NULL)\n\t\tret = blk_trace_setup_queue(q, bdev);\n\n\tif (ret == 0) {\n\t\tif (attr == &dev_attr_act_mask)\n\t\t\tq->blk_trace->act_mask = value;\n\t\telse if (attr == &dev_attr_pid)\n\t\t\tq->blk_trace->pid = value;\n\t\telse if (attr == &dev_attr_start_lba)\n\t\t\tq->blk_trace->start_lba = value;\n\t\telse if (attr == &dev_attr_end_lba)\n\t\t\tq->blk_trace->end_lba = value;\n\t}\n\nout_unlock_bdev:\n\tmutex_unlock(&q->blk_trace_mutex);\nout_bdput:\n\tbdput(bdev);\nout:\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "sysfs_blk_trace_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1751-1792",
    "snippet": "static ssize_t sysfs_blk_trace_attr_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct hd_struct *p = dev_to_part(dev);\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tssize_t ret = -ENXIO;\n\n\tbdev = bdget(part_devt(p));\n\tif (bdev == NULL)\n\t\tgoto out;\n\n\tq = blk_trace_get_queue(bdev);\n\tif (q == NULL)\n\t\tgoto out_bdput;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tif (attr == &dev_attr_enable) {\n\t\tret = sprintf(buf, \"%u\\n\", !!q->blk_trace);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tif (q->blk_trace == NULL)\n\t\tret = sprintf(buf, \"disabled\\n\");\n\telse if (attr == &dev_attr_act_mask)\n\t\tret = blk_trace_mask2str(buf, q->blk_trace->act_mask);\n\telse if (attr == &dev_attr_pid)\n\t\tret = sprintf(buf, \"%u\\n\", q->blk_trace->pid);\n\telse if (attr == &dev_attr_start_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", q->blk_trace->start_lba);\n\telse if (attr == &dev_attr_end_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", q->blk_trace->end_lba);\n\nout_unlock_bdev:\n\tmutex_unlock(&q->blk_trace_mutex);\nout_bdput:\n\tbdput(bdev);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\\n\"",
            "q->blk_trace->end_lba"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\\n\"",
            "q->blk_trace->start_lba"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "q->blk_trace->pid"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_mask2str",
          "args": [
            "buf",
            "q->blk_trace->act_mask"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_mask2str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1727-1741",
          "snippet": "static ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"disabled\\n\""
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "!!q->blk_trace"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_get_queue",
          "args": [
            "bdev"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_get_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1743-1749",
          "snippet": "static struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->bd_disk == NULL)\n\t\treturn NULL;\n\n\treturn bdev_get_queue(bdev);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->bd_disk == NULL)\n\t\treturn NULL;\n\n\treturn bdev_get_queue(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "part_devt(p)"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_devt",
          "args": [
            "p"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_part",
          "args": [
            "dev"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sysfs_blk_trace_attr_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct hd_struct *p = dev_to_part(dev);\n\tstruct request_queue *q;\n\tstruct block_device *bdev;\n\tssize_t ret = -ENXIO;\n\n\tbdev = bdget(part_devt(p));\n\tif (bdev == NULL)\n\t\tgoto out;\n\n\tq = blk_trace_get_queue(bdev);\n\tif (q == NULL)\n\t\tgoto out_bdput;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tif (attr == &dev_attr_enable) {\n\t\tret = sprintf(buf, \"%u\\n\", !!q->blk_trace);\n\t\tgoto out_unlock_bdev;\n\t}\n\n\tif (q->blk_trace == NULL)\n\t\tret = sprintf(buf, \"disabled\\n\");\n\telse if (attr == &dev_attr_act_mask)\n\t\tret = blk_trace_mask2str(buf, q->blk_trace->act_mask);\n\telse if (attr == &dev_attr_pid)\n\t\tret = sprintf(buf, \"%u\\n\", q->blk_trace->pid);\n\telse if (attr == &dev_attr_start_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", q->blk_trace->start_lba);\n\telse if (attr == &dev_attr_end_lba)\n\t\tret = sprintf(buf, \"%llu\\n\", q->blk_trace->end_lba);\n\nout_unlock_bdev:\n\tmutex_unlock(&q->blk_trace_mutex);\nout_bdput:\n\tbdput(bdev);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_get_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1743-1749",
    "snippet": "static struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->bd_disk == NULL)\n\t\treturn NULL;\n\n\treturn bdev_get_queue(bdev);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->bd_disk == NULL)\n\t\treturn NULL;\n\n\treturn bdev_get_queue(bdev);\n}"
  },
  {
    "function_name": "blk_trace_mask2str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1727-1741",
    "snippet": "static ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%s%s\"",
            "(p == buf) ? \"\" : \",\"",
            "mask_maps[i].str"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mask_maps"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}"
  },
  {
    "function_name": "blk_trace_str2mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1692-1725",
    "snippet": "static int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mask_maps"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "token",
            "mask_maps[i].str"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mask_maps"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&s",
            "\",\""
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_str2mask(const char *str)\n{\n\tint i;\n\tint mask = 0;\n\tchar *buf, *s, *token;\n\n\tbuf = kstrdup(str, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\ts = strstrip(buf);\n\n\twhile (1) {\n\t\ttoken = strsep(&s, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\n\t\tif (*token == '\\0')\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(mask_maps)) {\n\t\t\tmask = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}"
  },
  {
    "function_name": "blk_trace_setup_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1604-1633",
    "snippet": "static int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto free_bt;\n\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "310-319",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_probe_ref",
          "args": [],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "get_probe_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "321-327",
          "snippet": "static void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&q->blk_trace",
            "NULL",
            "bt"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_setup_lba",
          "args": [
            "bt",
            "bdev"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_setup_lba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "454-469",
          "snippet": "static void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tstruct hd_struct *part = NULL;\n\n\tif (bdev)\n\t\tpart = bdev->bd_part;\n\n\tif (part) {\n\t\tbt->start_lba = part->start_sect;\n\t\tbt->end_lba = part->start_sect + part->nr_sects;\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tstruct hd_struct *part = NULL;\n\n\tif (bdev)\n\t\tpart = bdev->bd_part;\n\n\tif (part) {\n\t\tbt->start_lba = part->start_sect;\n\t\tbt->end_lba = part->start_sect + part->nr_sects;\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "BLK_TN_MAX_MSG",
            "__alignof__(char)"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bt)",
            "GFP_KERNEL"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_setup_queue(struct request_queue *q,\n\t\t\t\t struct block_device *bdev)\n{\n\tstruct blk_trace *bt = NULL;\n\tint ret = -ENOMEM;\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto free_bt;\n\n\tbt->dev = bdev->bd_dev;\n\tbt->act_mask = (u16)-1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto free_bt;\n\n\tget_probe_ref();\n\treturn 0;\n\nfree_bt:\n\tblk_trace_free(bt);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_remove_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1588-1599",
    "snippet": "static int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tput_probe_ref();\n\tblk_trace_free(bt);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "310-319",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_probe_ref",
          "args": [],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "put_probe_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "329-335",
          "snippet": "static void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&q->blk_trace",
            "NULL"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_trace_remove_queue(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\tput_probe_ref();\n\tblk_trace_free(bt);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_blk_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1570-1584",
    "snippet": "static int __init init_blk_tracer(void)\n{\n\tif (!register_trace_event(&trace_blk_event)) {\n\t\tpr_warn(\"Warning: could not register block events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (register_tracer(&blk_tracer) != 0) {\n\t\tpr_warn(\"Warning: could not register the block tracer\\n\");\n\t\tunregister_trace_event(&trace_blk_event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&trace_blk_event"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "818-825",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register the block tracer\\n\""
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&blk_tracer"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1591-1672",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register block events\\n\""
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __init init_blk_tracer(void)\n{\n\tif (!register_trace_event(&trace_blk_event)) {\n\t\tpr_warn(\"Warning: could not register block events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (register_tracer(&blk_tracer) != 0) {\n\t\tpr_warn(\"Warning: could not register the block tracer\\n\");\n\t\tunregister_trace_event(&trace_blk_event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_tracer_set_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1535-1546",
    "snippet": "static int\nblk_tracer_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\t/* don't output context-info for blk_classic output */\n\tif (bit == TRACE_BLK_OPT_CLASSIC) {\n\t\tif (set)\n\t\t\ttr->trace_flags &= ~TRACE_ITER_CONTEXT_INFO;\n\t\telse\n\t\t\ttr->trace_flags |= TRACE_ITER_CONTEXT_INFO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CLASSIC\t0x1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CLASSIC\t0x1\n\nstatic int\nblk_tracer_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\t/* don't output context-info for blk_classic output */\n\tif (bit == TRACE_BLK_OPT_CLASSIC) {\n\t\tif (set)\n\t\t\ttr->trace_flags &= ~TRACE_ITER_CONTEXT_INFO;\n\t\telse\n\t\t\ttr->trace_flags |= TRACE_ITER_CONTEXT_INFO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_tracer_print_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1527-1533",
    "snippet": "static enum print_line_t blk_tracer_print_line(struct trace_iterator *iter)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\treturn print_one_line(iter, true);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CLASSIC\t0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_one_line",
          "args": [
            "iter",
            "true"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "print_one_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1464-1495",
          "snippet": "static enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CLASSIC\t0x1\n\nstatic enum print_line_t blk_tracer_print_line(struct trace_iterator *iter)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\treturn print_one_line(iter, true);\n}"
  },
  {
    "function_name": "blk_trace_event_print_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1518-1525",
    "snippet": "static enum print_line_t\nblk_trace_event_print_binary(struct trace_iterator *iter, int flags,\n\t\t\t     struct trace_event *event)\n{\n\tblk_trace_synthesize_old_trace(iter);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_synthesize_old_trace",
          "args": [
            "iter"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_synthesize_old_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1503-1516",
          "snippet": "static void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t\nblk_trace_event_print_binary(struct trace_iterator *iter, int flags,\n\t\t\t     struct trace_event *event)\n{\n\tblk_trace_synthesize_old_trace(iter);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "blk_trace_synthesize_old_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1503-1516",
    "snippet": "static void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putmem",
          "args": [
            "s",
            "&t->sector",
            "sizeof(old) - offset + t->pdu_len"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putmem_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "288-312",
          "snippet": "void trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_synthesize_old_trace(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct blk_io_trace *t = (struct blk_io_trace *)iter->ent;\n\tconst int offset = offsetof(struct blk_io_trace, sector);\n\tstruct blk_io_trace old = {\n\t\t.magic\t  = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION,\n\t\t.time     = iter->ts,\n\t};\n\n\ttrace_seq_putmem(s, &old, offset);\n\ttrace_seq_putmem(s, &t->sector,\n\t\t\t sizeof(old) - offset + t->pdu_len);\n}"
  },
  {
    "function_name": "blk_trace_event_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1497-1501",
    "snippet": "static enum print_line_t blk_trace_event_print(struct trace_iterator *iter,\n\t\t\t\t\t       int flags, struct trace_event *event)\n{\n\treturn print_one_line(iter, false);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_one_line",
          "args": [
            "iter",
            "false"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "print_one_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1464-1495",
          "snippet": "static enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t blk_trace_event_print(struct trace_iterator *iter,\n\t\t\t\t\t       int flags, struct trace_event *event)\n{\n\treturn print_one_line(iter, false);\n}"
  },
  {
    "function_name": "print_one_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1464-1495",
    "snippet": "static enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "what2act[what].print",
          "args": [
            "s",
            "iter->ent",
            "has_cg"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_action",
          "args": [
            "iter",
            "what2act[what].act[long_act]",
            "has_cg"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1257-1283",
          "snippet": "static void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tconst union kernfs_node_id *id = cgid_start(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %x,%-x %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id->ino, id->generation, act, rwbs);\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGNAME\t0x4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGNAME\t0x4\n\nstatic void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tconst union kernfs_node_id *id = cgid_start(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %x,%-x %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id->ino, id->generation, act, rwbs);\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"Unknown action %x\\n\"",
            "what"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "what == 0 || what >= ARRAY_SIZE(what2act)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "what2act"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_log_msg",
          "args": [
            "s",
            "iter->ent",
            "has_cg"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1399-1406",
          "snippet": "static void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "iter->ent"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t print_one_line(struct trace_iterator *iter,\n\t\t\t\t\tbool classic)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tconst struct blk_io_trace *t;\n\tu16 what;\n\tbool long_act;\n\tblk_log_action_t *log_action;\n\tbool has_cg;\n\n\tt\t   = te_blk_io_trace(iter->ent);\n\twhat\t   = (t->action & ((1 << BLK_TC_SHIFT) - 1)) & ~__BLK_TA_CGROUP;\n\tlong_act   = !!(tr->trace_flags & TRACE_ITER_VERBOSE);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\thas_cg\t   = t->action & __BLK_TA_CGROUP;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\tlog_action(iter, long_act ? \"message\" : \"m\", has_cg);\n\t\tblk_log_msg(s, iter->ent, has_cg);\n\t\treturn trace_handle_return(s);\n\t}\n\n\tif (unlikely(what == 0 || what >= ARRAY_SIZE(what2act)))\n\t\ttrace_seq_printf(s, \"Unknown action %x\\n\", what);\n\telse {\n\t\tlog_action(iter, what2act[what].act[long_act], has_cg);\n\t\twhat2act[what].print(s, iter->ent, has_cg);\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "blk_tracer_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1437-1440",
    "snippet": "static void blk_tracer_reset(struct trace_array *tr)\n{\n\tblk_tracer_stop(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_tracer_stop",
          "args": [
            "tr"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "blk_tracer_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1432-1435",
          "snippet": "static void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_reset(struct trace_array *tr)\n{\n\tblk_tracer_stop(tr);\n}"
  },
  {
    "function_name": "blk_tracer_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1432-1435",
    "snippet": "static void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_stop(struct trace_array *tr)\n{\n\tblk_tracer_enabled = false;\n}"
  },
  {
    "function_name": "blk_tracer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1425-1430",
    "snippet": "static int blk_tracer_init(struct trace_array *tr)\n{\n\tblk_tr = tr;\n\tblk_tracer_start(tr);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_tracer_start",
          "args": [
            "tr"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "blk_tracer_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1420-1423",
          "snippet": "static void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_tracer_init(struct trace_array *tr)\n{\n\tblk_tr = tr;\n\tblk_tracer_start(tr);\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_tracer_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1420-1423",
    "snippet": "static void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_tracer_start(struct trace_array *tr)\n{\n\tblk_tracer_enabled = true;\n}"
  },
  {
    "function_name": "blk_tracer_print_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1412-1418",
    "snippet": "static void blk_tracer_print_header(struct seq_file *m)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn;\n\tseq_puts(m, \"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"\n\t\t    \"#  |     |     |           |   |   |\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CLASSIC\t0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"\n\t\t    \"#  |     |     |           |   |   |\\n\""
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CLASSIC\t0x1\n\nstatic void blk_tracer_print_header(struct seq_file *m)\n{\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CLASSIC))\n\t\treturn;\n\tseq_puts(m, \"# DEV   CPU TIMESTAMP     PID ACT FLG\\n\"\n\t\t    \"#  |     |     |           |   |   |\\n\");\n}"
  },
  {
    "function_name": "blk_log_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1399-1406",
    "snippet": "static void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putmem",
          "args": [
            "s",
            "pdu_start(ent, has_cg)",
            "pdu_real_len(ent, has_cg)"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putmem_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "288-312",
          "snippet": "void trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t/* Each byte is represented by two chars */\n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t/* The added spaces can still cause an overflow */\n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_real_len",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_real_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1189-1193",
          "snippet": "static inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len -\n\t\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len -\n\t\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1178-1182",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_msg(struct trace_seq *s, const struct trace_entry *ent,\n\t\t\tbool has_cg)\n{\n\n\ttrace_seq_putmem(s, pdu_start(ent, has_cg),\n\t\tpdu_real_len(ent, has_cg));\n\ttrace_seq_putc(s, '\\n');\n}"
  },
  {
    "function_name": "blk_log_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1389-1397",
    "snippet": "static void blk_log_split(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"%llu / %llu [%s]\\n\", t_sector(ent),\n\t\t\t get_pdu_int(ent, has_cg), cmd);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu / %llu [%s]\\n\"",
            "t_sector(ent)",
            "get_pdu_int(ent, has_cg)",
            "cmd"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pdu_int",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "get_pdu_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1220-1224",
          "snippet": "static __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __u64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __u64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_sector",
          "args": [
            "ent"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1210-1213",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2004-2013",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_split(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"%llu / %llu [%s]\\n\", t_sector(ent),\n\t\t\t get_pdu_int(ent, has_cg), cmd);\n}"
  },
  {
    "function_name": "blk_log_unplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1380-1387",
    "snippet": "static void blk_log_unplug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s] %llu\\n\", cmd, get_pdu_int(ent, has_cg));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%s] %llu\\n\"",
            "cmd",
            "get_pdu_int(ent, has_cg)"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pdu_int",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "get_pdu_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1220-1224",
          "snippet": "static __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __u64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __u64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2004-2013",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_unplug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s] %llu\\n\", cmd, get_pdu_int(ent, has_cg));\n}"
  },
  {
    "function_name": "blk_log_plug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1371-1378",
    "snippet": "static void blk_log_plug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%s]\\n\"",
            "cmd"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2004-2013",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_plug(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n}"
  },
  {
    "function_name": "blk_log_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1360-1369",
    "snippet": "static void blk_log_remap(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tstruct blk_io_trace_remap r = { .device_from = 0, };\n\n\tget_pdu_remap(ent, &r, has_cg);\n\ttrace_seq_printf(s, \"%llu + %u <- (%d,%d) %llu\\n\",\n\t\t\t t_sector(ent), t_sec(ent),\n\t\t\t MAJOR(r.device_from), MINOR(r.device_from),\n\t\t\t (unsigned long long)r.sector_from);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu + %u <- (%d,%d) %llu\\n\"",
            "t_sector(ent)",
            "t_sec(ent)",
            "MAJOR(r.device_from)",
            "MINOR(r.device_from)",
            "(unsigned long long)r.sector_from"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "r.device_from"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "r.device_from"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_sec",
          "args": [
            "ent"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1210-1213",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pdu_remap",
          "args": [
            "ent",
            "&r",
            "has_cg"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "get_pdu_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1226-1235",
          "snippet": "static void get_pdu_remap(const struct trace_entry *ent,\n\t\t\t  struct blk_io_trace_remap *r, bool has_cg)\n{\n\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);\n\t__u64 sector_from = __r->sector_from;\n\n\tr->device_from = be32_to_cpu(__r->device_from);\n\tr->device_to   = be32_to_cpu(__r->device_to);\n\tr->sector_from = be64_to_cpu(sector_from);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_pdu_remap(const struct trace_entry *ent,\n\t\t\t  struct blk_io_trace_remap *r, bool has_cg)\n{\n\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);\n\t__u64 sector_from = __r->sector_from;\n\n\tr->device_from = be32_to_cpu(__r->device_from);\n\tr->device_to   = be32_to_cpu(__r->device_to);\n\tr->sector_from = be64_to_cpu(sector_from);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_remap(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tstruct blk_io_trace_remap r = { .device_from = 0, };\n\n\tget_pdu_remap(ent, &r, has_cg);\n\ttrace_seq_printf(s, \"%llu + %u <- (%d,%d) %llu\\n\",\n\t\t\t t_sector(ent), t_sec(ent),\n\t\t\t MAJOR(r.device_from), MINOR(r.device_from),\n\t\t\t (unsigned long long)r.sector_from);\n}"
  },
  {
    "function_name": "blk_log_with_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1343-1358",
    "snippet": "static void blk_log_with_error(struct trace_seq *s,\n\t\t\t      const struct trace_entry *ent, bool has_cg)\n{\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%d]\\n\", t_error(ent));\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%d]\\n\",\n\t\t\t\t\t t_sector(ent),\n\t\t\t\t\t t_sec(ent), t_error(ent));\n\t\telse\n\t\t\ttrace_seq_printf(s, \"%llu [%d]\\n\",\n\t\t\t\t\t t_sector(ent), t_error(ent));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%llu [%d]\\n\"",
            "t_sector(ent)",
            "t_error(ent)"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_error",
          "args": [
            "ent"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "t_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1215-1218",
          "snippet": "static inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_sector",
          "args": [
            "ent"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1210-1213",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_log_dump_pdu",
          "args": [
            "s",
            "ent",
            "has_cg"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_dump_pdu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1285-1322",
          "snippet": "static void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeroes and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeroes and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_PC"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_action",
          "args": [
            "ent"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "t_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1195-1198",
          "snippet": "static inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_with_error(struct trace_seq *s,\n\t\t\t      const struct trace_entry *ent, bool has_cg)\n{\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%d]\\n\", t_error(ent));\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%d]\\n\",\n\t\t\t\t\t t_sector(ent),\n\t\t\t\t\t t_sec(ent), t_error(ent));\n\t\telse\n\t\t\ttrace_seq_printf(s, \"%llu [%d]\\n\",\n\t\t\t\t\t t_sector(ent), t_error(ent));\n\t}\n}"
  },
  {
    "function_name": "blk_log_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1324-1341",
    "snippet": "static void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\ttrace_seq_printf(s, \"%u \", t_bytes(ent));\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%s]\\n\",\n\t\t\t\t\t\tt_sector(ent), t_sec(ent), cmd);\n\t\telse\n\t\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"[%s]\\n\"",
            "cmd"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_sec",
          "args": [
            "ent"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "t_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1210-1213",
          "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_log_dump_pdu",
          "args": [
            "s",
            "ent",
            "has_cg"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "blk_log_dump_pdu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1285-1322",
          "snippet": "static void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeroes and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeroes and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_bytes",
          "args": [
            "ent"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "t_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1200-1203",
          "snippet": "static inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_PC"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_action",
          "args": [
            "ent"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "t_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1195-1198",
          "snippet": "static inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "ent->pid",
            "cmd"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2004-2013",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent, bool has_cg)\n{\n\tchar cmd[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(ent->pid, cmd);\n\n\tif (t_action(ent) & BLK_TC_ACT(BLK_TC_PC)) {\n\t\ttrace_seq_printf(s, \"%u \", t_bytes(ent));\n\t\tblk_log_dump_pdu(s, ent, has_cg);\n\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t} else {\n\t\tif (t_sec(ent))\n\t\t\ttrace_seq_printf(s, \"%llu + %u [%s]\\n\",\n\t\t\t\t\t\tt_sector(ent), t_sec(ent), cmd);\n\t\telse\n\t\t\ttrace_seq_printf(s, \"[%s]\\n\", cmd);\n\t}\n}"
  },
  {
    "function_name": "blk_log_dump_pdu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1285-1322",
    "snippet": "static void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeroes and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\") \""
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s%02x\"",
            "i == 0 ? \"\" : \" \"",
            "pdu_buf[i]"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'('"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_real_len",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_real_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1189-1193",
          "snippet": "static inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len -\n\t\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len -\n\t\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1178-1182",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_dump_pdu(struct trace_seq *s,\n\tconst struct trace_entry *ent, bool has_cg)\n{\n\tconst unsigned char *pdu_buf;\n\tint pdu_len;\n\tint i, end;\n\n\tpdu_buf = pdu_start(ent, has_cg);\n\tpdu_len = pdu_real_len(ent, has_cg);\n\n\tif (!pdu_len)\n\t\treturn;\n\n\t/* find the last zero that needs to be printed */\n\tfor (end = pdu_len - 1; end >= 0; end--)\n\t\tif (pdu_buf[end])\n\t\t\tbreak;\n\tend++;\n\n\ttrace_seq_putc(s, '(');\n\n\tfor (i = 0; i < pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t/*\n\t\t * stop when the rest is just zeroes and indicate so\n\t\t * with a \"..\" appended\n\t\t */\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}"
  },
  {
    "function_name": "blk_log_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1257-1283",
    "snippet": "static void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tconst union kernfs_node_id *id = cgid_start(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %x,%-x %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id->ino, id->generation, act, rwbs);\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CGNAME\t0x4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"%3d,%-3d %2s %3s \"",
            "MAJOR(t->device)",
            "MINOR(t->device)",
            "act",
            "rwbs"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_from_kernfs_id",
          "args": [
            "id",
            "blkcg_name_buf",
            "sizeof(blkcg_name_buf)"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_from_kernfs_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "5454-5464",
          "snippet": "void cgroup_path_from_kernfs_id(const union kernfs_node_id *id,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nvoid cgroup_path_from_kernfs_id(const union kernfs_node_id *id,\n\t\t\t\t\tchar *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgid_start",
          "args": [
            "iter->ent"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "cgid_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1184-1187",
          "snippet": "static inline const void *cgid_start(const struct trace_entry *ent)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *cgid_start(const struct trace_entry *ent)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_rwbs",
          "args": [
            "rwbs",
            "t"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "fill_rwbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1138-1170",
          "snippet": "static void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "iter->ent"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGNAME\t0x4\n\nstatic void blk_log_action(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\tif (has_cg) {\n\t\tconst union kernfs_node_id *id = cgid_start(iter->ent);\n\n\t\tif (blk_tracer_flags.val & TRACE_BLK_OPT_CGNAME) {\n\t\t\tchar blkcg_name_buf[NAME_MAX + 1] = \"<...>\";\n\n\t\t\tcgroup_path_from_kernfs_id(id, blkcg_name_buf,\n\t\t\t\tsizeof(blkcg_name_buf));\n\t\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %s %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t blkcg_name_buf, act, rwbs);\n\t\t} else\n\t\t\ttrace_seq_printf(&iter->seq,\n\t\t\t\t \"%3d,%-3d %x,%-x %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device),\n\t\t\t\t id->ino, id->generation, act, rwbs);\n\t} else\n\t\ttrace_seq_printf(&iter->seq, \"%3d,%-3d %2s %3s \",\n\t\t\t\t MAJOR(t->device), MINOR(t->device), act, rwbs);\n}"
  },
  {
    "function_name": "blk_log_action_classic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1240-1255",
    "snippet": "static void blk_log_action_classic(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tunsigned long long ts  = iter->ts;\n\tunsigned long nsec_rem = do_div(ts, NSEC_PER_SEC);\n\tunsigned secs\t       = (unsigned long)ts;\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \",\n\t\t\t MAJOR(t->device), MINOR(t->device), iter->cpu,\n\t\t\t secs, nsec_rem, iter->ent->pid, act, rwbs);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \"",
            "MAJOR(t->device)",
            "MINOR(t->device)",
            "iter->cpu",
            "secs",
            "nsec_rem",
            "iter->ent->pid",
            "act",
            "rwbs"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "t->device"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "t->device"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_rwbs",
          "args": [
            "rwbs",
            "t"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "fill_rwbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1138-1170",
          "snippet": "static void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "iter->ent"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ts",
            "NSEC_PER_SEC"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_log_action_classic(struct trace_iterator *iter, const char *act,\n\tbool has_cg)\n{\n\tchar rwbs[RWBS_LEN];\n\tunsigned long long ts  = iter->ts;\n\tunsigned long nsec_rem = do_div(ts, NSEC_PER_SEC);\n\tunsigned secs\t       = (unsigned long)ts;\n\tconst struct blk_io_trace *t = te_blk_io_trace(iter->ent);\n\n\tfill_rwbs(rwbs, t);\n\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \",\n\t\t\t MAJOR(t->device), MINOR(t->device), iter->cpu,\n\t\t\t secs, nsec_rem, iter->ent->pid, act, rwbs);\n}"
  },
  {
    "function_name": "get_pdu_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1226-1235",
    "snippet": "static void get_pdu_remap(const struct trace_entry *ent,\n\t\t\t  struct blk_io_trace_remap *r, bool has_cg)\n{\n\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);\n\t__u64 sector_from = __r->sector_from;\n\n\tr->device_from = be32_to_cpu(__r->device_from);\n\tr->device_to   = be32_to_cpu(__r->device_to);\n\tr->sector_from = be64_to_cpu(sector_from);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "sector_from"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "__r->device_to"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "__r->device_from"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1178-1182",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_pdu_remap(const struct trace_entry *ent,\n\t\t\t  struct blk_io_trace_remap *r, bool has_cg)\n{\n\tconst struct blk_io_trace_remap *__r = pdu_start(ent, has_cg);\n\t__u64 sector_from = __r->sector_from;\n\n\tr->device_from = be32_to_cpu(__r->device_from);\n\tr->device_to   = be32_to_cpu(__r->device_to);\n\tr->sector_from = be64_to_cpu(sector_from);\n}"
  },
  {
    "function_name": "get_pdu_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1220-1224",
    "snippet": "static __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __u64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*val"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdu_start",
          "args": [
            "ent",
            "has_cg"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "pdu_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1178-1182",
          "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic __u64 get_pdu_int(const struct trace_entry *ent, bool has_cg)\n{\n\tconst __u64 *val = pdu_start(ent, has_cg);\n\treturn be64_to_cpu(*val);\n}"
  },
  {
    "function_name": "t_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1215-1218",
    "snippet": "static inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline __u16 t_error(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->error;\n}"
  },
  {
    "function_name": "t_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1210-1213",
    "snippet": "static inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long long t_sector(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->sector;\n}"
  },
  {
    "function_name": "t_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1205-1208",
    "snippet": "static inline u32 t_sec(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes >> 9;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_sec(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes >> 9;\n}"
  },
  {
    "function_name": "t_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1200-1203",
    "snippet": "static inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_bytes(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->bytes;\n}"
  },
  {
    "function_name": "t_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1195-1198",
    "snippet": "static inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline u32 t_action(const struct trace_entry *ent)\n{\n\treturn te_blk_io_trace(ent)->action;\n}"
  },
  {
    "function_name": "pdu_real_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1189-1193",
    "snippet": "static inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len -\n\t\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline int pdu_real_len(const struct trace_entry *ent, bool has_cg)\n{\n\treturn te_blk_io_trace(ent)->pdu_len -\n\t\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
  },
  {
    "function_name": "cgid_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1184-1187",
    "snippet": "static inline const void *cgid_start(const struct trace_entry *ent)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *cgid_start(const struct trace_entry *ent)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1);\n}"
  },
  {
    "function_name": "pdu_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1178-1182",
    "snippet": "static inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "te_blk_io_trace",
          "args": [
            "ent"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "te_blk_io_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1172-1176",
          "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline const void *pdu_start(const struct trace_entry *ent, bool has_cg)\n{\n\treturn (void *)(te_blk_io_trace(ent) + 1) +\n\t\t(has_cg ? sizeof(union kernfs_node_id) : 0);\n}"
  },
  {
    "function_name": "te_blk_io_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1172-1176",
    "snippet": "static inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic inline\nconst struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)\n{\n\treturn (const struct blk_io_trace *)ent;\n}"
  },
  {
    "function_name": "fill_rwbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1138-1170",
    "snippet": "static void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void fill_rwbs(char *rwbs, const struct blk_io_trace *t)\n{\n\tint i = 0;\n\tint tc = t->action >> BLK_TC_SHIFT;\n\n\tif ((t->action & ~__BLK_TN_CGROUP) == BLK_TN_MESSAGE) {\n\t\trwbs[i++] = 'N';\n\t\tgoto out;\n\t}\n\n\tif (tc & BLK_TC_FLUSH)\n\t\trwbs[i++] = 'F';\n\n\tif (tc & BLK_TC_DISCARD)\n\t\trwbs[i++] = 'D';\n\telse if (tc & BLK_TC_WRITE)\n\t\trwbs[i++] = 'W';\n\telse if (t->bytes)\n\t\trwbs[i++] = 'R';\n\telse\n\t\trwbs[i++] = 'N';\n\n\tif (tc & BLK_TC_FUA)\n\t\trwbs[i++] = 'F';\n\tif (tc & BLK_TC_AHEAD)\n\t\trwbs[i++] = 'A';\n\tif (tc & BLK_TC_SYNC)\n\t\trwbs[i++] = 'S';\n\tif (tc & BLK_TC_META)\n\t\trwbs[i++] = 'M';\nout:\n\trwbs[i] = '\\0';\n}"
  },
  {
    "function_name": "blk_unregister_tracepoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1112-1132",
    "snippet": "static void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_insert",
          "args": [
            "blk_add_trace_rq_insert",
            "NULL"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_issue",
          "args": [
            "blk_add_trace_rq_issue",
            "NULL"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_requeue",
          "args": [
            "blk_add_trace_rq_requeue",
            "NULL"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_complete",
          "args": [
            "blk_add_trace_rq_complete",
            "NULL"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_bounce",
          "args": [
            "blk_add_trace_bio_bounce",
            "NULL"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_complete",
          "args": [
            "blk_add_trace_bio_complete",
            "NULL"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_backmerge",
          "args": [
            "blk_add_trace_bio_backmerge",
            "NULL"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_frontmerge",
          "args": [
            "blk_add_trace_bio_frontmerge",
            "NULL"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_queue",
          "args": [
            "blk_add_trace_bio_queue",
            "NULL"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_getrq",
          "args": [
            "blk_add_trace_getrq",
            "NULL"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_sleeprq",
          "args": [
            "blk_add_trace_sleeprq",
            "NULL"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_plug",
          "args": [
            "blk_add_trace_plug",
            "NULL"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_unplug",
          "args": [
            "blk_add_trace_unplug",
            "NULL"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_split",
          "args": [
            "blk_add_trace_split",
            "NULL"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_bio_remap",
          "args": [
            "blk_add_trace_bio_remap",
            "NULL"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_block_rq_remap",
          "args": [
            "blk_add_trace_rq_remap",
            "NULL"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}"
  },
  {
    "function_name": "blk_register_tracepoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1074-1110",
    "snippet": "static void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_remap",
          "args": [
            "blk_add_trace_rq_remap",
            "NULL"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_remap",
          "args": [
            "blk_add_trace_bio_remap",
            "NULL"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_split",
          "args": [
            "blk_add_trace_split",
            "NULL"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_unplug",
          "args": [
            "blk_add_trace_unplug",
            "NULL"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_plug",
          "args": [
            "blk_add_trace_plug",
            "NULL"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_sleeprq",
          "args": [
            "blk_add_trace_sleeprq",
            "NULL"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_getrq",
          "args": [
            "blk_add_trace_getrq",
            "NULL"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_queue",
          "args": [
            "blk_add_trace_bio_queue",
            "NULL"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_frontmerge",
          "args": [
            "blk_add_trace_bio_frontmerge",
            "NULL"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_backmerge",
          "args": [
            "blk_add_trace_bio_backmerge",
            "NULL"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_complete",
          "args": [
            "blk_add_trace_bio_complete",
            "NULL"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_bio_bounce",
          "args": [
            "blk_add_trace_bio_bounce",
            "NULL"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_complete",
          "args": [
            "blk_add_trace_rq_complete",
            "NULL"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_requeue",
          "args": [
            "blk_add_trace_rq_requeue",
            "NULL"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_issue",
          "args": [
            "blk_add_trace_rq_issue",
            "NULL"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_block_rq_insert",
          "args": [
            "blk_add_trace_rq_insert",
            "NULL"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}"
  },
  {
    "function_name": "blk_add_driver_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1059-1071",
    "snippet": "void blk_add_driver_data(struct request_queue *q,\n\t\t\t struct request *rq,\n\t\t\t void *data, size_t len)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0, 0,\n\t\t\t\tBLK_TA_DRV_DATA, 0, len, data,\n\t\t\t\tblk_trace_request_get_cgid(q, rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "blk_rq_trace_sector(rq)",
            "blk_rq_bytes(rq)",
            "0",
            "0",
            "BLK_TA_DRV_DATA",
            "0",
            "len",
            "data",
            "blk_trace_request_get_cgid(q, rq)"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "q",
            "rq"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "779-786",
          "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_trace_sector",
          "args": [
            "rq"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_add_driver_data(struct request_queue *q,\n\t\t\t struct request *rq,\n\t\t\t void *data, size_t len)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0, 0,\n\t\t\t\tBLK_TA_DRV_DATA, 0, len, data,\n\t\t\t\tblk_trace_request_get_cgid(q, rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "1028-1046",
    "snippet": "static void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "blk_rq_pos(rq)",
            "blk_rq_bytes(rq)",
            "rq_data_dir(rq)",
            "0",
            "BLK_TA_REMAP",
            "0",
            "sizeof(r)",
            "&r",
            "blk_trace_request_get_cgid(q, rq)"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "q",
            "rq"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "779-786",
          "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_data_dir",
          "args": [
            "rq"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_pos",
          "args": [
            "rq"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "disk_devt(rq->rq_disk)"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_devt",
          "args": [
            "rq->rq_disk"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dev"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}"
  },
  {
    "function_name": "blk_add_trace_bio_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "996-1013",
    "snippet": "static void blk_add_trace_bio_remap(void *ignore,\n\t\t\t\t    struct request_queue *q, struct bio *bio,\n\t\t\t\t    dev_t dev, sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP, bio->bi_status,\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "bio->bi_iter.bi_sector",
            "bio->bi_iter.bi_size",
            "bio_op(bio)",
            "bio->bi_opf",
            "BLK_TA_REMAP",
            "bio->bi_status",
            "sizeof(r)",
            "&r",
            "blk_trace_bio_get_cgid(q, bio)"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "bio"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "772-776",
          "snippet": "static union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dev"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_remap(void *ignore,\n\t\t\t\t    struct request_queue *q, struct bio *bio,\n\t\t\t\t    dev_t dev, sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(bio_dev(bio));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, BLK_TA_REMAP, bio->bi_status,\n\t\t\tsizeof(r), &r, blk_trace_bio_get_cgid(q, bio));\n}"
  },
  {
    "function_name": "blk_add_trace_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "967-981",
    "snippet": "static void blk_add_trace_split(void *ignore,\n\t\t\t\tstruct request_queue *q, struct bio *bio,\n\t\t\t\tunsigned int pdu)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(pdu);\n\n\t\t__blk_add_trace(bt, bio->bi_iter.bi_sector,\n\t\t\t\tbio->bi_iter.bi_size, bio_op(bio), bio->bi_opf,\n\t\t\t\tBLK_TA_SPLIT, bio->bi_status, sizeof(rpdu),\n\t\t\t\t&rpdu, blk_trace_bio_get_cgid(q, bio));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "bio->bi_iter.bi_sector",
            "bio->bi_iter.bi_size",
            "bio_op(bio)",
            "bio->bi_opf",
            "BLK_TA_SPLIT",
            "bio->bi_status",
            "sizeof(rpdu)",
            "&rpdu",
            "blk_trace_bio_get_cgid(q, bio)"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "bio"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "772-776",
          "snippet": "static union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "pdu"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_split(void *ignore,\n\t\t\t\tstruct request_queue *q, struct bio *bio,\n\t\t\t\tunsigned int pdu)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(pdu);\n\n\t\t__blk_add_trace(bt, bio->bi_iter.bi_sector,\n\t\t\t\tbio->bi_iter.bi_size, bio_op(bio), bio->bi_opf,\n\t\t\t\tBLK_TA_SPLIT, bio->bi_status, sizeof(rpdu),\n\t\t\t\t&rpdu, blk_trace_bio_get_cgid(q, bio));\n\t}\n}"
  },
  {
    "function_name": "blk_add_trace_unplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "949-965",
    "snippet": "static void blk_add_trace_unplug(void *ignore, struct request_queue *q,\n\t\t\t\t    unsigned int depth, bool explicit)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(depth);\n\t\tu32 what;\n\n\t\tif (explicit)\n\t\t\twhat = BLK_TA_UNPLUG_IO;\n\t\telse\n\t\t\twhat = BLK_TA_UNPLUG_TIMER;\n\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, what, 0, sizeof(rpdu), &rpdu, NULL);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "0",
            "0",
            "0",
            "0",
            "what",
            "0",
            "sizeof(rpdu)",
            "&rpdu",
            "NULL"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "depth"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_unplug(void *ignore, struct request_queue *q,\n\t\t\t\t    unsigned int depth, bool explicit)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt) {\n\t\t__be64 rpdu = cpu_to_be64(depth);\n\t\tu32 what;\n\n\t\tif (explicit)\n\t\t\twhat = BLK_TA_UNPLUG_IO;\n\t\telse\n\t\t\twhat = BLK_TA_UNPLUG_TIMER;\n\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, what, 0, sizeof(rpdu), &rpdu, NULL);\n\t}\n}"
  },
  {
    "function_name": "blk_add_trace_plug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "941-947",
    "snippet": "static void blk_add_trace_plug(void *ignore, struct request_queue *q)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt)\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, BLK_TA_PLUG, 0, 0, NULL, NULL);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "0",
            "0",
            "0",
            "0",
            "BLK_TA_PLUG",
            "0",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_plug(void *ignore, struct request_queue *q)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt)\n\t\t__blk_add_trace(bt, 0, 0, 0, 0, BLK_TA_PLUG, 0, 0, NULL, NULL);\n}"
  },
  {
    "function_name": "blk_add_trace_sleeprq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "926-939",
    "snippet": "static void blk_add_trace_sleeprq(void *ignore,\n\t\t\t\t  struct request_queue *q,\n\t\t\t\t  struct bio *bio, int rw)\n{\n\tif (bio)\n\t\tblk_add_trace_bio(q, bio, BLK_TA_SLEEPRQ, 0);\n\telse {\n\t\tstruct blk_trace *bt = q->blk_trace;\n\n\t\tif (bt)\n\t\t\t__blk_add_trace(bt, 0, 0, rw, 0, BLK_TA_SLEEPRQ,\n\t\t\t\t\t0, 0, NULL, NULL);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "0",
            "0",
            "rw",
            "0",
            "BLK_TA_SLEEPRQ",
            "0",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_SLEEPRQ",
            "0"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_sleeprq(void *ignore,\n\t\t\t\t  struct request_queue *q,\n\t\t\t\t  struct bio *bio, int rw)\n{\n\tif (bio)\n\t\tblk_add_trace_bio(q, bio, BLK_TA_SLEEPRQ, 0);\n\telse {\n\t\tstruct blk_trace *bt = q->blk_trace;\n\n\t\tif (bt)\n\t\t\t__blk_add_trace(bt, 0, 0, rw, 0, BLK_TA_SLEEPRQ,\n\t\t\t\t\t0, 0, NULL, NULL);\n\t}\n}"
  },
  {
    "function_name": "blk_add_trace_getrq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "910-923",
    "snippet": "static void blk_add_trace_getrq(void *ignore,\n\t\t\t\tstruct request_queue *q,\n\t\t\t\tstruct bio *bio, int rw)\n{\n\tif (bio)\n\t\tblk_add_trace_bio(q, bio, BLK_TA_GETRQ, 0);\n\telse {\n\t\tstruct blk_trace *bt = q->blk_trace;\n\n\t\tif (bt)\n\t\t\t__blk_add_trace(bt, 0, 0, rw, 0, BLK_TA_GETRQ, 0, 0,\n\t\t\t\t\tNULL, NULL);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "0",
            "0",
            "rw",
            "0",
            "BLK_TA_GETRQ",
            "0",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_GETRQ",
            "0"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_getrq(void *ignore,\n\t\t\t\tstruct request_queue *q,\n\t\t\t\tstruct bio *bio, int rw)\n{\n\tif (bio)\n\t\tblk_add_trace_bio(q, bio, BLK_TA_GETRQ, 0);\n\telse {\n\t\tstruct blk_trace *bt = q->blk_trace;\n\n\t\tif (bt)\n\t\t\t__blk_add_trace(bt, 0, 0, rw, 0, BLK_TA_GETRQ, 0, 0,\n\t\t\t\t\tNULL, NULL);\n\t}\n}"
  },
  {
    "function_name": "blk_add_trace_bio_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "904-908",
    "snippet": "static void blk_add_trace_bio_queue(void *ignore,\n\t\t\t\t    struct request_queue *q, struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_QUEUE, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_QUEUE",
            "0"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_queue(void *ignore,\n\t\t\t\t    struct request_queue *q, struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_QUEUE, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_frontmerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "896-902",
    "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_FRONTMERGE",
            "0"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_backmerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "888-894",
    "snippet": "static void blk_add_trace_bio_backmerge(void *ignore,\n\t\t\t\t\tstruct request_queue *q,\n\t\t\t\t\tstruct request *rq,\n\t\t\t\t\tstruct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_BACKMERGE, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_BACKMERGE",
            "0"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_backmerge(void *ignore,\n\t\t\t\t\tstruct request_queue *q,\n\t\t\t\t\tstruct request *rq,\n\t\t\t\t\tstruct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_BACKMERGE, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "881-886",
    "snippet": "static void blk_add_trace_bio_complete(void *ignore,\n\t\t\t\t       struct request_queue *q, struct bio *bio,\n\t\t\t\t       int error)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_COMPLETE, error);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_COMPLETE",
            "error"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_complete(void *ignore,\n\t\t\t\t       struct request_queue *q, struct bio *bio,\n\t\t\t\t       int error)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_COMPLETE, error);\n}"
  },
  {
    "function_name": "blk_add_trace_bio_bounce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "875-879",
    "snippet": "static void blk_add_trace_bio_bounce(void *ignore,\n\t\t\t\t     struct request_queue *q, struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_BOUNCE, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_bio",
          "args": [
            "q",
            "bio",
            "BLK_TA_BOUNCE",
            "0"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_bio_frontmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "896-902",
          "snippet": "static void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_frontmerge(void *ignore,\n\t\t\t\t\t struct request_queue *q,\n\t\t\t\t\t struct request *rq,\n\t\t\t\t\t struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio_bounce(void *ignore,\n\t\t\t\t     struct request_queue *q, struct bio *bio)\n{\n\tblk_add_trace_bio(q, bio, BLK_TA_BOUNCE, 0);\n}"
  },
  {
    "function_name": "blk_add_trace_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "862-873",
    "snippet": "static void blk_add_trace_bio(struct request_queue *q, struct bio *bio,\n\t\t\t      u32 what, int error)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, what, error, 0, NULL,\n\t\t\tblk_trace_bio_get_cgid(q, bio));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "bio->bi_iter.bi_sector",
            "bio->bi_iter.bi_size",
            "bio_op(bio)",
            "bio->bi_opf",
            "what",
            "error",
            "0",
            "NULL",
            "blk_trace_bio_get_cgid(q, bio)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "bio"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "772-776",
          "snippet": "static union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_bio(struct request_queue *q, struct bio *bio,\n\t\t\t      u32 what, int error)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\t__blk_add_trace(bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size,\n\t\t\tbio_op(bio), bio->bi_opf, what, error, 0, NULL,\n\t\t\tblk_trace_bio_get_cgid(q, bio));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "844-849",
    "snippet": "static void blk_add_trace_rq_complete(void *ignore, struct request *rq,\n\t\t\tint error, unsigned int nr_bytes)\n{\n\tblk_add_trace_rq(rq, error, nr_bytes, BLK_TA_COMPLETE,\n\t\t\t blk_trace_request_get_cgid(rq->q, rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "error",
            "nr_bytes",
            "BLK_TA_COMPLETE",
            "blk_trace_request_get_cgid(rq->q, rq)"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1028-1046",
          "snippet": "static void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "rq->q",
            "rq"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "779-786",
          "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_complete(void *ignore, struct request *rq,\n\t\t\tint error, unsigned int nr_bytes)\n{\n\tblk_add_trace_rq(rq, error, nr_bytes, BLK_TA_COMPLETE,\n\t\t\t blk_trace_request_get_cgid(rq->q, rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_requeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "836-842",
    "snippet": "static void blk_add_trace_rq_requeue(void *ignore,\n\t\t\t\t     struct request_queue *q,\n\t\t\t\t     struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_REQUEUE,\n\t\t\t blk_trace_request_get_cgid(q, rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_REQUEUE",
            "blk_trace_request_get_cgid(q, rq)"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1028-1046",
          "snippet": "static void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "q",
            "rq"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "779-786",
          "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_requeue(void *ignore,\n\t\t\t\t     struct request_queue *q,\n\t\t\t\t     struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_REQUEUE,\n\t\t\t blk_trace_request_get_cgid(q, rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_issue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "829-834",
    "snippet": "static void blk_add_trace_rq_issue(void *ignore,\n\t\t\t\t   struct request_queue *q, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_ISSUE,\n\t\t\t blk_trace_request_get_cgid(q, rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_ISSUE",
            "blk_trace_request_get_cgid(q, rq)"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1028-1046",
          "snippet": "static void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "q",
            "rq"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "779-786",
          "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_issue(void *ignore,\n\t\t\t\t   struct request_queue *q, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_ISSUE,\n\t\t\t blk_trace_request_get_cgid(q, rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "822-827",
    "snippet": "static void blk_add_trace_rq_insert(void *ignore,\n\t\t\t\t    struct request_queue *q, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_INSERT,\n\t\t\t blk_trace_request_get_cgid(q, rq));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_add_trace_rq",
          "args": [
            "rq",
            "0",
            "blk_rq_bytes(rq)",
            "BLK_TA_INSERT",
            "blk_trace_request_get_cgid(q, rq)"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "blk_add_trace_rq_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1028-1046",
          "snippet": "static void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_remap(void *ignore,\n\t\t\t\t   struct request_queue *q,\n\t\t\t\t   struct request *rq, dev_t dev,\n\t\t\t\t   sector_t from)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\tstruct blk_io_trace_remap r;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tr.device_from = cpu_to_be32(dev);\n\tr.device_to   = cpu_to_be32(disk_devt(rq->rq_disk));\n\tr.sector_from = cpu_to_be64(from);\n\n\t__blk_add_trace(bt, blk_rq_pos(rq), blk_rq_bytes(rq),\n\t\t\trq_data_dir(rq), 0, BLK_TA_REMAP, 0,\n\t\t\tsizeof(r), &r, blk_trace_request_get_cgid(q, rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_request_get_cgid",
          "args": [
            "q",
            "rq"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_request_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "779-786",
          "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_rq_bytes",
          "args": [
            "rq"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq_insert(void *ignore,\n\t\t\t\t    struct request_queue *q, struct request *rq)\n{\n\tblk_add_trace_rq(rq, 0, blk_rq_bytes(rq), BLK_TA_INSERT,\n\t\t\t blk_trace_request_get_cgid(q, rq));\n}"
  },
  {
    "function_name": "blk_add_trace_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "804-820",
    "snippet": "static void blk_add_trace_rq(struct request *rq, int error,\n\t\t\t     unsigned int nr_bytes, u32 what,\n\t\t\t     union kernfs_node_id *cgid)\n{\n\tstruct blk_trace *bt = rq->q->blk_trace;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, error, 0, NULL, cgid);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_add_trace",
          "args": [
            "bt",
            "blk_rq_trace_sector(rq)",
            "nr_bytes",
            "req_op(rq)",
            "rq->cmd_flags",
            "what",
            "error",
            "0",
            "NULL",
            "cgid"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_add_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "213-308",
          "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "req_op",
          "args": [
            "rq"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_trace_sector",
          "args": [
            "rq"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_FS"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_PC"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_is_passthrough",
          "args": [
            "rq"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!bt"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_add_trace_rq(struct request *rq, int error,\n\t\t\t     unsigned int nr_bytes, u32 what,\n\t\t\t     union kernfs_node_id *cgid)\n{\n\tstruct blk_trace *bt = rq->q->blk_trace;\n\n\tif (likely(!bt))\n\t\treturn;\n\n\tif (blk_rq_is_passthrough(rq))\n\t\twhat |= BLK_TC_ACT(BLK_TC_PC);\n\telse\n\t\twhat |= BLK_TC_ACT(BLK_TC_FS);\n\n\t__blk_add_trace(bt, blk_rq_trace_sector(rq), nr_bytes, req_op(rq),\n\t\t\trq->cmd_flags, what, error, 0, NULL, cgid);\n}"
  },
  {
    "function_name": "blk_trace_request_get_cgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "779-786",
    "snippet": "static union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_bio_get_cgid",
          "args": [
            "q",
            "rq->bio"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_bio_get_cgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "772-776",
          "snippet": "static union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_request_get_cgid(struct request_queue *q, struct request *rq)\n{\n\tif (!rq->bio)\n\t\treturn NULL;\n\t/* Use the first bio */\n\treturn blk_trace_bio_get_cgid(q, rq->bio);\n}"
  },
  {
    "function_name": "blk_trace_bio_get_cgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "772-776",
    "snippet": "static union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "blk_trace_bio_get_cgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "759-770",
    "snippet": "static union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (!bt || !(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\treturn NULL;\n\n\tif (!bio->bi_css)\n\t\treturn NULL;\n\treturn cgroup_get_kernfs_id(bio->bi_css->cgroup);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CGROUP\t0x2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_get_kernfs_id",
          "args": [
            "bio->bi_css->cgroup"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nstatic union kernfs_node_id *\nblk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)\n{\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (!bt || !(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\treturn NULL;\n\n\tif (!bio->bi_css)\n\t\treturn NULL;\n\treturn cgroup_get_kernfs_id(bio->bi_css->cgroup);\n}"
  },
  {
    "function_name": "blk_trace_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "746-756",
    "snippet": "void blk_trace_shutdown(struct request_queue *q)\n{\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tif (q->blk_trace) {\n\t\t__blk_trace_startstop(q, 0);\n\t\t__blk_trace_remove(q);\n\t}\n\n\tmutex_unlock(&q->blk_trace_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "343-355",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_startstop",
          "args": [
            "q",
            "0"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_startstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "636-674",
          "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nvoid blk_trace_shutdown(struct request_queue *q)\n{\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tif (q->blk_trace) {\n\t\t__blk_trace_startstop(q, 0);\n\t\t__blk_trace_remove(q);\n\t}\n\n\tmutex_unlock(&q->blk_trace_mutex);\n}"
  },
  {
    "function_name": "blk_trace_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "701-739",
    "snippet": "int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)\n{\n\tstruct request_queue *q;\n\tint ret, start = 0;\n\tchar b[BDEVNAME_SIZE];\n\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tswitch (cmd) {\n\tcase BLKTRACESETUP:\n\t\tbdevname(bdev, b);\n\t\tret = __blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)\n\tcase BLKTRACESETUP32:\n\t\tbdevname(bdev, b);\n\t\tret = compat_blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#endif\n\tcase BLKTRACESTART:\n\t\tstart = 1;\n\tcase BLKTRACESTOP:\n\t\tret = __blk_trace_startstop(q, start);\n\t\tbreak;\n\tcase BLKTRACETEARDOWN:\n\t\tret = __blk_trace_remove(q);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&q->blk_trace_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "343-355",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_startstop",
          "args": [
            "q",
            "start"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_startstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "636-674",
          "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_blk_trace_setup",
          "args": [
            "q",
            "b",
            "bdev->bd_dev",
            "bdev",
            "arg"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "compat_blk_trace_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "603-633",
          "snippet": "static int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blk_trace_setup",
          "args": [
            "q",
            "b",
            "bdev->bd_dev",
            "bdev",
            "arg"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "567-586",
          "snippet": "static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)\n{\n\tstruct request_queue *q;\n\tint ret, start = 0;\n\tchar b[BDEVNAME_SIZE];\n\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\n\tswitch (cmd) {\n\tcase BLKTRACESETUP:\n\t\tbdevname(bdev, b);\n\t\tret = __blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)\n\tcase BLKTRACESETUP32:\n\t\tbdevname(bdev, b);\n\t\tret = compat_blk_trace_setup(q, b, bdev->bd_dev, bdev, arg);\n\t\tbreak;\n#endif\n\tcase BLKTRACESTART:\n\t\tstart = 1;\n\tcase BLKTRACESTOP:\n\t\tret = __blk_trace_startstop(q, start);\n\t\tbreak;\n\tcase BLKTRACETEARDOWN:\n\t\tret = __blk_trace_remove(q);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&q->blk_trace_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_startstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "676-685",
    "snippet": "int blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\tret = __blk_trace_startstop(q, start);\n\tmutex_unlock(&q->blk_trace_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_startstop",
          "args": [
            "q",
            "start"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_startstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "636-674",
          "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\tret = __blk_trace_startstop(q, start);\n\tmutex_unlock(&q->blk_trace_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__blk_trace_startstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "636-674",
    "snippet": "static int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relay_flush",
          "args": [
            "bt->rchan"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "relay_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "865-883",
          "snippet": "void relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_flush(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0))) {\n\t\trelay_switch_subbuf(buf, 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_switch_subbuf(buf, 0);\n\tmutex_unlock(&relay_channels_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&running_trace_lock"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bt->running_list"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&running_trace_lock"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_note_time",
          "args": [
            "bt"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "trace_note_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "130-144",
          "snippet": "static void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), NULL);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), NULL);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bt->running_list",
            "&running_trace_list"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_startstop(struct request_queue *q, int start)\n{\n\tint ret;\n\tstruct blk_trace *bt = q->blk_trace;\n\n\tif (bt == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * For starting a trace, we can transition from a setup or stopped\n\t * trace. For stopping a trace, the state must be running\n\t */\n\tret = -EINVAL;\n\tif (start) {\n\t\tif (bt->trace_state == Blktrace_setup ||\n\t\t    bt->trace_state == Blktrace_stopped) {\n\t\t\tblktrace_seq++;\n\t\t\tsmp_mb();\n\t\t\tbt->trace_state = Blktrace_running;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_add(&bt->running_list, &running_trace_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\n\t\t\ttrace_note_time(bt);\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tif (bt->trace_state == Blktrace_running) {\n\t\t\tbt->trace_state = Blktrace_stopped;\n\t\t\tspin_lock_irq(&running_trace_lock);\n\t\t\tlist_del_init(&bt->running_list);\n\t\t\tspin_unlock_irq(&running_trace_lock);\n\t\t\trelay_flush(bt->rchan);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_blk_trace_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "603-633",
    "snippet": "static int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "343-355",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&buts.name",
            "ARRAY_SIZE(buts.name)"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buts.name"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_blk_trace_setup",
          "args": [
            "q",
            "name",
            "dev",
            "bdev",
            "&buts"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "do_blk_trace_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "474-565",
          "snippet": "static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tif (!blk_debugfs_root)\n\t\treturn -ENOENT;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file(\"dropped\", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tif (!blk_debugfs_root)\n\t\treturn -ENOENT;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file(\"dropped\", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cbuts",
            "arg",
            "sizeof(cbuts)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int compat_blk_trace_setup(struct request_queue *q, char *name,\n\t\t\t\t  dev_t dev, struct block_device *bdev,\n\t\t\t\t  char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tstruct compat_blk_user_trace_setup cbuts;\n\tint ret;\n\n\tif (copy_from_user(&cbuts, arg, sizeof(cbuts)))\n\t\treturn -EFAULT;\n\n\tbuts = (struct blk_user_trace_setup) {\n\t\t.act_mask = cbuts.act_mask,\n\t\t.buf_size = cbuts.buf_size,\n\t\t.buf_nr = cbuts.buf_nr,\n\t\t.start_lba = cbuts.start_lba,\n\t\t.end_lba = cbuts.end_lba,\n\t\t.pid = cbuts.pid,\n\t};\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts.name, ARRAY_SIZE(buts.name))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_trace_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "588-599",
    "snippet": "int blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t    struct block_device *bdev,\n\t\t    char __user *arg)\n{\n\tint ret;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\tret = __blk_trace_setup(q, name, dev, bdev, arg);\n\tmutex_unlock(&q->blk_trace_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_setup",
          "args": [
            "q",
            "name",
            "dev",
            "bdev",
            "arg"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "567-586",
          "snippet": "static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t    struct block_device *bdev,\n\t\t    char __user *arg)\n{\n\tint ret;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\tret = __blk_trace_setup(q, name, dev, bdev, arg);\n\tmutex_unlock(&q->blk_trace_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__blk_trace_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "567-586",
    "snippet": "static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "343-355",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&buts",
            "sizeof(buts)"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_blk_trace_setup",
          "args": [
            "q",
            "name",
            "dev",
            "bdev",
            "&buts"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "do_blk_trace_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "474-565",
          "snippet": "static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tif (!blk_debugfs_root)\n\t\treturn -ENOENT;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file(\"dropped\", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tif (!blk_debugfs_root)\n\t\treturn -ENOENT;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file(\"dropped\", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&buts",
            "arg",
            "sizeof(buts)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t     struct block_device *bdev, char __user *arg)\n{\n\tstruct blk_user_trace_setup buts;\n\tint ret;\n\n\tret = copy_from_user(&buts, arg, sizeof(buts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tret = do_blk_trace_setup(q, name, dev, bdev, &buts);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &buts, sizeof(buts))) {\n\t\t__blk_trace_remove(q);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_blk_trace_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "474-565",
    "snippet": "static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tif (!blk_debugfs_root)\n\t\treturn -ENOENT;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file(\"dropped\", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "310-319",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_probe_ref",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "get_probe_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "321-327",
          "snippet": "static void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&q->blk_trace",
            "NULL",
            "bt"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_trace_setup_lba",
          "args": [
            "bt",
            "bdev"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_setup_lba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "454-469",
          "snippet": "static void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tstruct hd_struct *part = NULL;\n\n\tif (bdev)\n\t\tpart = bdev->bd_part;\n\n\tif (part) {\n\t\tbt->start_lba = part->start_sect;\n\t\tbt->end_lba = part->start_sect + part->nr_sects;\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tstruct hd_struct *part = NULL;\n\n\tif (bdev)\n\t\tpart = bdev->bd_part;\n\n\tif (part) {\n\t\tbt->start_lba = part->start_sect;\n\t\tbt->end_lba = part->start_sect + part->nr_sects;\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_open",
          "args": [
            "\"trace\"",
            "dir",
            "buts->buf_size",
            "buts->buf_nr",
            "&blk_relay_callbacks",
            "bt"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "relay_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "561-616",
          "snippet": "struct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn NULL;\n\tif (subbuf_size > UINT_MAX / n_subbufs)\n\t\treturn NULL;\n\n\tchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->buf = alloc_percpu(struct rchan_buf *);\n\tchan->version = RELAYFS_CHANNEL_VERSION;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = PAGE_ALIGN(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\t}\n\tsetup_callbacks(chan, cb);\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tbuf = relay_open_buf(chan, i);\n\t\tif (!buf)\n\t\t\tgoto free_bufs;\n\t\t*per_cpu_ptr(chan->buf, i) = buf;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_close_buf(buf);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);",
            "static LIST_HEAD(relay_channels);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\nstatic LIST_HEAD(relay_channels);\n\nstruct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\tstruct rchan_buf *buf;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn NULL;\n\tif (subbuf_size > UINT_MAX / n_subbufs)\n\t\treturn NULL;\n\n\tchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn NULL;\n\n\tchan->buf = alloc_percpu(struct rchan_buf *);\n\tchan->version = RELAYFS_CHANNEL_VERSION;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = PAGE_ALIGN(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, NAME_MAX);\n\t}\n\tsetup_callbacks(chan, cb);\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tbuf = relay_open_buf(chan, i);\n\t\tif (!buf)\n\t\t\tgoto free_bufs;\n\t\t*per_cpu_ptr(chan->buf, i) = buf;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\trelay_close_buf(buf);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"msg\"",
            "0222",
            "dir",
            "bt",
            "&blk_msg_fops"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"dropped\"",
            "0444",
            "dir",
            "bt",
            "&blk_dropped_fops"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bt->running_list"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bt->dropped",
            "0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "buts->name",
            "blk_debugfs_root"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_lookup",
          "args": [
            "buts->name",
            "blk_debugfs_root"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "BLK_TN_MAX_MSG",
            "__alignof__(char)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "unsignedlong"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bt)",
            "GFP_KERNEL"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "buts->name",
            "'/'",
            "'_'"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buts->name",
            "name",
            "BLKTRACE_BDEV_SIZE"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct blk_user_trace_setup *buts)\n{\n\tstruct blk_trace *bt = NULL;\n\tstruct dentry *dir = NULL;\n\tint ret;\n\n\tif (!buts->buf_size || !buts->buf_nr)\n\t\treturn -EINVAL;\n\n\tif (!blk_debugfs_root)\n\t\treturn -ENOENT;\n\n\tstrncpy(buts->name, name, BLKTRACE_BDEV_SIZE);\n\tbuts->name[BLKTRACE_BDEV_SIZE - 1] = '\\0';\n\n\t/*\n\t * some device names have larger paths - convert the slashes\n\t * to underscores for this to work as expected\n\t */\n\tstrreplace(buts->name, '/', '_');\n\n\tbt = kzalloc(sizeof(*bt), GFP_KERNEL);\n\tif (!bt)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tbt->sequence = alloc_percpu(unsigned long);\n\tif (!bt->sequence)\n\t\tgoto err;\n\n\tbt->msg_data = __alloc_percpu(BLK_TN_MAX_MSG, __alignof__(char));\n\tif (!bt->msg_data)\n\t\tgoto err;\n\n\tret = -ENOENT;\n\n\tdir = debugfs_lookup(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tbt->dir = dir = debugfs_create_dir(buts->name, blk_debugfs_root);\n\tif (!dir)\n\t\tgoto err;\n\n\tbt->dev = dev;\n\tatomic_set(&bt->dropped, 0);\n\tINIT_LIST_HEAD(&bt->running_list);\n\n\tret = -EIO;\n\tbt->dropped_file = debugfs_create_file(\"dropped\", 0444, dir, bt,\n\t\t\t\t\t       &blk_dropped_fops);\n\tif (!bt->dropped_file)\n\t\tgoto err;\n\n\tbt->msg_file = debugfs_create_file(\"msg\", 0222, dir, bt, &blk_msg_fops);\n\tif (!bt->msg_file)\n\t\tgoto err;\n\n\tbt->rchan = relay_open(\"trace\", dir, buts->buf_size,\n\t\t\t\tbuts->buf_nr, &blk_relay_callbacks, bt);\n\tif (!bt->rchan)\n\t\tgoto err;\n\n\tbt->act_mask = buts->act_mask;\n\tif (!bt->act_mask)\n\t\tbt->act_mask = (u16) -1;\n\n\tblk_trace_setup_lba(bt, bdev);\n\n\t/* overwrite with user settings */\n\tif (buts->start_lba)\n\t\tbt->start_lba = buts->start_lba;\n\tif (buts->end_lba)\n\t\tbt->end_lba = buts->end_lba;\n\n\tbt->pid = buts->pid;\n\tbt->trace_state = Blktrace_setup;\n\n\tret = -EBUSY;\n\tif (cmpxchg(&q->blk_trace, NULL, bt))\n\t\tgoto err;\n\n\tget_probe_ref();\n\n\tret = 0;\nerr:\n\tif (dir && !bt->dir)\n\t\tdput(dir);\n\tif (ret)\n\t\tblk_trace_free(bt);\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_trace_setup_lba",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "454-469",
    "snippet": "static void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tstruct hd_struct *part = NULL;\n\n\tif (bdev)\n\t\tpart = bdev->bd_part;\n\n\tif (part) {\n\t\tbt->start_lba = part->start_sect;\n\t\tbt->end_lba = part->start_sect + part->nr_sects;\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_setup_lba(struct blk_trace *bt,\n\t\t\t\tstruct block_device *bdev)\n{\n\tstruct hd_struct *part = NULL;\n\n\tif (bdev)\n\t\tpart = bdev->bd_part;\n\n\tif (part) {\n\t\tbt->start_lba = part->start_sect;\n\t\tbt->end_lba = part->start_sect + part->nr_sects;\n\t} else {\n\t\tbt->start_lba = 0;\n\t\tbt->end_lba = -1ULL;\n\t}\n}"
  },
  {
    "function_name": "blk_create_buf_file_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "438-446",
    "snippet": "static struct dentry *blk_create_buf_file_callback(const char *filename,\n\t\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t\t   umode_t mode,\n\t\t\t\t\t\t   struct rchan_buf *buf,\n\t\t\t\t\t\t   int *is_global)\n{\n\treturn debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t\t&relay_file_operations);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "filename",
            "mode",
            "parent",
            "buf",
            "&relay_file_operations"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *blk_create_buf_file_callback(const char *filename,\n\t\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t\t   umode_t mode,\n\t\t\t\t\t\t   struct rchan_buf *buf,\n\t\t\t\t\t\t   int *is_global)\n{\n\treturn debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t\t&relay_file_operations);\n}"
  },
  {
    "function_name": "blk_remove_buf_file_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "431-436",
    "snippet": "static int blk_remove_buf_file_callback(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "dentry"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_remove_buf_file_callback(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_subbuf_start_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "418-429",
    "snippet": "static int blk_subbuf_start_callback(struct rchan_buf *buf, void *subbuf,\n\t\t\t\t     void *prev_subbuf, size_t prev_padding)\n{\n\tstruct blk_trace *bt;\n\n\tif (!relay_buf_full(buf))\n\t\treturn 1;\n\n\tbt = buf->chan->private_data;\n\tatomic_inc(&bt->dropped);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bt->dropped"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_buf_full",
          "args": [
            "buf"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "relay_buf_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "255-259",
          "snippet": "int relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nint relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int blk_subbuf_start_callback(struct rchan_buf *buf, void *subbuf,\n\t\t\t\t     void *prev_subbuf, size_t prev_padding)\n{\n\tstruct blk_trace *bt;\n\n\tif (!relay_buf_full(buf))\n\t\treturn 1;\n\n\tbt = buf->chan->private_data;\n\tatomic_inc(&bt->dropped);\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_msg_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "387-405",
    "snippet": "static ssize_t blk_msg_write(struct file *filp, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *msg;\n\tstruct blk_trace *bt;\n\n\tif (count >= BLK_TN_MAX_MSG)\n\t\treturn -EINVAL;\n\n\tmsg = memdup_user_nul(buffer, count);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tbt = filp->private_data;\n\t__trace_note_message(bt, NULL, \"%s\", msg);\n\tkfree(msg);\n\n\treturn count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_note_message",
          "args": [
            "bt",
            "NULL",
            "\"%s\"",
            "msg"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "146-180",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGROUP\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msg"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msg"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buffer",
            "count"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_msg_write(struct file *filp, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *msg;\n\tstruct blk_trace *bt;\n\n\tif (count >= BLK_TN_MAX_MSG)\n\t\treturn -EINVAL;\n\n\tmsg = memdup_user_nul(buffer, count);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tbt = filp->private_data;\n\t__trace_note_message(bt, NULL, \"%s\", msg);\n\tkfree(msg);\n\n\treturn count;\n}"
  },
  {
    "function_name": "blk_dropped_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "369-378",
    "snippet": "static ssize_t blk_dropped_read(struct file *filp, char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct blk_trace *bt = filp->private_data;\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"%u\\n\", atomic_read(&bt->dropped));\n\n\treturn simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buffer",
            "count",
            "ppos",
            "buf",
            "strlen(buf)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%u\\n\"",
            "atomic_read(&bt->dropped)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bt->dropped"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic ssize_t blk_dropped_read(struct file *filp, char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct blk_trace *bt = filp->private_data;\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"%u\\n\", atomic_read(&bt->dropped));\n\n\treturn simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));\n}"
  },
  {
    "function_name": "blk_trace_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "357-366",
    "snippet": "int blk_trace_remove(struct request_queue *q)\n{\n\tint ret;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\tret = __blk_trace_remove(q);\n\tmutex_unlock(&q->blk_trace_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blk_trace_remove",
          "args": [
            "q"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__blk_trace_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "343-355",
          "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&q->blk_trace_mutex"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nint blk_trace_remove(struct request_queue *q)\n{\n\tint ret;\n\n\tmutex_lock(&q->blk_trace_mutex);\n\tret = __blk_trace_remove(q);\n\tmutex_unlock(&q->blk_trace_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__blk_trace_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "343-355",
    "snippet": "static int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_trace_cleanup",
          "args": [
            "bt"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "337-341",
          "snippet": "static void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&q->blk_trace",
            "NULL"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int __blk_trace_remove(struct request_queue *q)\n{\n\tstruct blk_trace *bt;\n\n\tbt = xchg(&q->blk_trace, NULL);\n\tif (!bt)\n\t\treturn -EINVAL;\n\n\tif (bt->trace_state != Blktrace_running)\n\t\tblk_trace_cleanup(bt);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blk_trace_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "337-341",
    "snippet": "static void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_probe_ref",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "put_probe_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "329-335",
          "snippet": "static void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_trace_free",
          "args": [
            "bt"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "blk_trace_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "310-319",
          "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_cleanup(struct blk_trace *bt)\n{\n\tblk_trace_free(bt);\n\tput_probe_ref();\n}"
  },
  {
    "function_name": "put_probe_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "329-335",
    "snippet": "static void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_unregister_tracepoints",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "blk_unregister_tracepoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1112-1132",
          "snippet": "static void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_unregister_tracepoints(void)\n{\n\tunregister_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tunregister_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tunregister_trace_block_split(blk_add_trace_split, NULL);\n\tunregister_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tunregister_trace_block_plug(blk_add_trace_plug, NULL);\n\tunregister_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tunregister_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tunregister_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tunregister_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tunregister_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tunregister_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tunregister_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tunregister_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tunregister_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tunregister_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tunregister_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\n\ttracepoint_synchronize_unregister();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void put_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (!--blk_probes_ref)\n\t\tblk_unregister_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
  },
  {
    "function_name": "get_probe_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "321-327",
    "snippet": "static void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_register_tracepoints",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "blk_register_tracepoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "1074-1110",
          "snippet": "static void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_register_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_trace_block_rq_insert(blk_add_trace_rq_insert, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_issue(blk_add_trace_rq_issue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_requeue(blk_add_trace_rq_requeue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_complete(blk_add_trace_rq_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_bounce(blk_add_trace_bio_bounce, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_complete(blk_add_trace_bio_complete, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_backmerge(blk_add_trace_bio_backmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_frontmerge(blk_add_trace_bio_frontmerge, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_queue(blk_add_trace_bio_queue, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_getrq(blk_add_trace_getrq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_sleeprq(blk_add_trace_sleeprq, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_plug(blk_add_trace_plug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_unplug(blk_add_trace_unplug, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_split(blk_add_trace_split, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_bio_remap(blk_add_trace_bio_remap, NULL);\n\tWARN_ON(ret);\n\tret = register_trace_block_rq_remap(blk_add_trace_rq_remap, NULL);\n\tWARN_ON(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&blk_probe_mutex"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void get_probe_ref(void)\n{\n\tmutex_lock(&blk_probe_mutex);\n\tif (++blk_probes_ref == 1)\n\t\tblk_register_tracepoints();\n\tmutex_unlock(&blk_probe_mutex);\n}"
  },
  {
    "function_name": "blk_trace_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "310-319",
    "snippet": "static void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bt"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "bt->msg_data"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "bt->dir"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_close",
          "args": [
            "bt->rchan"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "relay_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "832-856",
          "snippet": "void relay_close(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0)))\n\t\trelay_close_buf(buf);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t\trelay_close_buf(buf);\n\n\tif (chan->last_toobig)\n\t\tprintk(KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(relay_channels_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic DEFINE_MUTEX(relay_channels_mutex);\n\nvoid relay_close(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && (buf = *per_cpu_ptr(chan->buf, 0)))\n\t\trelay_close_buf(buf);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif ((buf = *per_cpu_ptr(chan->buf, i)))\n\t\t\t\trelay_close_buf(buf);\n\n\tif (chan->last_toobig)\n\t\tprintk(KERN_WARNING \"relay: one or more items not logged \"\n\t\t       \"[item size (%zd) > sub-buffer size (%zd)]\\n\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void blk_trace_free(struct blk_trace *bt)\n{\n\tdebugfs_remove(bt->msg_file);\n\tdebugfs_remove(bt->dropped_file);\n\trelay_close(bt->rchan);\n\tdebugfs_remove(bt->dir);\n\tfree_percpu(bt->sequence);\n\tfree_percpu(bt->msg_data);\n\tkfree(bt);\n}"
  },
  {
    "function_name": "__blk_add_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "213-308",
    "snippet": "static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "blk_tr",
            "buffer",
            "event",
            "0",
            "pc"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1250-1256",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)t + sizeof(*t) + cgid_len",
            "pdu_data",
            "pdu_len"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "bt->sequence",
            "cpu"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relay_reserve",
          "args": [
            "bt->rchan",
            "sizeof(*t) + pdu_len + cgid_len"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_note_tsk",
          "args": [
            "tsk"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "trace_note_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "116-128",
          "snippet": "static void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\tspin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), NULL);\n\t}\n\tspin_unlock_irqrestore(&running_trace_lock, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\tspin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), NULL);\n\t}\n\tspin_unlock_irqrestore(&running_trace_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->btrace_seq != blktrace_seq"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_BLK",
            "sizeof(*t) + pdu_len + cgid_len",
            "0",
            "pc"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_record_cmdline",
          "args": [
            "current"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2108-2111",
          "snippet": "void tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "act_log_check",
          "args": [
            "bt",
            "what",
            "sector",
            "pid"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "act_log_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "183-194",
          "snippet": "static int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_FLUSH"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_TC_ACT",
          "args": [
            "BLK_TC_DISCARD"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "FUA"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "PREFLUSH"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "META"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "RAHEAD"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MASK_TC_BIT",
          "args": [
            "op_flags",
            "SYNC"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_write",
          "args": [
            "op"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bt->trace_state != Blktrace_running && !blk_tracer"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int op, int op_flags, u32 what, int error, int pdu_len,\n\t\t     void *pdu_data, union kernfs_node_id *cgid)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (unlikely(bt->trace_state != Blktrace_running && !blk_tracer))\n\t\treturn;\n\n\twhat |= ddir_act[op_is_write(op) ? WRITE : READ];\n\twhat |= MASK_TC_BIT(op_flags, SYNC);\n\twhat |= MASK_TC_BIT(op_flags, RAHEAD);\n\twhat |= MASK_TC_BIT(op_flags, META);\n\twhat |= MASK_TC_BIT(op_flags, PREFLUSH);\n\twhat |= MASK_TC_BIT(op_flags, FUA);\n\tif (op == REQ_OP_DISCARD || op == REQ_OP_SECURE_ERASE)\n\t\twhat |= BLK_TC_ACT(BLK_TC_DISCARD);\n\tif (op == REQ_OP_FLUSH)\n\t\twhat |= BLK_TC_ACT(BLK_TC_FLUSH);\n\tif (cgid)\n\t\twhat |= __BLK_TA_CGROUP;\n\n\tpid = tsk->pid;\n\tif (act_log_check(bt, what, sector, pid))\n\t\treturn;\n\tcpu = raw_smp_processor_id();\n\n\tif (blk_tracer) {\n\t\ttracing_record_cmdline(current);\n\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + pdu_len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (unlikely(tsk->btrace_seq != blktrace_seq))\n\t\ttrace_note_tsk(tsk);\n\n\t/*\n\t * A word about the locking here - we disable interrupts to reserve\n\t * some space in the relay per-cpu buffer, to prevent an irq\n\t * from coming in and stepping on our toes.\n\t */\n\tlocal_irq_save(flags);\n\tt = relay_reserve(bt->rchan, sizeof(*t) + pdu_len + cgid_len);\n\tif (t) {\n\t\tsequence = per_cpu_ptr(bt->sequence, cpu);\n\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->sequence = ++(*sequence);\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\t/*\n\t\t * These two are not needed in ftrace as they are in the\n\t\t * generic trace_entry, filled by tracing_generic_entry_update,\n\t\t * but for the trace_event->bin() synthesizer benefit we do it\n\t\t * here too.\n\t\t */\n\t\tt->cpu = cpu;\n\t\tt->pid = pid;\n\n\t\tt->sector = sector;\n\t\tt->bytes = bytes;\n\t\tt->action = what;\n\t\tt->device = bt->dev;\n\t\tt->error = error;\n\t\tt->pdu_len = pdu_len + cgid_len;\n\n\t\tif (cgid_len)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tif (pdu_len)\n\t\t\tmemcpy((void *)t + sizeof(*t) + cgid_len, pdu_data, pdu_len);\n\n\t\tif (blk_tracer) {\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "act_log_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "183-194",
    "snippet": "static int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic int act_log_check(struct blk_trace *bt, u32 what, sector_t sector,\n\t\t\t pid_t pid)\n{\n\tif (((bt->act_mask << BLK_TC_SHIFT) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->start_lba || sector > bt->end_lba))\n\t\treturn 1;\n\tif (bt->pid && pid != bt->pid)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__trace_note_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "146-180",
    "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TRACE_BLK_OPT_CGROUP\t0x2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_note",
          "args": [
            "bt",
            "0",
            "BLK_TN_MESSAGE",
            "buf",
            "n",
            "NULL"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "146-180",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_get_kernfs_id",
          "args": [
            "blkcg->css.cgroup"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vscnprintf",
          "args": [
            "buf",
            "BLK_TN_MAX_MSG",
            "fmt",
            "args"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "bt->msg_data"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "trace_note_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "130-144",
    "snippet": "static void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), NULL);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_note",
          "args": [
            "bt",
            "0",
            "BLK_TN_TIMESTAMP",
            "words",
            "sizeof(words)",
            "NULL"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "146-180",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGROUP\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&now"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "723-741",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_time(struct blk_trace *bt)\n{\n\tstruct timespec64 now;\n\tunsigned long flags;\n\tu32 words[2];\n\n\t/* need to check user space to see if this breaks in y2038 or y2106 */\n\tktime_get_real_ts64(&now);\n\twords[0] = (u32)now.tv_sec;\n\twords[1] = now.tv_nsec;\n\n\tlocal_irq_save(flags);\n\ttrace_note(bt, 0, BLK_TN_TIMESTAMP, words, sizeof(words), NULL);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "trace_note_tsk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "116-128",
    "snippet": "static void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\tspin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), NULL);\n\t}\n\tspin_unlock_irqrestore(&running_trace_lock, flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&running_trace_lock",
            "flags"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_note",
          "args": [
            "bt",
            "tsk->pid",
            "BLK_TN_PROCESS",
            "tsk->comm",
            "sizeof(tsk->comm)",
            "NULL"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_note_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
          "lines": "146-180",
          "snippet": "void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <trace/events/block.h>",
            "#include \"../../block/blk.h\"",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/blktrace_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TRACE_BLK_OPT_CGROUP\t0x2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\n#define TRACE_BLK_OPT_CGROUP\t0x2\n\nvoid __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,\n\tconst char *fmt, ...)\n{\n\tint n;\n\tva_list args;\n\tunsigned long flags;\n\tchar *buf;\n\n\tif (unlikely(bt->trace_state != Blktrace_running &&\n\t\t     !blk_tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * If the BLK_TC_NOTIFY action mask isn't set, don't send any note\n\t * message to the trace.\n\t */\n\tif (!(bt->act_mask & BLK_TC_NOTIFY))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tbuf = this_cpu_ptr(bt->msg_data);\n\tva_start(args, fmt);\n\tn = vscnprintf(buf, BLK_TN_MAX_MSG, fmt, args);\n\tva_end(args);\n\n\tif (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))\n\t\tblkcg = NULL;\n#ifdef CONFIG_BLK_CGROUP\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n,\n\t\tblkcg ? cgroup_get_kernfs_id(blkcg->css.cgroup) : NULL);\n#else\n\ttrace_note(bt, 0, BLK_TN_MESSAGE, buf, n, NULL);\n#endif\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bt",
            "&running_trace_list",
            "running_list"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&running_trace_lock",
            "flags"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note_tsk(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tstruct blk_trace *bt;\n\n\ttsk->btrace_seq = blktrace_seq;\n\tspin_lock_irqsave(&running_trace_lock, flags);\n\tlist_for_each_entry(bt, &running_trace_list, running_list) {\n\t\ttrace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,\n\t\t\t   sizeof(tsk->comm), NULL);\n\t}\n\tspin_unlock_irqrestore(&running_trace_lock, flags);\n}"
  },
  {
    "function_name": "trace_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/blktrace.c",
    "lines": "66-110",
    "snippet": "static void trace_note(struct blk_trace *bt, pid_t pid, int action,\n\t\t       const void *data, size_t len,\n\t\t       union kernfs_node_id *cgid)\n{\n\tstruct blk_io_trace *t;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tint pc = 0;\n\tint cpu = smp_processor_id();\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (blk_tracer) {\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (!bt->rchan)\n\t\treturn;\n\n\tt = relay_reserve(bt->rchan, sizeof(*t) + len + cgid_len);\n\tif (t) {\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\tt->device = bt->dev;\n\t\tt->action = action | (cgid ? __BLK_TN_CGROUP : 0);\n\t\tt->pid = pid;\n\t\tt->cpu = cpu;\n\t\tt->pdu_len = len + cgid_len;\n\t\tif (cgid)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tmemcpy((void *) t + sizeof(*t) + cgid_len, data, len);\n\n\t\tif (blk_tracer)\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <trace/events/block.h>",
      "#include \"../../block/blk.h\"",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/blktrace_api.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "blk_tr",
            "buffer",
            "event",
            "0",
            "pc"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1250-1256",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct ring_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned long flags, int pc)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, flags, pc, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) t + sizeof(*t) + cgid_len",
            "data",
            "len"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relay_reserve",
          "args": [
            "bt->rchan",
            "sizeof(*t) + len + cgid_len"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_BLK",
            "sizeof(*t) + len + cgid_len",
            "0",
            "pc"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <trace/events/block.h>\n#include \"../../block/blk.h\"\n#include <linux/blk-cgroup.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/blktrace_api.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n\nstatic void trace_note(struct blk_trace *bt, pid_t pid, int action,\n\t\t       const void *data, size_t len,\n\t\t       union kernfs_node_id *cgid)\n{\n\tstruct blk_io_trace *t;\n\tstruct ring_buffer_event *event = NULL;\n\tstruct ring_buffer *buffer = NULL;\n\tint pc = 0;\n\tint cpu = smp_processor_id();\n\tbool blk_tracer = blk_tracer_enabled;\n\tssize_t cgid_len = cgid ? sizeof(*cgid) : 0;\n\n\tif (blk_tracer) {\n\t\tbuffer = blk_tr->trace_buffer.buffer;\n\t\tpc = preempt_count();\n\t\tevent = trace_buffer_lock_reserve(buffer, TRACE_BLK,\n\t\t\t\t\t\t  sizeof(*t) + len + cgid_len,\n\t\t\t\t\t\t  0, pc);\n\t\tif (!event)\n\t\t\treturn;\n\t\tt = ring_buffer_event_data(event);\n\t\tgoto record_it;\n\t}\n\n\tif (!bt->rchan)\n\t\treturn;\n\n\tt = relay_reserve(bt->rchan, sizeof(*t) + len + cgid_len);\n\tif (t) {\n\t\tt->magic = BLK_IO_TRACE_MAGIC | BLK_IO_TRACE_VERSION;\n\t\tt->time = ktime_to_ns(ktime_get());\nrecord_it:\n\t\tt->device = bt->dev;\n\t\tt->action = action | (cgid ? __BLK_TN_CGROUP : 0);\n\t\tt->pid = pid;\n\t\tt->cpu = cpu;\n\t\tt->pdu_len = len + cgid_len;\n\t\tif (cgid)\n\t\t\tmemcpy((void *)t + sizeof(*t), cgid, cgid_len);\n\t\tmemcpy((void *) t + sizeof(*t) + cgid_len, data, len);\n\n\t\tif (blk_tracer)\n\t\t\ttrace_buffer_unlock_commit(blk_tr, buffer, event, 0, pc);\n\t}\n}"
  }
]