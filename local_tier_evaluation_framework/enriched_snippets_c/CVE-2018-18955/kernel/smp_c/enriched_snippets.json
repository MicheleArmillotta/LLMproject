[
  {
    "function_name": "smp_call_on_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "789-807",
    "snippet": "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tstruct smp_call_on_cpu_struct sscs = {\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK(sscs.done),\n\t\t.func = func,\n\t\t.data = par,\n\t\t.cpu  = phys ? cpu : -1,\n\t};\n\n\tINIT_WORK_ONSTACK(&sscs.work, smp_call_on_cpu_callback);\n\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\n\n\tqueue_work_on(cpu, system_wq, &sscs.work);\n\twait_for_completion(&sscs.done);\n\n\treturn sscs.ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&sscs.done"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "system_wq",
            "&sscs.work"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1477-1492",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&sscs.work",
            "smp_call_on_cpu_callback"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK",
          "args": [
            "sscs.done"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tstruct smp_call_on_cpu_struct sscs = {\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK(sscs.done),\n\t\t.func = func,\n\t\t.data = par,\n\t\t.cpu  = phys ? cpu : -1,\n\t};\n\n\tINIT_WORK_ONSTACK(&sscs.work, smp_call_on_cpu_callback);\n\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\n\n\tqueue_work_on(cpu, system_wq, &sscs.work);\n\twait_for_completion(&sscs.done);\n\n\treturn sscs.ret;\n}"
  },
  {
    "function_name": "smp_call_on_cpu_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "775-787",
    "snippet": "static void smp_call_on_cpu_callback(struct work_struct *work)\n{\n\tstruct smp_call_on_cpu_struct *sscs;\n\n\tsscs = container_of(work, struct smp_call_on_cpu_struct, work);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(sscs->cpu);\n\tsscs->ret = sscs->func(sscs->data);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(-1);\n\n\tcomplete(&sscs->done);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&sscs->done"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervisor_pin_vcpu",
          "args": [
            "-1"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscs->func",
          "args": [
            "sscs->data"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervisor_pin_vcpu",
          "args": [
            "sscs->cpu"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsmp_call_on_cpu_struct",
            "work"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void smp_call_on_cpu_callback(struct work_struct *work)\n{\n\tstruct smp_call_on_cpu_struct *sscs;\n\n\tsscs = container_of(work, struct smp_call_on_cpu_struct, work);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(sscs->cpu);\n\tsscs->ret = sscs->func(sscs->data);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(-1);\n\n\tcomplete(&sscs->done);\n}"
  },
  {
    "function_name": "wake_up_all_idle_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "744-756",
    "snippet": "void wake_up_all_idle_cpus(void)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == smp_processor_id())\n\t\t\tcontinue;\n\n\t\twake_up_if_idle(cpu);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_if_idle",
          "args": [
            "cpu"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_if_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1802-1824",
          "snippet": "void wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\tif (set_nr_if_polling(rq->idle)) {\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t} else {\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (is_idle_task(rq->curr))\n\t\t\tsmp_send_reschedule(cpu);\n\t\t/* Else CPU is not idle, do nothing here: */\n\t\trq_unlock_irqrestore(rq, &rf);\n\t}\n\nout:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\tif (set_nr_if_polling(rq->idle)) {\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t} else {\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (is_idle_task(rq->curr))\n\t\t\tsmp_send_reschedule(cpu);\n\t\t/* Else CPU is not idle, do nothing here: */\n\t\trq_unlock_irqrestore(rq, &rf);\n\t}\n\nout:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid wake_up_all_idle_cpus(void)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu == smp_processor_id())\n\t\t\tcontinue;\n\n\t\twake_up_if_idle(cpu);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "kick_all_cpus_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "730-735",
    "snippet": "void kick_all_cpus_sync(void)\n{\n\t/* Make sure the change is visible before we kick the cpus */\n\tsmp_mb();\n\tsmp_call_function(do_nothing, NULL, 1);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "do_nothing",
            "NULL",
            "1"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "489-496",
          "snippet": "int smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid kick_all_cpus_sync(void)\n{\n\t/* Make sure the change is visible before we kick the cpus */\n\tsmp_mb();\n\tsmp_call_function(do_nothing, NULL, 1);\n}"
  },
  {
    "function_name": "do_nothing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "715-717",
    "snippet": "static void do_nothing(void *unused)\n{\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void do_nothing(void *unused)\n{\n}"
  },
  {
    "function_name": "on_each_cpu_cond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "706-712",
    "snippet": "void on_each_cpu_cond(bool (*cond_func)(int cpu, void *info),\n\t\t\tsmp_call_func_t func, void *info, bool wait,\n\t\t\tgfp_t gfp_flags)\n{\n\ton_each_cpu_cond_mask(cond_func, func, info, wait, gfp_flags,\n\t\t\t\tcpu_online_mask);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu_cond_mask",
          "args": [
            "cond_func",
            "func",
            "info",
            "wait",
            "gfp_flags",
            "cpu_online_mask"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu_cond_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "672-703",
          "snippet": "void on_each_cpu_cond_mask(bool (*cond_func)(int cpu, void *info),\n\t\t\tsmp_call_func_t func, void *info, bool wait,\n\t\t\tgfp_t gfp_flags, const struct cpumask *mask)\n{\n\tcpumask_var_t cpus;\n\tint cpu, ret;\n\n\tmight_sleep_if(gfpflags_allow_blocking(gfp_flags));\n\n\tif (likely(zalloc_cpumask_var(&cpus, (gfp_flags|__GFP_NOWARN)))) {\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info))\n\t\t\t\t__cpumask_set_cpu(cpu, cpus);\n\t\ton_each_cpu_mask(cpus, func, info, wait);\n\t\tpreempt_enable();\n\t\tfree_cpumask_var(cpus);\n\t} else {\n\t\t/*\n\t\t * No free cpumask, bother. No matter, we'll\n\t\t * just have to IPI them one by one.\n\t\t */\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info)) {\n\t\t\t\tret = smp_call_function_single(cpu, func,\n\t\t\t\t\t\t\t\tinfo, wait);\n\t\t\t\tWARN_ON_ONCE(ret);\n\t\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid on_each_cpu_cond_mask(bool (*cond_func)(int cpu, void *info),\n\t\t\tsmp_call_func_t func, void *info, bool wait,\n\t\t\tgfp_t gfp_flags, const struct cpumask *mask)\n{\n\tcpumask_var_t cpus;\n\tint cpu, ret;\n\n\tmight_sleep_if(gfpflags_allow_blocking(gfp_flags));\n\n\tif (likely(zalloc_cpumask_var(&cpus, (gfp_flags|__GFP_NOWARN)))) {\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info))\n\t\t\t\t__cpumask_set_cpu(cpu, cpus);\n\t\ton_each_cpu_mask(cpus, func, info, wait);\n\t\tpreempt_enable();\n\t\tfree_cpumask_var(cpus);\n\t} else {\n\t\t/*\n\t\t * No free cpumask, bother. No matter, we'll\n\t\t * just have to IPI them one by one.\n\t\t */\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info)) {\n\t\t\t\tret = smp_call_function_single(cpu, func,\n\t\t\t\t\t\t\t\tinfo, wait);\n\t\t\t\tWARN_ON_ONCE(ret);\n\t\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid on_each_cpu_cond(bool (*cond_func)(int cpu, void *info),\n\t\t\tsmp_call_func_t func, void *info, bool wait,\n\t\t\tgfp_t gfp_flags)\n{\n\ton_each_cpu_cond_mask(cond_func, func, info, wait, gfp_flags,\n\t\t\t\tcpu_online_mask);\n}"
  },
  {
    "function_name": "on_each_cpu_cond_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "672-703",
    "snippet": "void on_each_cpu_cond_mask(bool (*cond_func)(int cpu, void *info),\n\t\t\tsmp_call_func_t func, void *info, bool wait,\n\t\t\tgfp_t gfp_flags, const struct cpumask *mask)\n{\n\tcpumask_var_t cpus;\n\tint cpu, ret;\n\n\tmight_sleep_if(gfpflags_allow_blocking(gfp_flags));\n\n\tif (likely(zalloc_cpumask_var(&cpus, (gfp_flags|__GFP_NOWARN)))) {\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info))\n\t\t\t\t__cpumask_set_cpu(cpu, cpus);\n\t\ton_each_cpu_mask(cpus, func, info, wait);\n\t\tpreempt_enable();\n\t\tfree_cpumask_var(cpus);\n\t} else {\n\t\t/*\n\t\t * No free cpumask, bother. No matter, we'll\n\t\t * just have to IPI them one by one.\n\t\t */\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info)) {\n\t\t\t\tret = smp_call_function_single(cpu, func,\n\t\t\t\t\t\t\t\tinfo, wait);\n\t\t\t\tWARN_ON_ONCE(ret);\n\t\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "func",
            "info",
            "wait"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "268-307",
          "snippet": "int smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);\n\nint smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_func",
          "args": [
            "cpu",
            "info"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cpus"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu_mask",
          "args": [
            "cpus",
            "func",
            "info",
            "wait"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "629-642",
          "snippet": "void on_each_cpu_mask(const struct cpumask *mask, smp_call_func_t func,\n\t\t\tvoid *info, bool wait)\n{\n\tint cpu = get_cpu();\n\n\tsmp_call_function_many(mask, func, info, wait);\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tunsigned long flags;\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\tput_cpu();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid on_each_cpu_mask(const struct cpumask *mask, smp_call_func_t func,\n\t\t\tvoid *info, bool wait)\n{\n\tint cpu = get_cpu();\n\n\tsmp_call_function_many(mask, func, info, wait);\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tunsigned long flags;\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpumask_set_cpu",
          "args": [
            "cpu",
            "cpus"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_func",
          "args": [
            "cpu",
            "info"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "zalloc_cpumask_var(&cpus, (gfp_flags|__GFP_NOWARN))"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&cpus",
            "(gfp_flags|__GFP_NOWARN)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "gfpflags_allow_blocking(gfp_flags)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_flags"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid on_each_cpu_cond_mask(bool (*cond_func)(int cpu, void *info),\n\t\t\tsmp_call_func_t func, void *info, bool wait,\n\t\t\tgfp_t gfp_flags, const struct cpumask *mask)\n{\n\tcpumask_var_t cpus;\n\tint cpu, ret;\n\n\tmight_sleep_if(gfpflags_allow_blocking(gfp_flags));\n\n\tif (likely(zalloc_cpumask_var(&cpus, (gfp_flags|__GFP_NOWARN)))) {\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info))\n\t\t\t\t__cpumask_set_cpu(cpu, cpus);\n\t\ton_each_cpu_mask(cpus, func, info, wait);\n\t\tpreempt_enable();\n\t\tfree_cpumask_var(cpus);\n\t} else {\n\t\t/*\n\t\t * No free cpumask, bother. No matter, we'll\n\t\t * just have to IPI them one by one.\n\t\t */\n\t\tpreempt_disable();\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tif (cond_func(cpu, info)) {\n\t\t\t\tret = smp_call_function_single(cpu, func,\n\t\t\t\t\t\t\t\tinfo, wait);\n\t\t\t\tWARN_ON_ONCE(ret);\n\t\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "on_each_cpu_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "629-642",
    "snippet": "void on_each_cpu_mask(const struct cpumask *mask, smp_call_func_t func,\n\t\t\tvoid *info, bool wait)\n{\n\tint cpu = get_cpu();\n\n\tsmp_call_function_many(mask, func, info, wait);\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tunsigned long flags;\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\tput_cpu();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "209-258",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_many",
          "args": [
            "mask",
            "func",
            "info",
            "wait"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "403-471",
          "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t/* No online cpus?  We're done. */\n\tif (cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/* Do we have another CPU which isn't us? */\n\tnext_cpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (next_cpu == this_cpu)\n\t\tnext_cpu = cpumask_next_and(next_cpu, mask, cpu_online_mask);\n\n\t/* Fastpath: do that cpu by itself. */\n\tif (next_cpu >= nr_cpu_ids) {\n\t\tsmp_call_function_single(cpu, func, info, wait);\n\t\treturn;\n\t}\n\n\tcfd = this_cpu_ptr(&cfd_data);\n\n\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t/* Some callers race with other cpus changing the passed mask */\n\tif (unlikely(!cpumask_weight(cfd->cpumask)))\n\t\treturn;\n\n\tcpumask_clear(cfd->cpumask_ipi);\n\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\tcall_single_data_t *csd = per_cpu_ptr(cfd->csd, cpu);\n\n\t\tcsd_lock(csd);\n\t\tif (wait)\n\t\t\tcsd->flags |= CSD_FLAG_SYNCHRONOUS;\n\t\tcsd->func = func;\n\t\tcsd->info = info;\n\t\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t}\n\n\t/* Send a message to all CPUs in the map */\n\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\tif (wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = per_cpu_ptr(cfd->csd, cpu);\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t/* No online cpus?  We're done. */\n\tif (cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/* Do we have another CPU which isn't us? */\n\tnext_cpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (next_cpu == this_cpu)\n\t\tnext_cpu = cpumask_next_and(next_cpu, mask, cpu_online_mask);\n\n\t/* Fastpath: do that cpu by itself. */\n\tif (next_cpu >= nr_cpu_ids) {\n\t\tsmp_call_function_single(cpu, func, info, wait);\n\t\treturn;\n\t}\n\n\tcfd = this_cpu_ptr(&cfd_data);\n\n\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t/* Some callers race with other cpus changing the passed mask */\n\tif (unlikely(!cpumask_weight(cfd->cpumask)))\n\t\treturn;\n\n\tcpumask_clear(cfd->cpumask_ipi);\n\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\tcall_single_data_t *csd = per_cpu_ptr(cfd->csd, cpu);\n\n\t\tcsd_lock(csd);\n\t\tif (wait)\n\t\t\tcsd->flags |= CSD_FLAG_SYNCHRONOUS;\n\t\tcsd->func = func;\n\t\tcsd->info = info;\n\t\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t}\n\n\t/* Send a message to all CPUs in the map */\n\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\tif (wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = per_cpu_ptr(cfd->csd, cpu);\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid on_each_cpu_mask(const struct cpumask *mask, smp_call_func_t func,\n\t\t\tvoid *info, bool wait)\n{\n\tint cpu = get_cpu();\n\n\tsmp_call_function_many(mask, func, info, wait);\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tunsigned long flags;\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\tput_cpu();\n}"
  },
  {
    "function_name": "on_each_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "598-610",
    "snippet": "int on_each_cpu(void (*func) (void *info), void *info, int wait)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tpreempt_disable();\n\tret = smp_call_function(func, info, wait);\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "209-258",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "func",
            "info",
            "wait"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "489-496",
          "snippet": "int smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint on_each_cpu(void (*func) (void *info), void *info, int wait)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tpreempt_disable();\n\tret = smp_call_function(func, info, wait);\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "smp_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "563-591",
    "snippet": "void __init smp_init(void)\n{\n\tint num_nodes, num_cpus;\n\tunsigned int cpu;\n\n\tidle_threads_init();\n\tcpuhp_threads_init();\n\n\tpr_info(\"Bringing up secondary CPUs ...\\n\");\n\n\t/* FIXME: This should be done in userspace --RR */\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= setup_max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu);\n\t}\n\n\tnum_nodes = num_online_nodes();\n\tnum_cpus  = num_online_cpus();\n\tpr_info(\"Brought up %d node%s, %d CPU%s\\n\",\n\t\tnum_nodes, (num_nodes > 1 ? \"s\" : \"\"),\n\t\tnum_cpus,  (num_cpus  > 1 ? \"s\" : \"\"));\n\n\t/* Final decision about SMT support */\n\tcpu_smt_check_topology();\n\t/* Any cleanup work */\n\tsmp_cpus_done(setup_max_cpus);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int setup_max_cpus = NR_CPUS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_cpus_done",
          "args": [
            "setup_max_cpus"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_smt_check_topology",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_smt_check_topology",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "409-413",
          "snippet": "void __init cpu_smt_check_topology(void)\n{\n\tif (!cpu_smt_available)\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid __init cpu_smt_check_topology(void)\n{\n\tif (!cpu_smt_available)\n\t\tcpu_smt_control = CPU_SMT_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Brought up %d node%s, %d CPU%s\\n\"",
            "num_nodes",
            "(num_nodes > 1 ? \"s\" : \"\")",
            "num_cpus",
            "(num_cpus  > 1 ? \"s\" : \"\")"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_nodes",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "cpu"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1179-1182",
          "snippet": "int cpu_up(unsigned int cpu)\n{\n\treturn do_cpu_up(cpu, CPUHP_ONLINE);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nint cpu_up(unsigned int cpu)\n{\n\treturn do_cpu_up(cpu, CPUHP_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Bringing up secondary CPUs ...\\n\""
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_threads_init",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_threads_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "778-782",
          "snippet": "void __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_threads_init",
          "args": [],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "idle_threads_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smpboot.c",
          "lines": "66-76",
          "snippet": "void __init idle_threads_init(void)\n{\n\tunsigned int cpu, boot_cpu;\n\n\tboot_cpu = smp_processor_id();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu != boot_cpu)\n\t\t\tidle_init(cpu);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init idle_threads_init(void)\n{\n\tunsigned int cpu, boot_cpu;\n\n\tboot_cpu = smp_processor_id();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu != boot_cpu)\n\t\t\tidle_init(cpu);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int setup_max_cpus = NR_CPUS;\n\nvoid __init smp_init(void)\n{\n\tint num_nodes, num_cpus;\n\tunsigned int cpu;\n\n\tidle_threads_init();\n\tcpuhp_threads_init();\n\n\tpr_info(\"Bringing up secondary CPUs ...\\n\");\n\n\t/* FIXME: This should be done in userspace --RR */\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= setup_max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu);\n\t}\n\n\tnum_nodes = num_online_nodes();\n\tnum_cpus  = num_online_cpus();\n\tpr_info(\"Brought up %d node%s, %d CPU%s\\n\",\n\t\tnum_nodes, (num_nodes > 1 ? \"s\" : \"\"),\n\t\tnum_cpus,  (num_cpus  > 1 ? \"s\" : \"\"));\n\n\t/* Final decision about SMT support */\n\tcpu_smt_check_topology();\n\t/* Any cleanup work */\n\tsmp_cpus_done(setup_max_cpus);\n}"
  },
  {
    "function_name": "setup_nr_cpu_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "557-560",
    "snippet": "void __init setup_nr_cpu_ids(void)\n{\n\tnr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_last_bit",
          "args": [
            "cpumask_bits(cpu_possible_mask)",
            "NR_CPUS"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "cpu_possible_mask"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nvoid __init setup_nr_cpu_ids(void)\n{\n\tnr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1;\n}"
  },
  {
    "function_name": "maxcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "541-548",
    "snippet": "static int __init maxcpus(char *str)\n{\n\tget_option(&str, &setup_max_cpus);\n\tif (setup_max_cpus == 0)\n\t\tarch_disable_smp_support();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int setup_max_cpus = NR_CPUS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_disable_smp_support",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "arch_disable_smp_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "515-515",
          "snippet": "void __weak arch_disable_smp_support(void) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid __weak arch_disable_smp_support(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&setup_max_cpus"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int setup_max_cpus = NR_CPUS;\n\nstatic int __init maxcpus(char *str)\n{\n\tget_option(&str, &setup_max_cpus);\n\tif (setup_max_cpus == 0)\n\t\tarch_disable_smp_support();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nrcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "528-537",
    "snippet": "static int __init nrcpus(char *str)\n{\n\tint nr_cpus;\n\n\tget_option(&str, &nr_cpus);\n\tif (nr_cpus > 0 && nr_cpus < nr_cpu_ids)\n\t\tnr_cpu_ids = nr_cpus;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&nr_cpus"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nstatic int __init nrcpus(char *str)\n{\n\tint nr_cpus;\n\n\tget_option(&str, &nr_cpus);\n\tif (nr_cpus > 0 && nr_cpus < nr_cpu_ids)\n\t\tnr_cpu_ids = nr_cpus;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nosmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "517-523",
    "snippet": "static int __init nosmp(char *str)\n{\n\tsetup_max_cpus = 0;\n\tarch_disable_smp_support();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int setup_max_cpus = NR_CPUS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_disable_smp_support",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "arch_disable_smp_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "515-515",
          "snippet": "void __weak arch_disable_smp_support(void) { }",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid __weak arch_disable_smp_support(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int setup_max_cpus = NR_CPUS;\n\nstatic int __init nosmp(char *str)\n{\n\tsetup_max_cpus = 0;\n\tarch_disable_smp_support();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_disable_smp_support",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "515-515",
    "snippet": "void __weak arch_disable_smp_support(void) { }",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid __weak arch_disable_smp_support(void) { }"
  },
  {
    "function_name": "smp_call_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "489-496",
    "snippet": "int smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_many",
          "args": [
            "cpu_online_mask",
            "func",
            "info",
            "wait"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "403-471",
          "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t/* No online cpus?  We're done. */\n\tif (cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/* Do we have another CPU which isn't us? */\n\tnext_cpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (next_cpu == this_cpu)\n\t\tnext_cpu = cpumask_next_and(next_cpu, mask, cpu_online_mask);\n\n\t/* Fastpath: do that cpu by itself. */\n\tif (next_cpu >= nr_cpu_ids) {\n\t\tsmp_call_function_single(cpu, func, info, wait);\n\t\treturn;\n\t}\n\n\tcfd = this_cpu_ptr(&cfd_data);\n\n\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t/* Some callers race with other cpus changing the passed mask */\n\tif (unlikely(!cpumask_weight(cfd->cpumask)))\n\t\treturn;\n\n\tcpumask_clear(cfd->cpumask_ipi);\n\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\tcall_single_data_t *csd = per_cpu_ptr(cfd->csd, cpu);\n\n\t\tcsd_lock(csd);\n\t\tif (wait)\n\t\t\tcsd->flags |= CSD_FLAG_SYNCHRONOUS;\n\t\tcsd->func = func;\n\t\tcsd->info = info;\n\t\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t}\n\n\t/* Send a message to all CPUs in the map */\n\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\tif (wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = per_cpu_ptr(cfd->csd, cpu);\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t/* No online cpus?  We're done. */\n\tif (cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/* Do we have another CPU which isn't us? */\n\tnext_cpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (next_cpu == this_cpu)\n\t\tnext_cpu = cpumask_next_and(next_cpu, mask, cpu_online_mask);\n\n\t/* Fastpath: do that cpu by itself. */\n\tif (next_cpu >= nr_cpu_ids) {\n\t\tsmp_call_function_single(cpu, func, info, wait);\n\t\treturn;\n\t}\n\n\tcfd = this_cpu_ptr(&cfd_data);\n\n\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t/* Some callers race with other cpus changing the passed mask */\n\tif (unlikely(!cpumask_weight(cfd->cpumask)))\n\t\treturn;\n\n\tcpumask_clear(cfd->cpumask_ipi);\n\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\tcall_single_data_t *csd = per_cpu_ptr(cfd->csd, cpu);\n\n\t\tcsd_lock(csd);\n\t\tif (wait)\n\t\t\tcsd->flags |= CSD_FLAG_SYNCHRONOUS;\n\t\tcsd->func = func;\n\t\tcsd->info = info;\n\t\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t}\n\n\t/* Send a message to all CPUs in the map */\n\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\tif (wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = per_cpu_ptr(cfd->csd, cpu);\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smp_call_function_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "403-471",
    "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t/* No online cpus?  We're done. */\n\tif (cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/* Do we have another CPU which isn't us? */\n\tnext_cpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (next_cpu == this_cpu)\n\t\tnext_cpu = cpumask_next_and(next_cpu, mask, cpu_online_mask);\n\n\t/* Fastpath: do that cpu by itself. */\n\tif (next_cpu >= nr_cpu_ids) {\n\t\tsmp_call_function_single(cpu, func, info, wait);\n\t\treturn;\n\t}\n\n\tcfd = this_cpu_ptr(&cfd_data);\n\n\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t/* Some callers race with other cpus changing the passed mask */\n\tif (unlikely(!cpumask_weight(cfd->cpumask)))\n\t\treturn;\n\n\tcpumask_clear(cfd->cpumask_ipi);\n\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\tcall_single_data_t *csd = per_cpu_ptr(cfd->csd, cpu);\n\n\t\tcsd_lock(csd);\n\t\tif (wait)\n\t\t\tcsd->flags |= CSD_FLAG_SYNCHRONOUS;\n\t\tcsd->func = func;\n\t\tcsd->info = info;\n\t\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t}\n\n\t/* Send a message to all CPUs in the map */\n\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\tif (wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = per_cpu_ptr(cfd->csd, cpu);\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "106-109",
          "snippet": "static __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cfd->csd",
            "cpu"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cfd->cpumask"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_send_call_function_ipi_mask",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpumask_set_cpu",
          "args": [
            "cpu",
            "cfd->cpumask_ipi"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&csd->llist",
            "&per_cpu(call_single_queue, cpu)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "call_single_queue",
            "cpu"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csd_lock",
          "args": [
            "csd"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "111-122",
          "snippet": "static __always_inline void csd_lock(call_single_data_t *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock(call_single_data_t *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cfd->csd",
            "cpu"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cfd->cpumask"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cpumask_weight(cfd->cpumask)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cfd->cpumask"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpumask_clear_cpu",
          "args": [
            "this_cpu",
            "cfd->cpumask"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cfd->cpumask",
            "mask",
            "cpu_online_mask"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_data"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "func",
            "info",
            "wait"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "268-307",
          "snippet": "int smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);\n\nint smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "next_cpu",
            "mask",
            "cpu_online_mask"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "cpu",
            "mask",
            "cpu_online_mask"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "cpu",
            "mask",
            "cpu_online_mask"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "this_cpu"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t/* Try to fastpath.  So, what's a CPU they want? Ignoring this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t/* No online cpus?  We're done. */\n\tif (cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/* Do we have another CPU which isn't us? */\n\tnext_cpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (next_cpu == this_cpu)\n\t\tnext_cpu = cpumask_next_and(next_cpu, mask, cpu_online_mask);\n\n\t/* Fastpath: do that cpu by itself. */\n\tif (next_cpu >= nr_cpu_ids) {\n\t\tsmp_call_function_single(cpu, func, info, wait);\n\t\treturn;\n\t}\n\n\tcfd = this_cpu_ptr(&cfd_data);\n\n\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t/* Some callers race with other cpus changing the passed mask */\n\tif (unlikely(!cpumask_weight(cfd->cpumask)))\n\t\treturn;\n\n\tcpumask_clear(cfd->cpumask_ipi);\n\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\tcall_single_data_t *csd = per_cpu_ptr(cfd->csd, cpu);\n\n\t\tcsd_lock(csd);\n\t\tif (wait)\n\t\t\tcsd->flags |= CSD_FLAG_SYNCHRONOUS;\n\t\tcsd->func = func;\n\t\tcsd->info = info;\n\t\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t}\n\n\t/* Send a message to all CPUs in the map */\n\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\tif (wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = per_cpu_ptr(cfd->csd, cpu);\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "smp_call_function_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "360-386",
    "snippet": "int smp_call_function_any(const struct cpumask *mask,\n\t\t\t  smp_call_func_t func, void *info, int wait)\n{\n\tunsigned int cpu;\n\tconst struct cpumask *nodemask;\n\tint ret;\n\n\t/* Try for same CPU (cheapest) */\n\tcpu = get_cpu();\n\tif (cpumask_test_cpu(cpu, mask))\n\t\tgoto call;\n\n\t/* Try for same node. */\n\tnodemask = cpumask_of_node(cpu_to_node(cpu));\n\tfor (cpu = cpumask_first_and(nodemask, mask); cpu < nr_cpu_ids;\n\t     cpu = cpumask_next_and(cpu, nodemask, mask)) {\n\t\tif (cpu_online(cpu))\n\t\t\tgoto call;\n\t}\n\n\t/* Any online will do: smp_call_function_single handles nr_cpu_ids. */\n\tcpu = cpumask_any_and(mask, cpu_online_mask);\ncall:\n\tret = smp_call_function_single(cpu, func, info, wait);\n\tput_cpu();\n\treturn ret;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "func",
            "info",
            "wait"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "268-307",
          "snippet": "int smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);\n\nint smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "cpu",
            "nodemask",
            "mask"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "nodemask",
            "mask"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "cpu_to_node(cpu)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nint smp_call_function_any(const struct cpumask *mask,\n\t\t\t  smp_call_func_t func, void *info, int wait)\n{\n\tunsigned int cpu;\n\tconst struct cpumask *nodemask;\n\tint ret;\n\n\t/* Try for same CPU (cheapest) */\n\tcpu = get_cpu();\n\tif (cpumask_test_cpu(cpu, mask))\n\t\tgoto call;\n\n\t/* Try for same node. */\n\tnodemask = cpumask_of_node(cpu_to_node(cpu));\n\tfor (cpu = cpumask_first_and(nodemask, mask); cpu < nr_cpu_ids;\n\t     cpu = cpumask_next_and(cpu, nodemask, mask)) {\n\t\tif (cpu_online(cpu))\n\t\t\tgoto call;\n\t}\n\n\t/* Any online will do: smp_call_function_single handles nr_cpu_ids. */\n\tcpu = cpumask_any_and(mask, cpu_online_mask);\ncall:\n\tret = smp_call_function_single(cpu, func, info, wait);\n\tput_cpu();\n\treturn ret;\n}"
  },
  {
    "function_name": "smp_call_function_single_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "326-343",
    "snippet": "int smp_call_function_single_async(int cpu, call_single_data_t *csd)\n{\n\tint err = 0;\n\n\tpreempt_disable();\n\n\t/* We could deadlock if we have to wait here with interrupts disabled! */\n\tif (WARN_ON_ONCE(csd->flags & CSD_FLAG_LOCK))\n\t\tcsd_lock_wait(csd);\n\n\tcsd->flags = CSD_FLAG_LOCK;\n\tsmp_wmb();\n\n\terr = generic_exec_single(cpu, csd, csd->func, csd->info);\n\tpreempt_enable();\n\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_exec_single",
          "args": [
            "cpu",
            "csd",
            "csd->func",
            "csd->info"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "generic_exec_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "141-182",
          "snippet": "static int generic_exec_single(int cpu, call_single_data_t *csd,\n\t\t\t       smp_call_func_t func, void *info)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nstatic int generic_exec_single(int cpu, call_single_data_t *csd,\n\t\t\t       smp_call_func_t func, void *info)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "106-109",
          "snippet": "static __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "csd->flags & CSD_FLAG_LOCK"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function_single_async(int cpu, call_single_data_t *csd)\n{\n\tint err = 0;\n\n\tpreempt_disable();\n\n\t/* We could deadlock if we have to wait here with interrupts disabled! */\n\tif (WARN_ON_ONCE(csd->flags & CSD_FLAG_LOCK))\n\t\tcsd_lock_wait(csd);\n\n\tcsd->flags = CSD_FLAG_LOCK;\n\tsmp_wmb();\n\n\terr = generic_exec_single(cpu, csd, csd->func, csd->info);\n\tpreempt_enable();\n\n\treturn err;\n}"
  },
  {
    "function_name": "smp_call_function_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "268-307",
    "snippet": "int smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "106-109",
          "snippet": "static __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_exec_single",
          "args": [
            "cpu",
            "csd",
            "func",
            "info"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "generic_exec_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "141-182",
          "snippet": "static int generic_exec_single(int cpu, call_single_data_t *csd,\n\t\t\t       smp_call_func_t func, void *info)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nstatic int generic_exec_single(int cpu, call_single_data_t *csd,\n\t\t\t       smp_call_func_t func, void *info)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csd_lock",
          "args": [
            "csd"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "111-122",
          "snippet": "static __always_inline void csd_lock(call_single_data_t *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock(call_single_data_t *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&csd_data"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "this_cpu"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);\n\nint smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.flags = CSD_FLAG_LOCK | CSD_FLAG_SYNCHRONOUS,\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\terr = generic_exec_single(cpu, csd, func, info);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}"
  },
  {
    "function_name": "flush_smp_call_function_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "209-258",
    "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
      "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_run",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "168-172",
          "snippet": "void irq_work_run(void)\n{\n\tirq_work_run_list(this_cpu_ptr(&raised_list));\n\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nvoid irq_work_run(void)\n{\n\tirq_work_run_list(this_cpu_ptr(&raised_list));\n\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "209-258",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "csd_unlock",
          "args": [
            "csd"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "csd_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "124-132",
          "snippet": "static __always_inline void csd_unlock(call_single_data_t *csd)\n{\n\tWARN_ON(!(csd->flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->flags, 0);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_unlock(call_single_data_t *csd)\n{\n\tWARN_ON(!(csd->flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->flags, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "csd",
            "csd_next",
            "entry",
            "llist"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"IPI callback %pS sent to offline CPU\\n\"",
            "csd->func"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry",
          "args": [
            "csd",
            "entry",
            "llist"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"IPI on offline CPU %d\\n\"",
            "smp_processor_id()"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "head"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_reverse_order",
          "args": [
            "entry"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "head"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&call_single_queue"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}"
  },
  {
    "function_name": "generic_smp_call_function_single_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "190-193",
    "snippet": "void generic_smp_call_function_single_interrupt(void)\n{\n\tflush_smp_call_function_queue(true);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_smp_call_function_queue",
          "args": [
            "true"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "209-258",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid generic_smp_call_function_single_interrupt(void)\n{\n\tflush_smp_call_function_queue(true);\n}"
  },
  {
    "function_name": "generic_exec_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "141-182",
    "snippet": "static int generic_exec_single(int cpu, call_single_data_t *csd,\n\t\t\t       smp_call_func_t func, void *info)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_send_call_function_single_ipi",
          "args": [
            "cpu"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&csd->llist",
            "&per_cpu(call_single_queue, cpu)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "call_single_queue",
            "cpu"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "csd_unlock",
          "args": [
            "csd"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "csd_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "124-132",
          "snippet": "static __always_inline void csd_unlock(call_single_data_t *csd)\n{\n\tWARN_ON(!(csd->flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->flags, 0);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_unlock(call_single_data_t *csd)\n{\n\tWARN_ON(!(csd->flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->flags, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "209-258",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nstatic int generic_exec_single(int cpu, call_single_data_t *csd,\n\t\t\t       smp_call_func_t func, void *info)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "csd_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "124-132",
    "snippet": "static __always_inline void csd_unlock(call_single_data_t *csd)\n{\n\tWARN_ON(!(csd->flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->flags, 0);\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&csd->flags",
            "0"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(csd->flags & CSD_FLAG_LOCK)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_unlock(call_single_data_t *csd)\n{\n\tWARN_ON(!(csd->flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->flags, 0);\n}"
  },
  {
    "function_name": "csd_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "111-122",
    "snippet": "static __always_inline void csd_lock(call_single_data_t *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "106-109",
          "snippet": "static __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock(call_single_data_t *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}"
  },
  {
    "function_name": "csd_lock_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "106-109",
    "snippet": "static __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_cond_load_acquire",
          "args": [
            "&csd->flags",
            "!(VAL & CSD_FLAG_LOCK)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(call_single_data_t *csd)\n{\n\tsmp_cond_load_acquire(&csd->flags, !(VAL & CSD_FLAG_LOCK));\n}"
  },
  {
    "function_name": "call_function_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "89-97",
    "snippet": "void __init call_function_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\tinit_llist_head(&per_cpu(call_single_queue, i));\n\n\tsmpcfd_prepare_cpu(smp_processor_id());\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smpcfd_prepare_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "smpcfd_prepare_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "42-62",
          "snippet": "int smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->csd = alloc_percpu(call_single_data_t);\n\tif (!cfd->csd) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);\n\nint smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->csd = alloc_percpu(call_single_data_t);\n\tif (!cfd->csd) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nvoid __init call_function_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\tinit_llist_head(&per_cpu(call_single_queue, i));\n\n\tsmpcfd_prepare_cpu(smp_processor_id());\n}"
  },
  {
    "function_name": "smpcfd_dying_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "74-87",
    "snippet": "int smpcfd_dying_cpu(unsigned int cpu)\n{\n\t/*\n\t * The IPIs for the smp-call-function callbacks queued by other\n\t * CPUs might arrive late, either due to hardware latencies or\n\t * because this CPU disabled interrupts (inside stop-machine)\n\t * before the IPIs were sent. So flush out any pending callbacks\n\t * explicitly (without waiting for the IPIs to arrive), to\n\t * ensure that the outgoing CPU doesn't go offline with work\n\t * still pending.\n\t */\n\tflush_smp_call_function_queue(false);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_smp_call_function_queue",
          "args": [
            "false"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
          "lines": "209-258",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tstruct llist_head *head;\n\tstruct llist_node *entry;\n\tcall_single_data_t *csd, *csd_next;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tentry = llist_del_all(head);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, llist)\n\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\tcsd->func);\n\t}\n\n\tllist_for_each_entry_safe(csd, csd_next, entry, llist) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\n\t\t/* Do we wait until *after* callback? */\n\t\tif (csd->flags & CSD_FLAG_SYNCHRONOUS) {\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t} else {\n\t\t\tcsd_unlock(csd);\n\t\t\tfunc(info);\n\t\t}\n\t}\n\n\t/*\n\t * Handle irq works queued remotely by irq_work_queue_on().\n\t * Smp functions above are typically synchronous so they\n\t * better run first since some other CPUs may be busy waiting\n\t * for them.\n\t */\n\tirq_work_run();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smpcfd_dying_cpu(unsigned int cpu)\n{\n\t/*\n\t * The IPIs for the smp-call-function callbacks queued by other\n\t * CPUs might arrive late, either due to hardware latencies or\n\t * because this CPU disabled interrupts (inside stop-machine)\n\t * before the IPIs were sent. So flush out any pending callbacks\n\t * explicitly (without waiting for the IPIs to arrive), to\n\t * ensure that the outgoing CPU doesn't go offline with work\n\t * still pending.\n\t */\n\tflush_smp_call_function_queue(false);\n\treturn 0;\n}"
  },
  {
    "function_name": "smpcfd_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "64-72",
    "snippet": "int smpcfd_dead_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tfree_cpumask_var(cfd->cpumask);\n\tfree_cpumask_var(cfd->cpumask_ipi);\n\tfree_percpu(cfd->csd);\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cfd->csd"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cfd_data",
            "cpu"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);\n\nint smpcfd_dead_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tfree_cpumask_var(cfd->cpumask);\n\tfree_cpumask_var(cfd->cpumask_ipi);\n\tfree_percpu(cfd->csd);\n\treturn 0;\n}"
  },
  {
    "function_name": "smpcfd_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smp.c",
    "lines": "42-62",
    "snippet": "int smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->csd = alloc_percpu(call_single_data_t);\n\tif (!cfd->csd) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smpboot.h\"",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "call_single_data_t"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var_node",
          "args": [
            "&cfd->cpumask_ipi",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var_node",
          "args": [
            "&cfd->cpumask",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cfd_data",
            "cpu"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);\n\nint smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->csd = alloc_percpu(call_single_data_t);\n\tif (!cfd->csd) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  }
]