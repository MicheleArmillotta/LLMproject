[
  {
    "function_name": "kprobe_trace_self_tests_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1512-1643",
    "snippet": "static __init int kprobe_trace_self_tests_init(void)\n{\n\tint ret, warn = 0;\n\tint (*target)(int, int, int, int, int, int);\n\tstruct trace_kprobe *tk;\n\tstruct trace_event_file *file;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\ttarget = kprobe_trace_selftest_target;\n\n\tpr_info(\"Testing kprobe tracing: \");\n\n\tret = trace_run_command(\"p:testprobe kprobe_trace_selftest_target \"\n\t\t\t\t\"$stack $stack0 +0($stack)\",\n\t\t\t\tcreate_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function entry.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(tk, file);\n\t\t}\n\t}\n\n\tret = trace_run_command(\"r:testprobe2 kprobe_trace_selftest_target \"\n\t\t\t\t\"$retval\", create_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function return.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting 2nd new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(tk, file);\n\t\t}\n\t}\n\n\tif (warn)\n\t\tgoto end;\n\n\tret = target(1, 2, 3, 4, 5, 6);\n\n\t/*\n\t * Not expecting an error here, the check is only to prevent the\n\t * optimizer from removing the call to target() as otherwise there\n\t * are no side-effects and the call is never performed.\n\t */\n\tif (ret != 21)\n\t\twarn++;\n\n\t/* Disable trace points before removing it */\n\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(tk, file);\n\t}\n\n\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting 2nd test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe2 hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(tk, file);\n\t}\n\n\tret = trace_run_command(\"-:testprobe\", create_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\n\tret = trace_run_command(\"-:testprobe2\", create_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\nend:\n\trelease_all_trace_kprobes();\n\t/*\n\t * Wait for the optimizer work to finish. Otherwise it might fiddle\n\t * with probes in already freed __init text.\n\t */\n\twait_for_kprobe_optimizer();\n\tif (warn)\n\t\tpr_cont(\"NG: Some tests are failed. Please check them.\\n\");\n\telse\n\t\tpr_cont(\"OK\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KPROBE_EVENT_SYSTEM \"kprobes\""
    ],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"OK\\n\""
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_kprobe_optimizer",
          "args": [],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_kprobe_optimizer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "608-624",
          "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* this will also make optimizing_work execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* @optimizing_work might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_trace_kprobes",
          "args": [],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_trace_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "738-763",
          "snippet": "static int release_all_trace_kprobes(void)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = 0;\n\n\tmutex_lock(&probe_lock);\n\t/* Ensure no probe is in use. */\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t/* TODO: Use batch unregistration */\n\twhile (!list_empty(&probe_list)) {\n\t\ttk = list_entry(probe_list.next, struct trace_kprobe, list);\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(tk);\n\t}\n\nend:\n\tmutex_unlock(&probe_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static DEFINE_MUTEX(probe_lock);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic int release_all_trace_kprobes(void)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = 0;\n\n\tmutex_lock(&probe_lock);\n\t/* Ensure no probe is in use. */\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t/* TODO: Use batch unregistration */\n\twhile (!list_empty(&probe_list)) {\n\t\ttk = list_entry(probe_list.next, struct trace_kprobe, list);\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(tk);\n\t}\n\nend:\n\tmutex_unlock(&probe_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on deleting a probe.\\n\""
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_run_command",
          "args": [
            "\"-:testprobe2\"",
            "create_trace_kprobe"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "trace_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8386-8403",
          "snippet": "int trace_run_command(const char *buf, int (*createfn)(int, char **))\n{\n\tchar **argv;\n\tint argc, ret;\n\n\targc = 0;\n\tret = 0;\n\targv = argv_split(GFP_KERNEL, buf, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\n\nint trace_run_command(const char *buf, int (*createfn)(int, char **))\n{\n\tchar **argv;\n\tint argc, ret;\n\n\targc = 0;\n\tret = 0;\n\targv = argv_split(GFP_KERNEL, buf, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on deleting a probe.\\n\""
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_trace_kprobe",
          "args": [
            "tk",
            "file"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "disable_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "288-341",
          "snippet": "static int\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link = NULL;\n\tint wait = 0;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = find_event_file_link(&tk->tp, file);\n\t\tif (!link) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_del_rcu(&link->list);\n\t\twait = 1;\n\t\tif (!list_empty(&tk->tp.files))\n\t\t\tgoto out;\n\n\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t} else\n\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\n\tif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t\twait = 1;\n\t}\n\n\t/*\n\t * if tk is not added to any list, it must be a local trace_kprobe\n\t * created with perf_event_open. We don't need to wait for these\n\t * trace_kprobes\n\t */\n\tif (list_empty(&tk->list))\n\t\twait = 0;\n out:\n\tif (wait) {\n\t\t/*\n\t\t * Synchronize with kprobe_trace_func/kretprobe_trace_func\n\t\t * to ensure disabled (all running handlers are finished).\n\t\t * This is not only for kfree(), but also the caller,\n\t\t * trace_remove_event_call() supposes it for releasing\n\t\t * event_call related objects, which will be accessed in\n\t\t * the kprobe_trace_func/kretprobe_trace_func.\n\t\t */\n\t\tsynchronize_sched();\n\t\tkfree(link);\t/* Ignored if link == NULL */\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link = NULL;\n\tint wait = 0;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = find_event_file_link(&tk->tp, file);\n\t\tif (!link) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_del_rcu(&link->list);\n\t\twait = 1;\n\t\tif (!list_empty(&tk->tp.files))\n\t\t\tgoto out;\n\n\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t} else\n\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\n\tif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t\twait = 1;\n\t}\n\n\t/*\n\t * if tk is not added to any list, it must be a local trace_kprobe\n\t * created with perf_event_open. We don't need to wait for these\n\t * trace_kprobes\n\t */\n\tif (list_empty(&tk->list))\n\t\twait = 0;\n out:\n\tif (wait) {\n\t\t/*\n\t\t * Synchronize with kprobe_trace_func/kretprobe_trace_func\n\t\t * to ensure disabled (all running handlers are finished).\n\t\t * This is not only for kfree(), but also the caller,\n\t\t * trace_remove_event_call() supposes it for releasing\n\t\t * event_call related objects, which will be accessed in\n\t\t * the kprobe_trace_func/kretprobe_trace_func.\n\t\t */\n\t\tsynchronize_sched();\n\t\tkfree(link);\t/* Ignored if link == NULL */\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trace_probe_file",
          "args": [
            "tk",
            "top_trace_array()"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_probe_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1496-1506",
          "snippet": "trace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == &tk->tp.call)\n\t\t\treturn file;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\ntrace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == &tk->tp.call)\n\t\t\treturn file;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"incorrect number of testprobe2 hits\\n\""
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_nhit",
          "args": [
            "tk"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_nhit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-93",
          "snippet": "static nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting 2nd test probe.\\n\""
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "\"testprobe2\"",
            "KPROBE_EVENT_SYSTEM"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "220-230",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"incorrect number of testprobe hits\\n\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting test probe.\\n\""
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target",
          "args": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_trace_selftest_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe_selftest.c",
          "lines": "7-10",
          "snippet": "int kprobe_trace_selftest_target(int a1, int a2, int a3, int a4, int a5, int a6)\n{\n\treturn a1 + a2 + a3 + a4 + a5 + a6;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "int kprobe_trace_selftest_target(int a1, int a2, int a3, int a4, int a5, int a6)\n{\n\treturn a1 + a2 + a3 + a4 + a5 + a6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_trace_kprobe",
          "args": [
            "tk",
            "file"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "enable_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "250-282",
          "snippet": "static int\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tk->tp.files);\n\n\t\ttk->tp.flags |= TP_FLAG_TRACE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret) {\n\t\t\tlist_del_rcu(&link->list);\n\t\t\tkfree(link);\n\t\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t\t}\n\n\t} else {\n\t\ttk->tp.flags |= TP_FLAG_PROFILE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tk->tp.files);\n\n\t\ttk->tp.flags |= TP_FLAG_TRACE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret) {\n\t\t\tlist_del_rcu(&link->list);\n\t\t\tkfree(link);\n\t\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t\t}\n\n\t} else {\n\t\ttk->tp.flags |= TP_FLAG_PROFILE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting 2nd new probe.\\n\""
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on probing function return.\\n\""
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting new probe.\\n\""
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on probing function entry.\\n\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing kprobe tracing: \""
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_is_disabled",
          "args": [],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3943-3946",
          "snippet": "bool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic __init int kprobe_trace_self_tests_init(void)\n{\n\tint ret, warn = 0;\n\tint (*target)(int, int, int, int, int, int);\n\tstruct trace_kprobe *tk;\n\tstruct trace_event_file *file;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\ttarget = kprobe_trace_selftest_target;\n\n\tpr_info(\"Testing kprobe tracing: \");\n\n\tret = trace_run_command(\"p:testprobe kprobe_trace_selftest_target \"\n\t\t\t\t\"$stack $stack0 +0($stack)\",\n\t\t\t\tcreate_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function entry.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(tk, file);\n\t\t}\n\t}\n\n\tret = trace_run_command(\"r:testprobe2 kprobe_trace_selftest_target \"\n\t\t\t\t\"$retval\", create_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function return.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting 2nd new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(tk, file);\n\t\t}\n\t}\n\n\tif (warn)\n\t\tgoto end;\n\n\tret = target(1, 2, 3, 4, 5, 6);\n\n\t/*\n\t * Not expecting an error here, the check is only to prevent the\n\t * optimizer from removing the call to target() as otherwise there\n\t * are no side-effects and the call is never performed.\n\t */\n\tif (ret != 21)\n\t\twarn++;\n\n\t/* Disable trace points before removing it */\n\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(tk, file);\n\t}\n\n\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting 2nd test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe2 hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(tk, file);\n\t}\n\n\tret = trace_run_command(\"-:testprobe\", create_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\n\tret = trace_run_command(\"-:testprobe2\", create_trace_kprobe);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\nend:\n\trelease_all_trace_kprobes();\n\t/*\n\t * Wait for the optimizer work to finish. Otherwise it might fiddle\n\t * with probes in already freed __init text.\n\t */\n\twait_for_kprobe_optimizer();\n\tif (warn)\n\t\tpr_cont(\"NG: Some tests are failed. Please check them.\\n\");\n\telse\n\t\tpr_cont(\"OK\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "find_trace_probe_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1496-1506",
    "snippet": "trace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == &tk->tp.call)\n\t\t\treturn file;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\ntrace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == &tk->tp.call)\n\t\t\treturn file;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_kprobe_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1465-1491",
    "snippet": "static __init int init_kprobe_trace(void)\n{\n\tstruct dentry *d_tracer;\n\tstruct dentry *entry;\n\n\tif (register_module_notifier(&trace_kprobe_module_nb))\n\t\treturn -EINVAL;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"kprobe_events\", 0644, d_tracer,\n\t\t\t\t    NULL, &kprobe_events_ops);\n\n\t/* Event list interface */\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_events' entry\\n\");\n\n\t/* Profile interface */\n\tentry = tracefs_create_file(\"kprobe_profile\", 0444, d_tracer,\n\t\t\t\t    NULL, &kprobe_profile_ops);\n\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_profile' entry\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block trace_kprobe_module_nb = {\n\t.notifier_call = trace_kprobe_module_callback,\n\t.priority = 1\t/* Invoked after kprobe module callback */\n};",
      "static const struct file_operations kprobe_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = probes_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= probes_write,\n};",
      "static const struct file_operations kprobe_profile_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = profile_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'kprobe_profile' entry\\n\""
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"kprobe_profile\"",
            "0444",
            "d_tracer",
            "NULL",
            "&kprobe_profile_ops"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'kprobe_events' entry\\n\""
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"kprobe_events\"",
            "0644",
            "d_tracer",
            "NULL",
            "&kprobe_events_ops"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&trace_kprobe_module_nb"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic struct notifier_block trace_kprobe_module_nb = {\n\t.notifier_call = trace_kprobe_module_callback,\n\t.priority = 1\t/* Invoked after kprobe module callback */\n};\nstatic const struct file_operations kprobe_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = probes_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= probes_write,\n};\nstatic const struct file_operations kprobe_profile_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = profile_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};\n\nstatic __init int init_kprobe_trace(void)\n{\n\tstruct dentry *d_tracer;\n\tstruct dentry *entry;\n\n\tif (register_module_notifier(&trace_kprobe_module_nb))\n\t\treturn -EINVAL;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"kprobe_events\", 0644, d_tracer,\n\t\t\t\t    NULL, &kprobe_events_ops);\n\n\t/* Event list interface */\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_events' entry\\n\");\n\n\t/* Profile interface */\n\tentry = tracefs_create_file(\"kprobe_profile\", 0444, d_tracer,\n\t\t\t\t    NULL, &kprobe_profile_ops);\n\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_profile' entry\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_local_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1446-1461",
    "snippet": "void destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = container_of(event_call, struct trace_kprobe, tp.call);\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tkfree(tk->tp.call.print_fmt);\n\tfree_trace_kprobe(tk);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "206-218",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk->tp.call.print_fmt"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "408-420",
          "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event_call",
            "structtrace_kprobe",
            "tp.call"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nvoid destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = container_of(event_call, struct trace_kprobe, tp.call);\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tkfree(tk->tp.call.print_fmt);\n\tfree_trace_kprobe(tk);\n}"
  },
  {
    "function_name": "create_local_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1402-1444",
    "snippet": "struct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk, &tk->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0) {\n\t\tkfree(tk->tp.call.print_fmt);\n\t\tgoto error;\n\t}\n\n\treturn &tk->tp.call;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KPROBE_EVENT_SYSTEM \"kprobes\""
    ],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "206-218",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk->tp.call.print_fmt"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "367-405",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tk->tp",
            "trace_kprobe_is_return(tk)"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "621-637",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tk",
            "&tk->tp.call"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1348-1363",
          "snippet": "static inline void init_trace_event_call(struct trace_kprobe *tk,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->define_fields = kretprobe_event_define_fields;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->define_fields = kprobe_event_define_fields;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n\tcall->data = tk;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};",
            "static struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};\nstatic struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};\n\nstatic inline void init_trace_event_call(struct trace_kprobe *tk,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->define_fields = kretprobe_event_define_fields;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->define_fields = kprobe_event_define_fields;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n\tcall->data = tk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tk"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate trace_probe.(%d)\\n\"",
            "(int)PTR_ERR(tk)"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tk"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tk"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_kprobe",
          "args": [
            "KPROBE_EVENT_SYSTEM",
            "event",
            "(void *)addr",
            "func",
            "offs",
            "0/* maxactive */",
            "0/* nargs */",
            "is_return"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "141-204",
          "snippet": "static struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\n\tif (!event || !is_good_name(event)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.call.class = &tk->tp.class;\n\ttk->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tk->tp.call.name)\n\t\tgoto error;\n\n\tif (!group || !is_good_name(group)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tk->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tk->list);\n\tINIT_LIST_HEAD(&tk->tp.files);\n\treturn tk;\nerror:\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\n\tif (!event || !is_good_name(event)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.call.class = &tk->tp.class;\n\ttk->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tk->tp.call.name)\n\t\tgoto error;\n\n\tif (!group || !is_good_name(group)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tk->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tk->list);\n\tINIT_LIST_HEAD(&tk->tp.files);\n\treturn tk;\nerror:\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstruct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk, &tk->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0) {\n\t\tkfree(tk->tp.call.print_fmt);\n\t\tgoto error;\n\t}\n\n\treturn &tk->tp.call;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "unregister_kprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1389-1398",
    "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk->tp.call.print_fmt"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_remove_event_call",
          "args": [
            "&tk->tp.call"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "trace_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2370-2383",
          "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}"
  },
  {
    "function_name": "register_kprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1365-1387",
    "snippet": "static int register_kprobe_event(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tint ret = 0;\n\n\tinit_trace_event_call(tk, call);\n\n\tif (traceprobe_set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0)\n\t\treturn -ENOMEM;\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tkfree(call->print_fmt);\n\t\treturn -ENODEV;\n\t}\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_info(\"Failed to register kprobe event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tkfree(call->print_fmt);\n\t\tunregister_trace_event(&call->event);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "818-825",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->print_fmt"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to register kprobe event: %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_add_event_call",
          "args": [
            "call"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "trace_add_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2309-2322",
          "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tk->tp",
            "trace_kprobe_is_return(tk)"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "621-637",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tk",
            "call"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1348-1363",
          "snippet": "static inline void init_trace_event_call(struct trace_kprobe *tk,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->define_fields = kretprobe_event_define_fields;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->define_fields = kprobe_event_define_fields;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n\tcall->data = tk;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};",
            "static struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};\nstatic struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};\n\nstatic inline void init_trace_event_call(struct trace_kprobe *tk,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->define_fields = kretprobe_event_define_fields;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->define_fields = kprobe_event_define_fields;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n\tcall->data = tk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int register_kprobe_event(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tint ret = 0;\n\n\tinit_trace_event_call(tk, call);\n\n\tif (traceprobe_set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0)\n\t\treturn -ENOMEM;\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tkfree(call->print_fmt);\n\t\treturn -ENODEV;\n\t}\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_info(\"Failed to register kprobe event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tkfree(call->print_fmt);\n\t\tunregister_trace_event(&call->event);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "init_trace_event_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1348-1363",
    "snippet": "static inline void init_trace_event_call(struct trace_kprobe *tk,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->define_fields = kretprobe_event_define_fields;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->define_fields = kprobe_event_define_fields;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n\tcall->data = tk;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};",
      "static struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&call->class->fields"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};\nstatic struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};\n\nstatic inline void init_trace_event_call(struct trace_kprobe *tk,\n\t\t\t\t\t struct trace_event_call *call)\n{\n\tINIT_LIST_HEAD(&call->class->fields);\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->define_fields = kretprobe_event_define_fields;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->define_fields = kprobe_event_define_fields;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n\tcall->data = tk;\n}"
  },
  {
    "function_name": "kretprobe_dispatcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1323-1337",
    "snippet": "static int\nkretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tstruct trace_kprobe *tk = container_of(ri->rp, struct trace_kprobe, rp);\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (tk->tp.flags & TP_FLAG_TRACE)\n\t\tkretprobe_trace_func(tk, ri, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (tk->tp.flags & TP_FLAG_PROFILE)\n\t\tkretprobe_perf_func(tk, ri, regs);\n#endif\n\treturn 0;\t/* We don't tweek kernel, so just return 0 */\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kretprobe_perf_func",
          "args": [
            "tk",
            "ri",
            "regs"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_perf_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1209-1240",
          "snippet": "static void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_trace_func",
          "args": [
            "tk",
            "ri",
            "regs"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1061-1069",
          "snippet": "static void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "*tk->nhit"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ri->rp",
            "structtrace_kprobe",
            "rp"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nkretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tstruct trace_kprobe *tk = container_of(ri->rp, struct trace_kprobe, rp);\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (tk->tp.flags & TP_FLAG_TRACE)\n\t\tkretprobe_trace_func(tk, ri, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (tk->tp.flags & TP_FLAG_PROFILE)\n\t\tkretprobe_perf_func(tk, ri, regs);\n#endif\n\treturn 0;\t/* We don't tweek kernel, so just return 0 */\n}"
  },
  {
    "function_name": "kprobe_dispatcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1306-1320",
    "snippet": "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct trace_kprobe *tk = container_of(kp, struct trace_kprobe, rp.kp);\n\tint ret = 0;\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (tk->tp.flags & TP_FLAG_TRACE)\n\t\tkprobe_trace_func(tk, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (tk->tp.flags & TP_FLAG_PROFILE)\n\t\tret = kprobe_perf_func(tk, regs);\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_perf_func",
          "args": [
            "tk",
            "regs"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_perf_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1160-1205",
          "snippet": "static int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_trace_func",
          "args": [
            "tk",
            "regs"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1012-1019",
          "snippet": "static void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "*tk->nhit"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kp",
            "structtrace_kprobe",
            "rp.kp"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct trace_kprobe *tk = container_of(kp, struct trace_kprobe, rp.kp);\n\tint ret = 0;\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (tk->tp.flags & TP_FLAG_TRACE)\n\t\tkprobe_trace_func(tk, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (tk->tp.flags & TP_FLAG_PROFILE)\n\t\tret = kprobe_perf_func(tk, regs);\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1279-1304",
    "snippet": "static int kprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)event->data;\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_kprobe(tk, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_kprobe(tk, file);\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn enable_trace_kprobe(tk, NULL);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn disable_trace_kprobe(tk, NULL);\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_trace_kprobe",
          "args": [
            "tk",
            "NULL"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "disable_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "288-341",
          "snippet": "static int\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link = NULL;\n\tint wait = 0;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = find_event_file_link(&tk->tp, file);\n\t\tif (!link) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_del_rcu(&link->list);\n\t\twait = 1;\n\t\tif (!list_empty(&tk->tp.files))\n\t\t\tgoto out;\n\n\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t} else\n\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\n\tif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t\twait = 1;\n\t}\n\n\t/*\n\t * if tk is not added to any list, it must be a local trace_kprobe\n\t * created with perf_event_open. We don't need to wait for these\n\t * trace_kprobes\n\t */\n\tif (list_empty(&tk->list))\n\t\twait = 0;\n out:\n\tif (wait) {\n\t\t/*\n\t\t * Synchronize with kprobe_trace_func/kretprobe_trace_func\n\t\t * to ensure disabled (all running handlers are finished).\n\t\t * This is not only for kfree(), but also the caller,\n\t\t * trace_remove_event_call() supposes it for releasing\n\t\t * event_call related objects, which will be accessed in\n\t\t * the kprobe_trace_func/kretprobe_trace_func.\n\t\t */\n\t\tsynchronize_sched();\n\t\tkfree(link);\t/* Ignored if link == NULL */\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link = NULL;\n\tint wait = 0;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = find_event_file_link(&tk->tp, file);\n\t\tif (!link) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_del_rcu(&link->list);\n\t\twait = 1;\n\t\tif (!list_empty(&tk->tp.files))\n\t\t\tgoto out;\n\n\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t} else\n\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\n\tif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t\twait = 1;\n\t}\n\n\t/*\n\t * if tk is not added to any list, it must be a local trace_kprobe\n\t * created with perf_event_open. We don't need to wait for these\n\t * trace_kprobes\n\t */\n\tif (list_empty(&tk->list))\n\t\twait = 0;\n out:\n\tif (wait) {\n\t\t/*\n\t\t * Synchronize with kprobe_trace_func/kretprobe_trace_func\n\t\t * to ensure disabled (all running handlers are finished).\n\t\t * This is not only for kfree(), but also the caller,\n\t\t * trace_remove_event_call() supposes it for releasing\n\t\t * event_call related objects, which will be accessed in\n\t\t * the kprobe_trace_func/kretprobe_trace_func.\n\t\t */\n\t\tsynchronize_sched();\n\t\tkfree(link);\t/* Ignored if link == NULL */\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_trace_kprobe",
          "args": [
            "tk",
            "NULL"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "enable_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "250-282",
          "snippet": "static int\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tk->tp.files);\n\n\t\ttk->tp.flags |= TP_FLAG_TRACE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret) {\n\t\t\tlist_del_rcu(&link->list);\n\t\t\tkfree(link);\n\t\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t\t}\n\n\t} else {\n\t\ttk->tp.flags |= TP_FLAG_PROFILE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tk->tp.files);\n\n\t\ttk->tp.flags |= TP_FLAG_TRACE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret) {\n\t\t\tlist_del_rcu(&link->list);\n\t\t\tkfree(link);\n\t\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t\t}\n\n\t} else {\n\t\ttk->tp.flags |= TP_FLAG_PROFILE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int kprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)event->data;\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_kprobe(tk, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_kprobe(tk, file);\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn enable_trace_kprobe(tk, NULL);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn disable_trace_kprobe(tk, NULL);\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_get_kprobe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1243-1270",
    "snippet": "int bpf_get_kprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **symbol, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_kprobe *tk;\n\n\tif (perf_type_tracepoint)\n\t\ttk = find_trace_kprobe(pevent, group);\n\telse\n\t\ttk = event->tp_event->data;\n\tif (!tk)\n\t\treturn -EINVAL;\n\n\t*fd_type = trace_kprobe_is_return(tk) ? BPF_FD_TYPE_KRETPROBE\n\t\t\t\t\t      : BPF_FD_TYPE_KPROBE;\n\tif (tk->symbol) {\n\t\t*symbol = tk->symbol;\n\t\t*probe_offset = tk->rp.kp.offset;\n\t\t*probe_addr = 0;\n\t} else {\n\t\t*symbol = NULL;\n\t\t*probe_offset = 0;\n\t\t*probe_addr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "pevent",
            "group"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "220-230",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "event->tp_event"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nint bpf_get_kprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **symbol, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_kprobe *tk;\n\n\tif (perf_type_tracepoint)\n\t\ttk = find_trace_kprobe(pevent, group);\n\telse\n\t\ttk = event->tp_event->data;\n\tif (!tk)\n\t\treturn -EINVAL;\n\n\t*fd_type = trace_kprobe_is_return(tk) ? BPF_FD_TYPE_KRETPROBE\n\t\t\t\t\t      : BPF_FD_TYPE_KPROBE;\n\tif (tk->symbol) {\n\t\t*symbol = tk->symbol;\n\t\t*probe_offset = tk->rp.kp.offset;\n\t\t*probe_addr = 0;\n\t} else {\n\t\t*symbol = NULL;\n\t\t*probe_offset = 0;\n\t\t*probe_addr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kretprobe_perf_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1209-1240",
    "snippet": "static void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "size",
            "rctx",
            "call->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "166-188",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "388-410",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "__size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "147-163",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "call->perf_events"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "regs"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "37-79",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "call"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}"
  },
  {
    "function_name": "kprobe_perf_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1160-1205",
    "snippet": "static int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "size",
            "rctx",
            "call->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "166-188",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry[1]",
            "0",
            "dsize"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "388-410",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "__size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "147-163",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "call->perf_events"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "regs"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "37-79",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "call"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &tk->tp.call;\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "kretprobe_event_define_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1145-1155",
    "snippet": "static int kretprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kretprobe_trace_entry_head field;\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)event_call->data;\n\n\tDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\n\tDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), &tk->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "sizeof(field)",
            "&tk->tp"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "639-662",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int kretprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kretprobe_trace_entry_head field;\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)event_call->data;\n\n\tDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\n\tDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), &tk->tp);\n}"
  },
  {
    "function_name": "kprobe_event_define_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1134-1143",
    "snippet": "static int kprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kprobe_trace_entry_head field;\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)event_call->data;\n\n\tDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), &tk->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "sizeof(field)",
            "&tk->tp"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "639-662",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int kprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kprobe_trace_entry_head field;\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)event_call->data;\n\n\tDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), &tk->tp);\n}"
  },
  {
    "function_name": "print_kretprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1100-1131",
    "snippet": "static enum print_line_t\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\n\t\t      struct trace_event *event)\n{\n\tstruct kretprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kretprobe_trace_entry_head *)iter->ent;\n\ttp = container_of(event, struct trace_probe, call.event);\n\n\ttrace_seq_printf(s, \"%s: (\", trace_event_name(&tp->call));\n\n\tif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_puts(s, \" <- \");\n\n\tif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tp->args",
            "tp->nr_args",
            "(u8 *)&field[1]",
            "field"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-216",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->func",
            "flags & ~TRACE_ITER_SYM_OFFSET"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "419-437",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\tif (sym_flags & TRACE_ITER_SYM_OFFSET)\n\t\tseq_print_sym_offset(s, \"%s\", ip);\n\telse\n\t\tseq_print_sym_short(s, \"%s\", ip);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\tif (sym_flags & TRACE_ITER_SYM_OFFSET)\n\t\tseq_print_sym_offset(s, \"%s\", ip);\n\telse\n\t\tseq_print_sym_short(s, \"%s\", ip);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" <- \""
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: (\"",
            "trace_event_name(&tp->call)"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tp->call"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_probe",
            "call.event"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\n\t\t      struct trace_event *event)\n{\n\tstruct kretprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kretprobe_trace_entry_head *)iter->ent;\n\ttp = container_of(event, struct trace_probe, call.event);\n\n\ttrace_seq_printf(s, \"%s: (\", trace_event_name(&tp->call));\n\n\tif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_puts(s, \" <- \");\n\n\tif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_kprobe_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1073-1098",
    "snippet": "static enum print_line_t\nprint_kprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct kprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kprobe_trace_entry_head *)iter->ent;\n\ttp = container_of(event, struct trace_probe, call.event);\n\n\ttrace_seq_printf(s, \"%s: (\", trace_event_name(&tp->call));\n\n\tif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tp->args",
            "tp->nr_args",
            "(u8 *)&field[1]",
            "field"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-216",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->ip",
            "flags | TRACE_ITER_SYM_OFFSET"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "419-437",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\tif (sym_flags & TRACE_ITER_SYM_OFFSET)\n\t\tseq_print_sym_offset(s, \"%s\", ip);\n\telse\n\t\tseq_print_sym_short(s, \"%s\", ip);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\tif (sym_flags & TRACE_ITER_SYM_OFFSET)\n\t\tseq_print_sym_offset(s, \"%s\", ip);\n\telse\n\t\tseq_print_sym_short(s, \"%s\", ip);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: (\"",
            "trace_event_name(&tp->call)"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tp->call"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_probe",
            "call.event"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\nprint_kprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct kprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kprobe_trace_entry_head *)iter->ent;\n\ttp = container_of(event, struct trace_probe, call.event);\n\n\ttrace_seq_printf(s, \"%s: (\", trace_event_name(&tp->call));\n\n\tif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "kretprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1061-1069",
    "snippet": "static void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kretprobe_trace_func",
          "args": [
            "tk",
            "ri",
            "regs",
            "link->file"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "__kretprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1023-1059",
          "snippet": "static nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, pc, dsize;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, pc, dsize;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "link",
            "&tk->tp.files",
            "list"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}"
  },
  {
    "function_name": "__kretprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1023-1059",
    "snippet": "static nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, pc, dsize;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit_regs",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "irq_flags",
            "pc",
            "regs"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1354-1369",
          "snippet": "static inline void\nevent_trigger_unlock_commit_regs(struct trace_event_file *file,\n\t\t\t\t struct ring_buffer *buffer,\n\t\t\t\t struct ring_buffer_event *event,\n\t\t\t\t void *entry, unsigned long irq_flags, int pc,\n\t\t\t\t struct pt_regs *regs)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit_regs(file->tr, buffer, event,\n\t\t\t\t\t\tirq_flags, pc, regs);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit_regs(struct trace_event_file *file,\n\t\t\t\t struct ring_buffer *buffer,\n\t\t\t\t struct ring_buffer_event *event,\n\t\t\t\t void *entry, unsigned long irq_flags, int pc,\n\t\t\t\t struct pt_regs *regs)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit_regs(file->tr, buffer, event,\n\t\t\t\t\t\tirq_flags, pc, regs);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "166-188",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "trace_file",
            "call->event.type",
            "size",
            "irq_flags",
            "pc"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2274-2312",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct ring_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "147-163",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "irq_flags"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "call != trace_file->event_call"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, pc, dsize;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}"
  },
  {
    "function_name": "kprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "1012-1019",
    "snippet": "static void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kprobe_trace_func",
          "args": [
            "tk",
            "regs",
            "link->file"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "__kprobe_trace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "976-1010",
          "snippet": "void\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, dsize, pc;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nvoid\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, dsize, pc;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "link",
            "&tk->tp.files",
            "list"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry_rcu(link, &tk->tp.files, list)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}"
  },
  {
    "function_name": "__kprobe_trace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "976-1010",
    "snippet": "void\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, dsize, pc;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit_regs",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "irq_flags",
            "pc",
            "regs"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1354-1369",
          "snippet": "static inline void\nevent_trigger_unlock_commit_regs(struct trace_event_file *file,\n\t\t\t\t struct ring_buffer *buffer,\n\t\t\t\t struct ring_buffer_event *event,\n\t\t\t\t void *entry, unsigned long irq_flags, int pc,\n\t\t\t\t struct pt_regs *regs)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit_regs(file->tr, buffer, event,\n\t\t\t\t\t\tirq_flags, pc, regs);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit_regs(struct trace_event_file *file,\n\t\t\t\t struct ring_buffer *buffer,\n\t\t\t\t struct ring_buffer_event *event,\n\t\t\t\t void *entry, unsigned long irq_flags, int pc,\n\t\t\t\t struct pt_regs *regs)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit_regs(file->tr, buffer, event,\n\t\t\t\t\t\tirq_flags, pc, regs);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "166-188",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, struct pt_regs *regs,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, regs, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic))\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\telse\n\t\t\tdyndata += ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "trace_file",
            "call->event.type",
            "size",
            "irq_flags",
            "pc"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2274-2312",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct ring_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "147-163",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "irq_flags"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "call != trace_file->event_call"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nvoid\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tint size, dsize, pc;\n\tunsigned long irq_flags;\n\tstruct trace_event_call *call = &tk->tp.call;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\tsize = sizeof(*entry) + tk->tp.size + dsize;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\n\t\t\t\t\t\tcall->event.type,\n\t\t\t\t\t\tsize, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\tevent_trigger_unlock_commit_regs(trace_file, buffer, event,\n\t\t\t\t\t entry, irq_flags, pc, regs);\n}"
  },
  {
    "function_name": "process_fetch_insn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "931-972",
    "snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\nretry:\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = regs_get_kernel_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = (unsigned long)current->comm;\n\t\tbreak;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\tcase FETCH_OP_ARG:\n\t\tval = regs_get_kernel_argument(regs, code->param);\n\t\tbreak;\n#endif\n\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */\n\t\tcode++;\n\t\tgoto retry;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn_bottom",
          "args": [
            "code",
            "val",
            "dest",
            "base"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "66-144",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\twhile (code->op == FETCH_OP_DEREF) {\n\t\tlval = val;\n\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\tsizeof(val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t}\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret += fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\twhile (code->op == FETCH_OP_DEREF) {\n\t\tlval = val;\n\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\tsizeof(val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t}\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret += fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regs_get_kernel_argument",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_return_value",
          "args": [
            "regs"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_get_kernel_stack_nth",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_get_register",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nprocess_fetch_insn(struct fetch_insn *code, struct pt_regs *regs, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\nretry:\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = regs_get_kernel_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = (unsigned long)current->comm;\n\t\tbreak;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\tcase FETCH_OP_ARG:\n\t\tval = regs_get_kernel_argument(regs, code->param);\n\t\tbreak;\n#endif\n\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */\n\t\tcode++;\n\t\tgoto retry;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}"
  },
  {
    "function_name": "probe_mem_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "924-928",
    "snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\treturn probe_kernel_read(dest, src, size);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "dest",
            "src",
            "size"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\treturn probe_kernel_read(dest, src, size);\n}"
  },
  {
    "function_name": "fetch_store_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "904-922",
    "snippet": "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tu8 *dst = get_loc_data(dest, base);\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_unsafe(dst, (void *)addr, maxlen);\n\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "(void *)dst - base"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_unsafe",
          "args": [
            "dst",
            "(void *)addr",
            "maxlen"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "*(u32 *)dest"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tu8 *dst = get_loc_data(dest, base);\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_unsafe(dst, (void *)addr, maxlen);\n\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\treturn ret;\n}"
  },
  {
    "function_name": "fetch_store_strlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "878-898",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn (ret < 0) ? ret : len;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user_inatomic",
          "args": [
            "&c",
            "(u8 *)addr + len",
            "1"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn (ret < 0) ? ret : len;\n}"
  },
  {
    "function_name": "profile_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "862-865",
    "snippet": "static int profile_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &profile_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations profile_seq_op = {\n\t.start  = probes_seq_start,\n\t.next   = probes_seq_next,\n\t.stop   = probes_seq_stop,\n\t.show   = probes_profile_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&profile_seq_op"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations profile_seq_op = {\n\t.start  = probes_seq_start,\n\t.next   = probes_seq_next,\n\t.stop   = probes_seq_stop,\n\t.show   = probes_profile_seq_show\n};\n\nstatic int profile_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &profile_seq_op);\n}"
  },
  {
    "function_name": "probes_profile_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "843-853",
    "snippet": "static int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_kprobe *tk = v;\n\n\tseq_printf(m, \"  %-44s %15lu %15lu\\n\",\n\t\t   trace_event_name(&tk->tp.call),\n\t\t   trace_kprobe_nhit(tk),\n\t\t   tk->rp.kp.nmissed);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %-44s %15lu %15lu\\n\"",
            "trace_event_name(&tk->tp.call)",
            "trace_kprobe_nhit(tk)",
            "tk->rp.kp.nmissed"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_nhit",
          "args": [
            "tk"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_nhit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-93",
          "snippet": "static nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tk->tp.call"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_kprobe *tk = v;\n\n\tseq_printf(m, \"  %-44s %15lu %15lu\\n\",\n\t\t   trace_event_name(&tk->tp.call),\n\t\t   trace_kprobe_nhit(tk),\n\t\t   tk->rp.kp.nmissed);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "probes_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "826-831",
    "snippet": "static ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_trace_kprobe);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_trace_kprobe"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8407-8470",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_trace_kprobe);\n}"
  },
  {
    "function_name": "probes_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "813-824",
    "snippet": "static int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = release_all_trace_kprobes();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations probes_seq_op = {\n\t.start  = probes_seq_start,\n\t.next   = probes_seq_next,\n\t.stop   = probes_seq_stop,\n\t.show   = probes_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&probes_seq_op"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_trace_kprobes",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_trace_kprobes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "738-763",
          "snippet": "static int release_all_trace_kprobes(void)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = 0;\n\n\tmutex_lock(&probe_lock);\n\t/* Ensure no probe is in use. */\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t/* TODO: Use batch unregistration */\n\twhile (!list_empty(&probe_list)) {\n\t\ttk = list_entry(probe_list.next, struct trace_kprobe, list);\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(tk);\n\t}\n\nend:\n\tmutex_unlock(&probe_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static DEFINE_MUTEX(probe_lock);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic int release_all_trace_kprobes(void)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = 0;\n\n\tmutex_lock(&probe_lock);\n\t/* Ensure no probe is in use. */\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t/* TODO: Use batch unregistration */\n\twhile (!list_empty(&probe_list)) {\n\t\ttk = list_entry(probe_list.next, struct trace_kprobe, list);\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(tk);\n\t}\n\nend:\n\tmutex_unlock(&probe_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations probes_seq_op = {\n\t.start  = probes_seq_start,\n\t.next   = probes_seq_next,\n\t.stop   = probes_seq_stop,\n\t.show   = probes_seq_show\n};\n\nstatic int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = release_all_trace_kprobes();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}"
  },
  {
    "function_name": "probes_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "782-804",
    "snippet": "static int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_kprobe *tk = v;\n\tint i;\n\n\tseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\n\tseq_printf(m, \":%s/%s\", tk->tp.call.class->system,\n\t\t\ttrace_event_name(&tk->tp.call));\n\n\tif (!tk->symbol)\n\t\tseq_printf(m, \" 0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tseq_printf(m, \" %s+%u\", trace_kprobe_symbol(tk),\n\t\t\t   tk->rp.kp.offset);\n\telse\n\t\tseq_printf(m, \" %s\", trace_kprobe_symbol(tk));\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tk->tp.args[i].name, tk->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s=%s\"",
            "tk->tp.args[i].name",
            "tk->tp.args[i].comm"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "42-45",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tk->tp.call"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_kprobe *tk = v;\n\tint i;\n\n\tseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\n\tseq_printf(m, \":%s/%s\", tk->tp.call.class->system,\n\t\t\ttrace_event_name(&tk->tp.call));\n\n\tif (!tk->symbol)\n\t\tseq_printf(m, \" 0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tseq_printf(m, \" %s+%u\", trace_kprobe_symbol(tk),\n\t\t\t   tk->rp.kp.offset);\n\telse\n\t\tseq_printf(m, \" %s\", trace_kprobe_symbol(tk));\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tk->tp.args[i].name, tk->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "probes_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "777-780",
    "snippet": "static void probes_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&probe_lock);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(probe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe_lock"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(probe_lock);\n\nstatic void probes_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&probe_lock);\n}"
  },
  {
    "function_name": "probes_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "772-775",
    "snippet": "static void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &probe_list, pos);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&probe_list",
            "pos"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(probe_list);\n\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &probe_list, pos);\n}"
  },
  {
    "function_name": "probes_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "766-770",
    "snippet": "static void *probes_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&probe_lock);\n\treturn seq_list_start(&probe_list, *pos);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(probe_lock);",
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&probe_list",
            "*pos"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&probe_lock"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&probe_lock);\n\treturn seq_list_start(&probe_list, *pos);\n}"
  },
  {
    "function_name": "release_all_trace_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "738-763",
    "snippet": "static int release_all_trace_kprobes(void)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = 0;\n\n\tmutex_lock(&probe_lock);\n\t/* Ensure no probe is in use. */\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t/* TODO: Use batch unregistration */\n\twhile (!list_empty(&probe_list)) {\n\t\ttk = list_entry(probe_list.next, struct trace_kprobe, list);\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(tk);\n\t}\n\nend:\n\tmutex_unlock(&probe_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static DEFINE_MUTEX(probe_lock);",
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe_lock"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "206-218",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "423-437",
          "snippet": "static int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "probe_list.next",
            "structtrace_kprobe",
            "list"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&probe_list"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tk",
            "&probe_list",
            "list"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&probe_lock"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic int release_all_trace_kprobes(void)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = 0;\n\n\tmutex_lock(&probe_lock);\n\t/* Ensure no probe is in use. */\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t/* TODO: Use batch unregistration */\n\twhile (!list_empty(&probe_list)) {\n\t\ttk = list_entry(probe_list.next, struct trace_kprobe, list);\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(tk);\n\t}\n\nend:\n\tmutex_unlock(&probe_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "523-736",
    "snippet": "static int create_trace_kprobe(int argc, char **argv)\n{\n\t/*\n\t * Argument syntax:\n\t *  - Add kprobe:\n\t *      p[:[GRP/]EVENT] [MOD:]KSYM[+OFFS]|KADDR [FETCHARGS]\n\t *  - Add kretprobe:\n\t *      r[MAXACTIVE][:[GRP/]EVENT] [MOD:]KSYM[+0] [FETCHARGS]\n\t * Fetch args:\n\t *  $retval\t: fetch return value\n\t *  $stack\t: fetch stack address\n\t *  $stackN\t: fetch Nth of stack (N:0-)\n\t *  $comm       : fetch current task comm\n\t *  @ADDR\t: fetch memory at ADDR (ADDR should be in kernel)\n\t *  @SYM[+|-offs] : fetch memory at SYM +|- offs (SYM is a data symbol)\n\t *  %REG\t: fetch register REG\n\t * Dereferencing memory fetch:\n\t *  +|-offs(ARG) : fetch memory at ARG +|- offs address.\n\t * Alias name of args:\n\t *  NAME=FETCHARG : set NAME as alias of FETCHARG.\n\t * Type of args:\n\t *  FETCHARG:TYPE : use TYPE instead of unsigned long.\n\t */\n\tstruct trace_kprobe *tk;\n\tint i, ret = 0;\n\tbool is_return = false, is_delete = false;\n\tchar *symbol = NULL, *event = NULL, *group = NULL;\n\tint maxactive = 0;\n\tchar *arg;\n\tlong offset = 0;\n\tvoid *addr = NULL;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tunsigned int flags = TPARG_FL_KERNEL;\n\n\t/* argc must be >= 1 */\n\tif (argv[0][0] == 'p')\n\t\tis_return = false;\n\telse if (argv[0][0] == 'r') {\n\t\tis_return = true;\n\t\tflags |= TPARG_FL_RETURN;\n\t} else if (argv[0][0] == '-')\n\t\tis_delete = true;\n\telse {\n\t\tpr_info(\"Probe definition must be started with 'p', 'r' or\"\n\t\t\t\" '-'.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event) {\n\t\tevent[0] = '\\0';\n\t\tevent++;\n\t}\n\tif (is_return && isdigit(argv[0][1])) {\n\t\tret = kstrtouint(&argv[0][1], 0, &maxactive);\n\t\tif (ret) {\n\t\t\tpr_info(\"Failed to parse maxactive.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t/* kretprobes instances are iterated over via a list. The\n\t\t * maximum should stay reasonable.\n\t\t */\n\t\tif (maxactive > KRETPROBE_MAXACTIVE_MAX) {\n\t\t\tpr_info(\"Maxactive is too big (%d > %d).\\n\",\n\t\t\t\tmaxactive, KRETPROBE_MAXACTIVE_MAX);\n\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\n\tif (event) {\n\t\tchar *slash;\n\n\t\tslash = strchr(event, '/');\n\t\tif (slash) {\n\t\t\tgroup = event;\n\t\t\tevent = slash + 1;\n\t\t\tslash[0] = '\\0';\n\t\t\tif (strlen(group) == 0) {\n\t\t\t\tpr_info(\"Group name is not specified\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (strlen(event) == 0) {\n\t\t\tpr_info(\"Event name is not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!group)\n\t\tgroup = KPROBE_EVENT_SYSTEM;\n\n\tif (is_delete) {\n\t\tif (!event) {\n\t\t\tpr_info(\"Delete command needs an event name.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&probe_lock);\n\t\ttk = find_trace_kprobe(event, group);\n\t\tif (!tk) {\n\t\t\tmutex_unlock(&probe_lock);\n\t\t\tpr_info(\"Event %s/%s doesn't exist.\\n\", group, event);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t/* delete an event */\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret == 0)\n\t\t\tfree_trace_kprobe(tk);\n\t\tmutex_unlock(&probe_lock);\n\t\treturn ret;\n\t}\n\n\tif (argc < 2) {\n\t\tpr_info(\"Probe point is not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* try to parse an address. if that fails, try to read the\n\t * input as a symbol. */\n\tif (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {\n\t\t/* a symbol specified */\n\t\tsymbol = argv[1];\n\t\t/* TODO: support .init module functions */\n\t\tret = traceprobe_split_symbol_offset(symbol, &offset);\n\t\tif (ret || offset < 0 || offset > UINT_MAX) {\n\t\t\tpr_info(\"Failed to parse either an address or a symbol.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (kprobe_on_func_entry(NULL, symbol, offset))\n\t\t\tflags |= TPARG_FL_FENTRY;\n\t\tif (offset && is_return && !(flags & TPARG_FL_FENTRY)) {\n\t\t\tpr_info(\"Given offset is not valid for return probe.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\targc -= 2; argv += 2;\n\n\t/* setup a probe */\n\tif (!event) {\n\t\t/* Make a new event name */\n\t\tif (symbol)\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_%ld\",\n\t\t\t\t is_return ? 'r' : 'p', symbol, offset);\n\t\telse\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_0x%p\",\n\t\t\t\t is_return ? 'r' : 'p', addr);\n\t\tsanitize_event_name(buf);\n\t\tevent = buf;\n\t}\n\ttk = alloc_trace_kprobe(group, event, addr, symbol, offset, maxactive,\n\t\t\t       argc, is_return);\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn PTR_ERR(tk);\n\t}\n\n\t/* parse arguments */\n\tret = 0;\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\tstruct probe_arg *parg = &tk->tp.args[i];\n\n\t\t/* Increment count for freeing args in error case */\n\t\ttk->tp.nr_args++;\n\n\t\t/* Parse argument name */\n\t\targ = strchr(argv[i], '=');\n\t\tif (arg) {\n\t\t\t*arg++ = '\\0';\n\t\t\tparg->name = kstrdup(argv[i], GFP_KERNEL);\n\t\t} else {\n\t\t\targ = argv[i];\n\t\t\t/* If argument name is omitted, set \"argN\" */\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"arg%d\", i + 1);\n\t\t\tparg->name = kstrdup(buf, GFP_KERNEL);\n\t\t}\n\n\t\tif (!parg->name) {\n\t\t\tpr_info(\"Failed to allocate argument[%d] name.\\n\", i);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!is_good_name(parg->name)) {\n\t\t\tpr_info(\"Invalid argument[%d] name: %s\\n\",\n\t\t\t\ti, parg->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (traceprobe_conflict_field_name(parg->name,\n\t\t\t\t\t\t\ttk->tp.args, i)) {\n\t\t\tpr_info(\"Argument[%d] name '%s' conflicts with \"\n\t\t\t\t\"another field.\\n\", i, argv[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Parse fetch argument */\n\t\tret = traceprobe_parse_probe_arg(arg, &tk->tp.size, parg,\n\t\t\t\t\t\t flags);\n\t\tif (ret) {\n\t\t\tpr_info(\"Parse error at argument[%d]. (%d)\\n\", i, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = register_trace_kprobe(tk);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KRETPROBE_MAXACTIVE_MAX 4096",
      "#define KPROBE_EVENT_SYSTEM \"kprobes\""
    ],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static DEFINE_MUTEX(probe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "206-218",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "register_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "440-479",
          "snippet": "static int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&probe_lock);\n\n\t/* Delete old (same name) event if exist */\n\told_tk = find_trace_kprobe(trace_event_name(&tk->tp.call),\n\t\t\ttk->tp.call.class->system);\n\tif (old_tk) {\n\t\tret = unregister_trace_kprobe(old_tk);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(old_tk);\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tlist_add_tail(&tk->list, &probe_list);\n\nend:\n\tmutex_unlock(&probe_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static DEFINE_MUTEX(probe_lock);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&probe_lock);\n\n\t/* Delete old (same name) event if exist */\n\told_tk = find_trace_kprobe(trace_event_name(&tk->tp.call),\n\t\t\ttk->tp.call.class->system);\n\tif (old_tk) {\n\t\tret = unregister_trace_kprobe(old_tk);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(old_tk);\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tlist_add_tail(&tk->list, &probe_list);\n\nend:\n\tmutex_unlock(&probe_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Parse error at argument[%d]. (%d)\\n\"",
            "i",
            "ret"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_probe_arg",
          "args": [
            "arg",
            "&tk->tp.size",
            "parg",
            "flags"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "351-491",
          "snippet": "int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2;\n\tint ret, len;\n\n\tif (strlen(arg) > MAX_ARGSTR_LEN) {\n\t\tpr_info(\"Argument is too long.: %s\\n\",  arg);\n\t\treturn -ENOSPC;\n\t}\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm) {\n\t\tpr_info(\"Failed to allocate memory for command '%s'.\\n\", arg);\n\t\treturn -ENOMEM;\n\t}\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2 = '\\0';\n\t\t\tparg->count = simple_strtoul(t2 + 1, &t2, 0);\n\t\t\tif (strcmp(t2, \"]\") || parg->count == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (parg->count > MAX_ARRAY_LEN)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\t/*\n\t * The default type of $comm should be \"string\", and it can't be\n\t * dereferenced.\n\t */\n\tif (!t && strcmp(arg, \"$comm\") == 0)\n\t\tparg->type = find_fetch_type(\"string\");\n\telse\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\tpr_info(\"Unsupported type: %s\\n\", t);\n\t\treturn -EINVAL;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kzalloc(sizeof(*code) * FETCH_INSN_MAX, GFP_KERNEL);\n\tif (!code)\n\t\treturn -ENOMEM;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_IMM &&\n\t\t    code->op != FETCH_OP_COMM) {\n\t\t\tpr_info(\"string only accepts memory or address.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (code->op != FETCH_OP_DEREF || parg->count) {\n\t\t\t/*\n\t\t\t * IMM and COMM is pointing actual address, those must\n\t\t\t * be kept, and if parg->count != 0, this is an array\n\t\t\t * of string pointers instead of string address itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tcode->op = FETCH_OP_ST_STRING;\t/* In DEREF case, replace it */\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING) {\n\t\t\tpr_info(\"array only accepts memory or address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\t/* Shrink down the code buffer */\n\tparg->code = kzalloc(sizeof(*code) * (code - tmp + 1), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nint traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2;\n\tint ret, len;\n\n\tif (strlen(arg) > MAX_ARGSTR_LEN) {\n\t\tpr_info(\"Argument is too long.: %s\\n\",  arg);\n\t\treturn -ENOSPC;\n\t}\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm) {\n\t\tpr_info(\"Failed to allocate memory for command '%s'.\\n\", arg);\n\t\treturn -ENOMEM;\n\t}\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2 = '\\0';\n\t\t\tparg->count = simple_strtoul(t2 + 1, &t2, 0);\n\t\t\tif (strcmp(t2, \"]\") || parg->count == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (parg->count > MAX_ARRAY_LEN)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\t/*\n\t * The default type of $comm should be \"string\", and it can't be\n\t * dereferenced.\n\t */\n\tif (!t && strcmp(arg, \"$comm\") == 0)\n\t\tparg->type = find_fetch_type(\"string\");\n\telse\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\tpr_info(\"Unsupported type: %s\\n\", t);\n\t\treturn -EINVAL;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kzalloc(sizeof(*code) * FETCH_INSN_MAX, GFP_KERNEL);\n\tif (!code)\n\t\treturn -ENOMEM;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_IMM &&\n\t\t    code->op != FETCH_OP_COMM) {\n\t\t\tpr_info(\"string only accepts memory or address.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (code->op != FETCH_OP_DEREF || parg->count) {\n\t\t\t/*\n\t\t\t * IMM and COMM is pointing actual address, those must\n\t\t\t * be kept, and if parg->count != 0, this is an array\n\t\t\t * of string pointers instead of string address itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tcode->op = FETCH_OP_ST_STRING;\t/* In DEREF case, replace it */\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING) {\n\t\t\tpr_info(\"array only accepts memory or address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\t/* Shrink down the code buffer */\n\tparg->code = kzalloc(sizeof(*code) * (code - tmp + 1), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Argument[%d] name '%s' conflicts with \"\n\t\t\t\t\"another field.\\n\"",
            "i",
            "argv[i]"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_conflict_field_name",
          "args": [
            "parg->name",
            "tk->tp.args",
            "i"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_conflict_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "494-508",
          "snippet": "int traceprobe_conflict_field_name(const char *name,\n\t\t\t       struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};\n\nint traceprobe_conflict_field_name(const char *name,\n\t\t\t       struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Invalid argument[%d] name: %s\\n\"",
            "i",
            "parg->name"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "parg->name"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "247-256",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate argument[%d] name.\\n\"",
            "i"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"arg%d\"",
            "i + 1"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "argv[i]",
            "GFP_KERNEL"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[i]",
            "'='"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tk"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate trace_probe.(%d)\\n\"",
            "(int)PTR_ERR(tk)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tk"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tk"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_kprobe",
          "args": [
            "group",
            "event",
            "addr",
            "symbol",
            "offset",
            "maxactive",
            "argc",
            "is_return"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "141-204",
          "snippet": "static struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\n\tif (!event || !is_good_name(event)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.call.class = &tk->tp.class;\n\ttk->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tk->tp.call.name)\n\t\tgoto error;\n\n\tif (!group || !is_good_name(group)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tk->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tk->list);\n\tINIT_LIST_HEAD(&tk->tp.files);\n\treturn tk;\nerror:\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\n\tif (!event || !is_good_name(event)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.call.class = &tk->tp.class;\n\ttk->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tk->tp.call.name)\n\t\tgoto error;\n\n\tif (!group || !is_good_name(group)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tk->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tk->list);\n\tINIT_LIST_HEAD(&tk->tp.files);\n\treturn tk;\nerror:\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_event_name",
          "args": [
            "buf"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_event_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "516-521",
          "snippet": "static inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"%c_0x%p\"",
            "is_return ? 'r' : 'p'",
            "addr"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"%c_%s_%ld\"",
            "is_return ? 'r' : 'p'",
            "symbol",
            "offset"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Given offset is not valid for return probe.\\n\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_on_func_entry",
          "args": [
            "NULL",
            "symbol",
            "offset"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_on_func_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1864-1876",
          "snippet": "bool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to parse either an address or a symbol.\\n\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traceprobe_split_symbol_offset",
          "args": [
            "symbol",
            "&offset"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_split_symbol_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "137-155",
          "snippet": "int traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "argv[1]",
            "0",
            "(unsigned long *)&addr"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Probe point is not specified.\\n\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe_lock"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "423-437",
          "snippet": "static int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Event %s/%s doesn't exist.\\n\"",
            "group",
            "event"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "event",
            "group"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "220-230",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&probe_lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Delete command needs an event name.\\n\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Event name is not specified\\n\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "event"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "878-898",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Group name is not specified\\n\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "event",
            "'/'"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Maxactive is too big (%d > %d).\\n\"",
            "maxactive",
            "KRETPROBE_MAXACTIVE_MAX"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to parse maxactive.\\n\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "&argv[0][1]",
            "0",
            "&maxactive"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "argv[0][1]"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "&argv[0][1]",
            "':'"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Probe definition must be started with 'p', 'r' or\"\n\t\t\t\" '-'.\\n\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define KRETPROBE_MAXACTIVE_MAX 4096\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\n\nstatic int create_trace_kprobe(int argc, char **argv)\n{\n\t/*\n\t * Argument syntax:\n\t *  - Add kprobe:\n\t *      p[:[GRP/]EVENT] [MOD:]KSYM[+OFFS]|KADDR [FETCHARGS]\n\t *  - Add kretprobe:\n\t *      r[MAXACTIVE][:[GRP/]EVENT] [MOD:]KSYM[+0] [FETCHARGS]\n\t * Fetch args:\n\t *  $retval\t: fetch return value\n\t *  $stack\t: fetch stack address\n\t *  $stackN\t: fetch Nth of stack (N:0-)\n\t *  $comm       : fetch current task comm\n\t *  @ADDR\t: fetch memory at ADDR (ADDR should be in kernel)\n\t *  @SYM[+|-offs] : fetch memory at SYM +|- offs (SYM is a data symbol)\n\t *  %REG\t: fetch register REG\n\t * Dereferencing memory fetch:\n\t *  +|-offs(ARG) : fetch memory at ARG +|- offs address.\n\t * Alias name of args:\n\t *  NAME=FETCHARG : set NAME as alias of FETCHARG.\n\t * Type of args:\n\t *  FETCHARG:TYPE : use TYPE instead of unsigned long.\n\t */\n\tstruct trace_kprobe *tk;\n\tint i, ret = 0;\n\tbool is_return = false, is_delete = false;\n\tchar *symbol = NULL, *event = NULL, *group = NULL;\n\tint maxactive = 0;\n\tchar *arg;\n\tlong offset = 0;\n\tvoid *addr = NULL;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tunsigned int flags = TPARG_FL_KERNEL;\n\n\t/* argc must be >= 1 */\n\tif (argv[0][0] == 'p')\n\t\tis_return = false;\n\telse if (argv[0][0] == 'r') {\n\t\tis_return = true;\n\t\tflags |= TPARG_FL_RETURN;\n\t} else if (argv[0][0] == '-')\n\t\tis_delete = true;\n\telse {\n\t\tpr_info(\"Probe definition must be started with 'p', 'r' or\"\n\t\t\t\" '-'.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event) {\n\t\tevent[0] = '\\0';\n\t\tevent++;\n\t}\n\tif (is_return && isdigit(argv[0][1])) {\n\t\tret = kstrtouint(&argv[0][1], 0, &maxactive);\n\t\tif (ret) {\n\t\t\tpr_info(\"Failed to parse maxactive.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t/* kretprobes instances are iterated over via a list. The\n\t\t * maximum should stay reasonable.\n\t\t */\n\t\tif (maxactive > KRETPROBE_MAXACTIVE_MAX) {\n\t\t\tpr_info(\"Maxactive is too big (%d > %d).\\n\",\n\t\t\t\tmaxactive, KRETPROBE_MAXACTIVE_MAX);\n\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\n\tif (event) {\n\t\tchar *slash;\n\n\t\tslash = strchr(event, '/');\n\t\tif (slash) {\n\t\t\tgroup = event;\n\t\t\tevent = slash + 1;\n\t\t\tslash[0] = '\\0';\n\t\t\tif (strlen(group) == 0) {\n\t\t\t\tpr_info(\"Group name is not specified\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (strlen(event) == 0) {\n\t\t\tpr_info(\"Event name is not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!group)\n\t\tgroup = KPROBE_EVENT_SYSTEM;\n\n\tif (is_delete) {\n\t\tif (!event) {\n\t\t\tpr_info(\"Delete command needs an event name.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&probe_lock);\n\t\ttk = find_trace_kprobe(event, group);\n\t\tif (!tk) {\n\t\t\tmutex_unlock(&probe_lock);\n\t\t\tpr_info(\"Event %s/%s doesn't exist.\\n\", group, event);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t/* delete an event */\n\t\tret = unregister_trace_kprobe(tk);\n\t\tif (ret == 0)\n\t\t\tfree_trace_kprobe(tk);\n\t\tmutex_unlock(&probe_lock);\n\t\treturn ret;\n\t}\n\n\tif (argc < 2) {\n\t\tpr_info(\"Probe point is not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* try to parse an address. if that fails, try to read the\n\t * input as a symbol. */\n\tif (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {\n\t\t/* a symbol specified */\n\t\tsymbol = argv[1];\n\t\t/* TODO: support .init module functions */\n\t\tret = traceprobe_split_symbol_offset(symbol, &offset);\n\t\tif (ret || offset < 0 || offset > UINT_MAX) {\n\t\t\tpr_info(\"Failed to parse either an address or a symbol.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (kprobe_on_func_entry(NULL, symbol, offset))\n\t\t\tflags |= TPARG_FL_FENTRY;\n\t\tif (offset && is_return && !(flags & TPARG_FL_FENTRY)) {\n\t\t\tpr_info(\"Given offset is not valid for return probe.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\targc -= 2; argv += 2;\n\n\t/* setup a probe */\n\tif (!event) {\n\t\t/* Make a new event name */\n\t\tif (symbol)\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_%ld\",\n\t\t\t\t is_return ? 'r' : 'p', symbol, offset);\n\t\telse\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_0x%p\",\n\t\t\t\t is_return ? 'r' : 'p', addr);\n\t\tsanitize_event_name(buf);\n\t\tevent = buf;\n\t}\n\ttk = alloc_trace_kprobe(group, event, addr, symbol, offset, maxactive,\n\t\t\t       argc, is_return);\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn PTR_ERR(tk);\n\t}\n\n\t/* parse arguments */\n\tret = 0;\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\tstruct probe_arg *parg = &tk->tp.args[i];\n\n\t\t/* Increment count for freeing args in error case */\n\t\ttk->tp.nr_args++;\n\n\t\t/* Parse argument name */\n\t\targ = strchr(argv[i], '=');\n\t\tif (arg) {\n\t\t\t*arg++ = '\\0';\n\t\t\tparg->name = kstrdup(argv[i], GFP_KERNEL);\n\t\t} else {\n\t\t\targ = argv[i];\n\t\t\t/* If argument name is omitted, set \"argN\" */\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"arg%d\", i + 1);\n\t\t\tparg->name = kstrdup(buf, GFP_KERNEL);\n\t\t}\n\n\t\tif (!parg->name) {\n\t\t\tpr_info(\"Failed to allocate argument[%d] name.\\n\", i);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!is_good_name(parg->name)) {\n\t\t\tpr_info(\"Invalid argument[%d] name: %s\\n\",\n\t\t\t\ti, parg->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (traceprobe_conflict_field_name(parg->name,\n\t\t\t\t\t\t\ttk->tp.args, i)) {\n\t\t\tpr_info(\"Argument[%d] name '%s' conflicts with \"\n\t\t\t\t\"another field.\\n\", i, argv[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Parse fetch argument */\n\t\tret = traceprobe_parse_probe_arg(arg, &tk->tp.size, parg,\n\t\t\t\t\t\t flags);\n\t\tif (ret) {\n\t\t\tpr_info(\"Parse error at argument[%d]. (%d)\\n\", i, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = register_trace_kprobe(tk);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ret;\n}"
  },
  {
    "function_name": "sanitize_event_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "516-521",
    "snippet": "static inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}"
  },
  {
    "function_name": "trace_kprobe_module_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "482-508",
    "snippet": "static int trace_kprobe_module_callback(struct notifier_block *nb,\n\t\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\n\tif (val != MODULE_STATE_COMING)\n\t\treturn NOTIFY_DONE;\n\n\t/* Update probes on coming module */\n\tmutex_lock(&probe_lock);\n\tlist_for_each_entry(tk, &probe_list, list) {\n\t\tif (trace_kprobe_within_module(tk, mod)) {\n\t\t\t/* Don't need to check busy - this should have gone. */\n\t\t\t__unregister_trace_kprobe(tk);\n\t\t\tret = __register_trace_kprobe(tk);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to re-register probe %s on %s: %d\\n\",\n\t\t\t\t\ttrace_event_name(&tk->tp.call),\n\t\t\t\t\tmod->name, ret);\n\t\t}\n\t}\n\tmutex_unlock(&probe_lock);\n\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static DEFINE_MUTEX(probe_lock);",
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe_lock"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to re-register probe %s on %s: %d\\n\"",
            "trace_event_name(&tk->tp.call)",
            "mod->name",
            "ret"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tk->tp.call"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "367-405",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "408-420",
          "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_within_module",
          "args": [
            "tk",
            "mod"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_within_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "57-63",
          "snippet": "static nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tk",
            "&probe_list",
            "list"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&probe_lock"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic int trace_kprobe_module_callback(struct notifier_block *nb,\n\t\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\n\tif (val != MODULE_STATE_COMING)\n\t\treturn NOTIFY_DONE;\n\n\t/* Update probes on coming module */\n\tmutex_lock(&probe_lock);\n\tlist_for_each_entry(tk, &probe_list, list) {\n\t\tif (trace_kprobe_within_module(tk, mod)) {\n\t\t\t/* Don't need to check busy - this should have gone. */\n\t\t\t__unregister_trace_kprobe(tk);\n\t\t\tret = __register_trace_kprobe(tk);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to re-register probe %s on %s: %d\\n\",\n\t\t\t\t\ttrace_event_name(&tk->tp.call),\n\t\t\t\t\tmod->name, ret);\n\t\t}\n\t}\n\tmutex_unlock(&probe_lock);\n\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "register_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "440-479",
    "snippet": "static int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&probe_lock);\n\n\t/* Delete old (same name) event if exist */\n\told_tk = find_trace_kprobe(trace_event_name(&tk->tp.call),\n\t\t\ttk->tp.call.class->system);\n\tif (old_tk) {\n\t\tret = unregister_trace_kprobe(old_tk);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(old_tk);\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tlist_add_tail(&tk->list, &probe_list);\n\nend:\n\tmutex_unlock(&probe_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static DEFINE_MUTEX(probe_lock);",
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probe_lock"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tk->list",
            "&probe_list"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_kprobe_event",
          "args": [
            "tk"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1389-1398",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"This probe might be able to register after target module is loaded. Continue.\\n\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_module_exist",
          "args": [
            "tk"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_module_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "65-82",
          "snippet": "static nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\tmutex_lock(&module_mutex);\n\tret = !!find_module(tk->symbol);\n\tmutex_unlock(&module_mutex);\n\t*p = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\tmutex_lock(&module_mutex);\n\tret = !!find_module(tk->symbol);\n\tmutex_unlock(&module_mutex);\n\t*p = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "367-405",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register probe event(%d)\\n\"",
            "ret"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "old_tk"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "206-218",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_kprobe",
          "args": [
            "old_tk"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "423-437",
          "snippet": "static int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "trace_event_name(&tk->tp.call)",
            "tk->tp.call.class->system"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "220-230",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tk->tp.call"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&probe_lock"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic DEFINE_MUTEX(probe_lock);\nstatic LIST_HEAD(probe_list);\n\nstatic int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&probe_lock);\n\n\t/* Delete old (same name) event if exist */\n\told_tk = find_trace_kprobe(trace_event_name(&tk->tp.call),\n\t\t\ttk->tp.call.class->system);\n\tif (old_tk) {\n\t\tret = unregister_trace_kprobe(old_tk);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(old_tk);\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tlist_add_tail(&tk->list, &probe_list);\n\nend:\n\tmutex_unlock(&probe_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "423-437",
    "snippet": "static int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tk->list"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "408-420",
          "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kprobe_event",
          "args": [
            "tk"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1389-1398",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\n\t__unregister_trace_kprobe(tk);\n\tlist_del(&tk->list);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__unregister_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "408-420",
    "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1389-1398",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1992-1994",
          "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_registered",
          "args": [
            "&tk->tp"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "241-244",
          "snippet": "static inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_REGISTERED\t4"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_REGISTERED\t4\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\ttk->tp.flags &= ~TP_FLAG_REGISTERED;\n\t\t/* Cleanup kprobe for reuse */\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
  },
  {
    "function_name": "__register_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "367-405",
    "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Probing address(0x%p) is not an instruction boundary.\\n\"",
            "tk->rp.kp.addr"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1389-1398",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\tint ret;\n\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\tret = trace_remove_event_call(&tk->tp.call);\n\tif (!ret)\n\t\tkfree(tk->tp.call.print_fmt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1992-1994",
          "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_update_arg",
          "args": [
            "&tk->tp.args[i]"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_update_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "525-557",
          "snippet": "int traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(\"+-\", code->data);\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(\"+-\", code->data);\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not probe notrace function %s\\n\"",
            "trace_kprobe_symbol(tk)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "42-45",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_notrace_func",
          "args": [
            "tk"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "within_notrace_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "345-361",
          "snippet": "static bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long offset, size, addr;\n\n\taddr = trace_kprobe_address(tk);\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long offset, size, addr;\n\n\taddr = trace_kprobe_address(tk);\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_registered",
          "args": [
            "&tk->tp"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "241-244",
          "snippet": "static inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_REGISTERED\t4"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_REGISTERED\t4\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tif (trace_probe_is_registered(&tk->tp))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\tif (ret == 0) {\n\t\ttk->tp.flags |= TP_FLAG_REGISTERED;\n\t} else if (ret == -EILSEQ) {\n\t\tpr_warn(\"Probing address(0x%p) is not an instruction boundary.\\n\",\n\t\t\ttk->rp.kp.addr);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "within_notrace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "345-361",
    "snippet": "static bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long offset, size, addr;\n\n\taddr = trace_kprobe_address(tk);\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "addr",
            "addr + size - 1"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1572-1593",
          "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tfor (pg = ftrace_pages_start; pg; pg = pg->next) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (rec)\n\t\t\treturn rec->ip;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "addr",
            "&size",
            "&offset"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "260-269",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_address",
          "args": [
            "tk"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "96-110",
          "snippet": "static nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long offset, size, addr;\n\n\taddr = trace_kprobe_address(tk);\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}"
  },
  {
    "function_name": "disable_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "288-341",
    "snippet": "static int\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link = NULL;\n\tint wait = 0;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = find_event_file_link(&tk->tp, file);\n\t\tif (!link) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_del_rcu(&link->list);\n\t\twait = 1;\n\t\tif (!list_empty(&tk->tp.files))\n\t\t\tgoto out;\n\n\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t} else\n\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\n\tif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t\twait = 1;\n\t}\n\n\t/*\n\t * if tk is not added to any list, it must be a local trace_kprobe\n\t * created with perf_event_open. We don't need to wait for these\n\t * trace_kprobes\n\t */\n\tif (list_empty(&tk->list))\n\t\twait = 0;\n out:\n\tif (wait) {\n\t\t/*\n\t\t * Synchronize with kprobe_trace_func/kretprobe_trace_func\n\t\t * to ensure disabled (all running handlers are finished).\n\t\t * This is not only for kfree(), but also the caller,\n\t\t * trace_remove_event_call() supposes it for releasing\n\t\t * event_call related objects, which will be accessed in\n\t\t * the kprobe_trace_func/kretprobe_trace_func.\n\t\t */\n\t\tsynchronize_sched();\n\t\tkfree(link);\t/* Ignored if link == NULL */\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tk->list"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "disable_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "2034-2048",
          "snippet": "int disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_registered",
          "args": [
            "&tk->tp"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "241-244",
          "snippet": "static inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_REGISTERED\t4"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_REGISTERED\t4\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "236-239",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&link->list"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file_link",
          "args": [
            "&tk->tp",
            "file"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "258-268",
          "snippet": "static inline struct event_file_link *\nfind_event_file_link(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry(link, &tp->files, list)\n\t\tif (link->file == file)\n\t\t\treturn link;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct event_file_link *\nfind_event_file_link(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlist_for_each_entry(link, &tp->files, list)\n\t\tif (link->file == file)\n\t\t\treturn link;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link = NULL;\n\tint wait = 0;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = find_event_file_link(&tk->tp, file);\n\t\tif (!link) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_del_rcu(&link->list);\n\t\twait = 1;\n\t\tif (!list_empty(&tk->tp.files))\n\t\t\tgoto out;\n\n\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t} else\n\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\n\tif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t\twait = 1;\n\t}\n\n\t/*\n\t * if tk is not added to any list, it must be a local trace_kprobe\n\t * created with perf_event_open. We don't need to wait for these\n\t * trace_kprobes\n\t */\n\tif (list_empty(&tk->list))\n\t\twait = 0;\n out:\n\tif (wait) {\n\t\t/*\n\t\t * Synchronize with kprobe_trace_func/kretprobe_trace_func\n\t\t * to ensure disabled (all running handlers are finished).\n\t\t * This is not only for kfree(), but also the caller,\n\t\t * trace_remove_event_call() supposes it for releasing\n\t\t * event_call related objects, which will be accessed in\n\t\t * the kprobe_trace_func/kretprobe_trace_func.\n\t\t */\n\t\tsynchronize_sched();\n\t\tkfree(link);\t/* Ignored if link == NULL */\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "enable_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "250-282",
    "snippet": "static int\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tk->tp.files);\n\n\t\ttk->tp.flags |= TP_FLAG_TRACE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret) {\n\t\t\tlist_del_rcu(&link->list);\n\t\t\tkfree(link);\n\t\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t\t}\n\n\t} else {\n\t\ttk->tp.flags |= TP_FLAG_PROFILE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__enable_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "232-244",
          "snippet": "static inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_probe_is_registered(&tk->tp) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_probe_is_registered(&tk->tp) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&link->list"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&link->list",
            "&tk->tp.files"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*link)",
            "GFP_KERNEL"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\tint ret = 0;\n\n\tif (file) {\n\t\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlink->file = file;\n\t\tlist_add_tail_rcu(&link->list, &tk->tp.files);\n\n\t\ttk->tp.flags |= TP_FLAG_TRACE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret) {\n\t\t\tlist_del_rcu(&link->list);\n\t\t\tkfree(link);\n\t\t\ttk->tp.flags &= ~TP_FLAG_TRACE;\n\t\t}\n\n\t} else {\n\t\ttk->tp.flags |= TP_FLAG_PROFILE;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\ttk->tp.flags &= ~TP_FLAG_PROFILE;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "__enable_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "232-244",
    "snippet": "static inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_probe_is_registered(&tk->tp) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "enable_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "2052-2084",
          "snippet": "int enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "37-40",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_has_gone",
          "args": [
            "tk"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_has_gone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "52-55",
          "snippet": "static nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn !!(kprobe_gone(&tk->rp.kp));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn !!(kprobe_gone(&tk->rp.kp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_registered",
          "args": [
            "&tk->tp"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "241-244",
          "snippet": "static inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_REGISTERED\t4"
          ],
          "globals_used": [
            "extern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_REGISTERED\t4\n\nextern int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\t   struct probe_arg *parg, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_registered(struct trace_probe *tp)\n{\n\treturn !!(tp->flags & TP_FLAG_REGISTERED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_probe_is_registered(&tk->tp) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "220-230",
    "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static LIST_HEAD(probe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tk->tp.call.class->system",
            "group"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trace_event_name(&tk->tp.call)",
            "event"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "&tk->tp.call"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tk",
            "&probe_list",
            "list"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, &probe_list, list)\n\t\tif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\n\t\t    strcmp(tk->tp.call.class->system, group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "206-218",
    "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "tk->nhit"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_free_probe_arg",
          "args": [
            "&tk->tp.args[i]"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_free_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "510-523",
          "snippet": "void traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i;\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tk->tp.args[i]);\n\n\tkfree(tk->tp.call.class->system);\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n}"
  },
  {
    "function_name": "alloc_trace_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "141-204",
    "snippet": "static struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\n\tif (!event || !is_good_name(event)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.call.class = &tk->tp.class;\n\ttk->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tk->tp.call.name)\n\t\tgoto error;\n\n\tif (!group || !is_good_name(group)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tk->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tk->list);\n\tINIT_LIST_HEAD(&tk->tp.files);\n\treturn tk;\nerror:\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "tk->nhit"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tk->tp.files"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tk->list"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "group",
            "GFP_KERNEL"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "group"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "247-256",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event",
            "GFP_KERNEL"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "symbol",
            "GFP_KERNEL"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "unsignedlong"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SIZEOF_TRACE_KPROBE(nargs)",
            "GFP_KERNEL"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZEOF_TRACE_KPROBE",
          "args": [
            "nargs"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\n\tif (!event || !is_good_name(event)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.call.class = &tk->tp.class;\n\ttk->tp.call.name = kstrdup(event, GFP_KERNEL);\n\tif (!tk->tp.call.name)\n\t\tgoto error;\n\n\tif (!group || !is_good_name(group)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk->tp.class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tk->tp.class.system)\n\t\tgoto error;\n\n\tINIT_LIST_HEAD(&tk->list);\n\tINIT_LIST_HEAD(&tk->tp.files);\n\treturn tk;\nerror:\n\tkfree(tk->tp.call.name);\n\tkfree(tk->symbol);\n\tfree_percpu(tk->nhit);\n\tkfree(tk);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "trace_kprobe_error_injectable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "121-126",
    "snippet": "bool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn within_error_injection_list(trace_kprobe_address(tk));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "within_error_injection_list",
          "args": [
            "trace_kprobe_address(tk)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_address",
          "args": [
            "tk"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "96-110",
          "snippet": "static nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nbool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn within_error_injection_list(trace_kprobe_address(tk));\n}"
  },
  {
    "function_name": "trace_kprobe_on_func_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "112-119",
    "snippet": "bool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn kprobe_on_func_entry(tk->rp.kp.addr,\n\t\t\ttk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name,\n\t\t\ttk->rp.kp.addr ? 0 : tk->rp.kp.offset);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_on_func_entry",
          "args": [
            "tk->rp.kp.addr",
            "tk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name",
            "tk->rp.kp.addr ? 0 : tk->rp.kp.offset"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_on_func_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1864-1876",
          "snippet": "bool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn false;\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset) ||\n\t\t\t\t\t\t!arch_kprobe_on_func_entry(offset))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nbool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = (struct trace_kprobe *)call->data;\n\n\treturn kprobe_on_func_entry(tk->rp.kp.addr,\n\t\t\ttk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name,\n\t\t\ttk->rp.kp.addr ? 0 : tk->rp.kp.offset);\n}"
  },
  {
    "function_name": "trace_kprobe_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "96-110",
    "snippet": "static nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "trace_kprobe_symbol(tk)"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4090-4111",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "42-45",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}"
  },
  {
    "function_name": "trace_kprobe_nhit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "84-93",
    "snippet": "static nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}"
  },
  {
    "function_name": "trace_kprobe_module_exist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "65-82",
    "snippet": "static nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\tmutex_lock(&module_mutex);\n\tret = !!find_module(tk->symbol);\n\tmutex_unlock(&module_mutex);\n\t*p = ':';\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&module_mutex"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_module",
          "args": [
            "tk->symbol"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "find_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "621-625",
          "snippet": "struct module *find_module(const char *name)\n{\n\tmodule_assert_mutex();\n\treturn find_module_all(name, strlen(name), false);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstruct module *find_module(const char *name)\n{\n\tmodule_assert_mutex();\n\treturn find_module_all(name, strlen(name), false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&module_mutex"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tk->symbol",
            "':'"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\tmutex_lock(&module_mutex);\n\tret = !!find_module(tk->symbol);\n\tmutex_unlock(&module_mutex);\n\t*p = ':';\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_kprobe_within_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "57-63",
    "snippet": "static nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mod->name",
            "name",
            "len"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "42-45",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mod->name"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "878-898",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}"
  },
  {
    "function_name": "trace_kprobe_has_gone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "52-55",
    "snippet": "static nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn !!(kprobe_gone(&tk->rp.kp));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn !!(kprobe_gone(&tk->rp.kp));\n}"
  },
  {
    "function_name": "trace_kprobe_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "47-50",
    "snippet": "static nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\n{\n\treturn tk->rp.kp.offset;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\n{\n\treturn tk->rp.kp.offset;\n}"
  },
  {
    "function_name": "trace_kprobe_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "42-45",
    "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
  },
  {
    "function_name": "trace_kprobe_is_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
    "lines": "37-40",
    "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
  }
]