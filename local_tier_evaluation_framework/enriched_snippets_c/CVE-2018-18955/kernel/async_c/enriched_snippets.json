[
  {
    "function_name": "current_is_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "327-332",
    "snippet": "bool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue_internal.h",
          "lines": "61-66",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nbool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}"
  },
  {
    "function_name": "async_synchronize_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "316-319",
    "snippet": "void async_synchronize_cookie(async_cookie_t cookie)\n{\n\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ASYNC_DOMAIN(async_dfl_domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_synchronize_cookie_domain",
          "args": [
            "cookie",
            "&async_dfl_domain"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_cookie_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "287-306",
          "snippet": "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t uninitialized_var(starttime), delta, endtime;\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\t\tstarttime = ktime_get();\n\t}\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tendtime = ktime_get();\n\t\tdelta = ktime_sub(endtime, starttime);\n\n\t\tpr_debug(\"async_continuing @ %i after %lli usec\\n\",\n\t\t\ttask_pid_nr(current),\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(async_done);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t uninitialized_var(starttime), delta, endtime;\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\t\tstarttime = ktime_get();\n\t}\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tendtime = ktime_get();\n\t\tdelta = ktime_sub(endtime, starttime);\n\n\t\tpr_debug(\"async_continuing @ %i after %lli usec\\n\",\n\t\t\ttask_pid_nr(current),\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic ASYNC_DOMAIN(async_dfl_domain);\n\nvoid async_synchronize_cookie(async_cookie_t cookie)\n{\n\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);\n}"
  },
  {
    "function_name": "async_synchronize_cookie_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "287-306",
    "snippet": "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t uninitialized_var(starttime), delta, endtime;\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\t\tstarttime = ktime_get();\n\t}\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tendtime = ktime_get();\n\t\tdelta = ktime_sub(endtime, starttime);\n\n\t\tpr_debug(\"async_continuing @ %i after %lli usec\\n\",\n\t\t\ttask_pid_nr(current),\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(async_done);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"async_continuing @ %i after %lli usec\\n\"",
            "task_pid_nr(current)",
            "(long long)ktime_to_ns(delta) >> 10"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "delta"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "endtime",
            "starttime"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "async_done",
            "lowest_in_progress(domain) >= cookie"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowest_in_progress",
          "args": [
            "domain"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "lowest_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "85-108",
          "snippet": "static async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
          ],
          "globals_used": [
            "static LIST_HEAD(async_global_pending);",
            "static DEFINE_SPINLOCK(async_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\n\nstatic async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"async_waiting @ %i\\n\"",
            "task_pid_nr(current)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t uninitialized_var(starttime), delta, endtime;\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\t\tstarttime = ktime_get();\n\t}\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tendtime = ktime_get();\n\t\tdelta = ktime_sub(endtime, starttime);\n\n\t\tpr_debug(\"async_continuing @ %i after %lli usec\\n\",\n\t\t\ttask_pid_nr(current),\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n}"
  },
  {
    "function_name": "async_synchronize_full_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "272-275",
    "snippet": "void async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [
      "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_synchronize_cookie_domain",
          "args": [
            "ASYNC_COOKIE_MAX",
            "domain"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_cookie_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "287-306",
          "snippet": "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t uninitialized_var(starttime), delta, endtime;\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\t\tstarttime = ktime_get();\n\t}\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tendtime = ktime_get();\n\t\tdelta = ktime_sub(endtime, starttime);\n\n\t\tpr_debug(\"async_continuing @ %i after %lli usec\\n\",\n\t\t\ttask_pid_nr(current),\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(async_done);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t uninitialized_var(starttime), delta, endtime;\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\t\tstarttime = ktime_get();\n\t}\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tendtime = ktime_get();\n\t\tdelta = ktime_sub(endtime, starttime);\n\n\t\tpr_debug(\"async_continuing @ %i after %lli usec\\n\",\n\t\t\ttask_pid_nr(current),\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nvoid async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}"
  },
  {
    "function_name": "async_unregister_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "256-262",
    "snippet": "void async_unregister_domain(struct async_domain *domain)\n{\n\tspin_lock_irq(&async_lock);\n\tWARN_ON(!domain->registered || !list_empty(&domain->pending));\n\tdomain->registered = 0;\n\tspin_unlock_irq(&async_lock);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(async_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&async_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!domain->registered || !list_empty(&domain->pending)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&domain->pending"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&async_lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DEFINE_SPINLOCK(async_lock);\n\nvoid async_unregister_domain(struct async_domain *domain)\n{\n\tspin_lock_irq(&async_lock);\n\tWARN_ON(!domain->registered || !list_empty(&domain->pending));\n\tdomain->registered = 0;\n\tspin_unlock_irq(&async_lock);\n}"
  },
  {
    "function_name": "async_synchronize_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "241-244",
    "snippet": "void async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_synchronize_full_domain",
          "args": [
            "NULL"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_full_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "272-275",
          "snippet": "void async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nvoid async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nvoid async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}"
  },
  {
    "function_name": "async_schedule_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "229-233",
    "snippet": "async_cookie_t async_schedule_domain(async_func_t func, void *data,\n\t\t\t\t     struct async_domain *domain)\n{\n\treturn __async_schedule(func, data, domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__async_schedule",
          "args": [
            "func",
            "data",
            "domain"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__async_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "152-201",
          "snippet": "static async_cookie_t __async_schedule(async_func_t func, void *data, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work(system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define MAX_WORK\t\t32768"
          ],
          "globals_used": [
            "static async_cookie_t next_cookie = 1;",
            "static LIST_HEAD(async_global_pending);",
            "static DEFINE_SPINLOCK(async_lock);",
            "static atomic_t entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define MAX_WORK\t\t32768\n\nstatic async_cookie_t next_cookie = 1;\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\nstatic atomic_t entry_count;\n\nstatic async_cookie_t __async_schedule(async_func_t func, void *data, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work(system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nasync_cookie_t async_schedule_domain(async_func_t func, void *data,\n\t\t\t\t     struct async_domain *domain)\n{\n\treturn __async_schedule(func, data, domain);\n}"
  },
  {
    "function_name": "async_schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "211-214",
    "snippet": "async_cookie_t async_schedule(async_func_t func, void *data)\n{\n\treturn __async_schedule(func, data, &async_dfl_domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ASYNC_DOMAIN(async_dfl_domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__async_schedule",
          "args": [
            "func",
            "data",
            "&async_dfl_domain"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__async_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "152-201",
          "snippet": "static async_cookie_t __async_schedule(async_func_t func, void *data, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work(system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define MAX_WORK\t\t32768"
          ],
          "globals_used": [
            "static async_cookie_t next_cookie = 1;",
            "static LIST_HEAD(async_global_pending);",
            "static DEFINE_SPINLOCK(async_lock);",
            "static atomic_t entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define MAX_WORK\t\t32768\n\nstatic async_cookie_t next_cookie = 1;\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\nstatic atomic_t entry_count;\n\nstatic async_cookie_t __async_schedule(async_func_t func, void *data, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work(system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic ASYNC_DOMAIN(async_dfl_domain);\n\nasync_cookie_t async_schedule(async_func_t func, void *data)\n{\n\treturn __async_schedule(func, data, &async_dfl_domain);\n}"
  },
  {
    "function_name": "__async_schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "152-201",
    "snippet": "static async_cookie_t __async_schedule(async_func_t func, void *data, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work(system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [
      "#define MAX_WORK\t\t32768"
    ],
    "globals_used": [
      "static async_cookie_t next_cookie = 1;",
      "static LIST_HEAD(async_global_pending);",
      "static DEFINE_SPINLOCK(async_lock);",
      "static atomic_t entry_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_unbound_wq",
            "&entry->work"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry_count"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->global_list",
            "&async_global_pending"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->domain_list",
            "&domain->pending"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&entry->work",
            "async_run_entry_fn"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->global_list"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->domain_list"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "data",
            "newcookie"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "dereference_module_function_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "3964-3968",
          "snippet": "void * __weak dereference_module_function_descriptor(struct module *mod,\n\t\t\t\t\t\t     void *ptr)\n{\n\treturn ptr;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid * __weak dereference_module_function_descriptor(struct module *mod,\n\t\t\t\t\t\t     void *ptr)\n{\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&entry_count"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct async_entry)",
            "GFP_ATOMIC"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define MAX_WORK\t\t32768\n\nstatic async_cookie_t next_cookie = 1;\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\nstatic atomic_t entry_count;\n\nstatic async_cookie_t __async_schedule(async_func_t func, void *data, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work(system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}"
  },
  {
    "function_name": "async_run_entry_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "113-150",
    "snippet": "static void async_run_entry_fn(struct work_struct *work)\n{\n\tstruct async_entry *entry =\n\t\tcontainer_of(work, struct async_entry, work);\n\tunsigned long flags;\n\tktime_t uninitialized_var(calltime), delta, rettime;\n\n\t/* 1) run (and print duration) */\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"calling  %lli_%pF @ %i\\n\",\n\t\t\t(long long)entry->cookie,\n\t\t\tentry->func, task_pid_nr(current));\n\t\tcalltime = ktime_get();\n\t}\n\tentry->func(entry->data, entry->cookie);\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\trettime = ktime_get();\n\t\tdelta = ktime_sub(rettime, calltime);\n\t\tpr_debug(\"initcall %lli_%pF returned 0 after %lld usecs\\n\",\n\t\t\t(long long)entry->cookie,\n\t\t\tentry->func,\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n\n\t/* 2) remove self from the pending queues */\n\tspin_lock_irqsave(&async_lock, flags);\n\tlist_del_init(&entry->domain_list);\n\tlist_del_init(&entry->global_list);\n\n\t/* 3) free the entry */\n\tkfree(entry);\n\tatomic_dec(&entry_count);\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* 4) wake up any waiters */\n\twake_up(&async_done);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(async_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(async_done);",
      "static atomic_t entry_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&async_done"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&entry_count"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->global_list"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->domain_list"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"initcall %lli_%pF returned 0 after %lld usecs\\n\"",
            "(long long)entry->cookie",
            "entry->func",
            "(long long)ktime_to_ns(delta) >> 10"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "delta"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "rettime",
            "calltime"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry->func",
          "args": [
            "entry->data",
            "entry->cookie"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "347-353",
          "snippet": "static struct bpf_func_state *func(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\n\treturn cur->frame[reg->frameno];\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(struct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __mark_reg_not_init(struct bpf_reg_state *reg);\n\nstatic struct bpf_func_state *func(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\n\treturn cur->frame[reg->frameno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"calling  %lli_%pF @ %i\\n\"",
            "(long long)entry->cookie",
            "entry->func",
            "task_pid_nr(current)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structasync_entry",
            "work"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DEFINE_SPINLOCK(async_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\nstatic atomic_t entry_count;\n\nstatic void async_run_entry_fn(struct work_struct *work)\n{\n\tstruct async_entry *entry =\n\t\tcontainer_of(work, struct async_entry, work);\n\tunsigned long flags;\n\tktime_t uninitialized_var(calltime), delta, rettime;\n\n\t/* 1) run (and print duration) */\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\tpr_debug(\"calling  %lli_%pF @ %i\\n\",\n\t\t\t(long long)entry->cookie,\n\t\t\tentry->func, task_pid_nr(current));\n\t\tcalltime = ktime_get();\n\t}\n\tentry->func(entry->data, entry->cookie);\n\tif (initcall_debug && system_state < SYSTEM_RUNNING) {\n\t\trettime = ktime_get();\n\t\tdelta = ktime_sub(rettime, calltime);\n\t\tpr_debug(\"initcall %lli_%pF returned 0 after %lld usecs\\n\",\n\t\t\t(long long)entry->cookie,\n\t\t\tentry->func,\n\t\t\t(long long)ktime_to_ns(delta) >> 10);\n\t}\n\n\t/* 2) remove self from the pending queues */\n\tspin_lock_irqsave(&async_lock, flags);\n\tlist_del_init(&entry->domain_list);\n\tlist_del_init(&entry->global_list);\n\n\t/* 3) free the entry */\n\tkfree(entry);\n\tatomic_dec(&entry_count);\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* 4) wake up any waiters */\n\twake_up(&async_done);\n}"
  },
  {
    "function_name": "lowest_in_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
    "lines": "85-108",
    "snippet": "static async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [
      "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
    ],
    "globals_used": [
      "static LIST_HEAD(async_global_pending);",
      "static DEFINE_SPINLOCK(async_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&async_global_pending",
            "structasync_entry",
            "global_list"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&async_global_pending"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&domain->pending",
            "structasync_entry",
            "domain_list"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\n\nstatic async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}"
  }
]