[
  {
    "function_name": "compat_exit_robust_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
    "lines": "51-119",
    "snippet": "void compat_exit_robust_list(struct task_struct *curr)\n{\n\tstruct compat_robust_list_head __user *head = curr->compat_robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tcompat_uptr_t uentry, next_uentry, upending;\n\tcompat_long_t futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t/*\n\t * Fetch the list head (which was registered earlier, via\n\t * sys_set_robust_list()):\n\t */\n\tif (fetch_robust_entry(&uentry, &entry, &head->list.next, &pi))\n\t\treturn;\n\t/*\n\t * Fetch the relative futex offset:\n\t */\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t/*\n\t * Fetch any possibly pending lock-add first, and handle it\n\t * if it exists:\n\t */\n\tif (fetch_robust_entry(&upending, &pending,\n\t\t\t       &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = NULL;\t/* avoid warning with gcc */\n\twhile (entry != (struct robust_list __user *) &head->list) {\n\t\t/*\n\t\t * Fetch the next entry in the list before calling\n\t\t * handle_futex_death:\n\t\t */\n\t\trc = fetch_robust_entry(&next_uentry, &next_entry,\n\t\t\t(compat_uptr_t __user *)&entry->next, &next_pi);\n\t\t/*\n\t\t * A pending lock might already be on the list, so\n\t\t * dont process it twice:\n\t\t */\n\t\tif (entry != pending) {\n\t\t\tvoid __user *uaddr = futex_uaddr(entry, futex_offset);\n\n\t\t\tif (handle_futex_death(uaddr, curr, pi))\n\t\t\t\treturn;\n\t\t}\n\t\tif (rc)\n\t\t\treturn;\n\t\tuentry = next_uentry;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\t/*\n\t\t * Avoid excessively long or circular lists:\n\t\t */\n\t\tif (!--limit)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\tif (pending) {\n\t\tvoid __user *uaddr = futex_uaddr(pending, futex_offset);\n\n\t\thandle_futex_death(uaddr, curr, pip);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/futex.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_futex_death",
          "args": [
            "uaddr",
            "curr",
            "pip"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "handle_futex_death",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex.c",
          "lines": "3363-3408",
          "snippet": "int handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & FUTEX_TID_MASK) == task_pid_vnr(curr)) {\n\t\t/*\n\t\t * Ok, this dying thread is truly holding a futex\n\t\t * of interest. Set the OWNER_DIED bit atomically\n\t\t * via cmpxchg, and if the value had FUTEX_WAITERS\n\t\t * set, wake up a waiter (if any). (We have to do a\n\t\t * futex_wake() even if OWNER_DIED is already set -\n\t\t * to handle the rare but possible case of recursive\n\t\t * thread-death.) The rest of the cleanup is done in\n\t\t * userspace.\n\t\t */\n\t\tmval = (uval & FUTEX_WAITERS) | FUTEX_OWNER_DIED;\n\t\t/*\n\t\t * We are not holding a lock here, but we want to have\n\t\t * the pagefault_disable/enable() protection because\n\t\t * we want to handle the fault gracefully. If the\n\t\t * access fails we try to fault in the futex with R/W\n\t\t * verification via get_user_pages. get_user() above\n\t\t * does not guarantee R/W access. If that fails we\n\t\t * give up and leave the futex locked.\n\t\t */\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t/*\n\t\t * Wake robust non-PI futexes here. The wakeup of\n\t\t * PI futexes happens in exit_pi_state():\n\t\t */\n\t\tif (!pi && (uval & FUTEX_WAITERS))\n\t\t\tfutex_wake(uaddr, 1, 1, FUTEX_BITSET_MATCH_ANY);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking/rtmutex_common.h\"",
            "#include <asm/futex.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid.h>",
            "#include <linux/magic.h>",
            "#include <linux/export.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/futex.h>",
            "#include <linux/init.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking/rtmutex_common.h\"\n#include <asm/futex.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/freezer.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/ptrace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/magic.h>\n#include <linux/export.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/futex.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\nint handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & FUTEX_TID_MASK) == task_pid_vnr(curr)) {\n\t\t/*\n\t\t * Ok, this dying thread is truly holding a futex\n\t\t * of interest. Set the OWNER_DIED bit atomically\n\t\t * via cmpxchg, and if the value had FUTEX_WAITERS\n\t\t * set, wake up a waiter (if any). (We have to do a\n\t\t * futex_wake() even if OWNER_DIED is already set -\n\t\t * to handle the rare but possible case of recursive\n\t\t * thread-death.) The rest of the cleanup is done in\n\t\t * userspace.\n\t\t */\n\t\tmval = (uval & FUTEX_WAITERS) | FUTEX_OWNER_DIED;\n\t\t/*\n\t\t * We are not holding a lock here, but we want to have\n\t\t * the pagefault_disable/enable() protection because\n\t\t * we want to handle the fault gracefully. If the\n\t\t * access fails we try to fault in the futex with R/W\n\t\t * verification via get_user_pages. get_user() above\n\t\t * does not guarantee R/W access. If that fails we\n\t\t * give up and leave the futex locked.\n\t\t */\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t/*\n\t\t * Wake robust non-PI futexes here. The wakeup of\n\t\t * PI futexes happens in exit_pi_state():\n\t\t */\n\t\tif (!pi && (uval & FUTEX_WAITERS))\n\t\t\tfutex_wake(uaddr, 1, 1, FUTEX_BITSET_MATCH_ANY);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_uaddr",
          "args": [
            "pending",
            "futex_offset"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "futex_uaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
          "lines": "36-43",
          "snippet": "static void __user *futex_uaddr(struct robust_list __user *entry,\n\t\t\t\tcompat_long_t futex_offset)\n{\n\tcompat_uptr_t base = ptr_to_compat(entry);\n\tvoid __user *uaddr = compat_ptr(base + futex_offset);\n\n\treturn uaddr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/futex.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic void __user *futex_uaddr(struct robust_list __user *entry,\n\t\t\t\tcompat_long_t futex_offset)\n{\n\tcompat_uptr_t base = ptr_to_compat(entry);\n\tvoid __user *uaddr = compat_ptr(base + futex_offset);\n\n\treturn uaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_robust_entry",
          "args": [
            "&next_uentry",
            "&next_entry",
            "(compat_uptr_t __user *)&entry->next",
            "&next_pi"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_robust_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
          "lines": "23-34",
          "snippet": "static inline int\nfetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,\n\t\t   compat_uptr_t __user *head, unsigned int *pi)\n{\n\tif (get_user(*uentry, head))\n\t\treturn -EFAULT;\n\n\t*entry = compat_ptr((*uentry) & ~1);\n\t*pi = (unsigned int)(*uentry) & 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/futex.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic inline int\nfetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,\n\t\t   compat_uptr_t __user *head, unsigned int *pi)\n{\n\tif (get_user(*uentry, head))\n\t\treturn -EFAULT;\n\n\t*entry = compat_ptr((*uentry) & ~1);\n\t*pi = (unsigned int)(*uentry) & 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "futex_offset",
            "&head->futex_offset"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nvoid compat_exit_robust_list(struct task_struct *curr)\n{\n\tstruct compat_robust_list_head __user *head = curr->compat_robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tcompat_uptr_t uentry, next_uentry, upending;\n\tcompat_long_t futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t/*\n\t * Fetch the list head (which was registered earlier, via\n\t * sys_set_robust_list()):\n\t */\n\tif (fetch_robust_entry(&uentry, &entry, &head->list.next, &pi))\n\t\treturn;\n\t/*\n\t * Fetch the relative futex offset:\n\t */\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t/*\n\t * Fetch any possibly pending lock-add first, and handle it\n\t * if it exists:\n\t */\n\tif (fetch_robust_entry(&upending, &pending,\n\t\t\t       &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = NULL;\t/* avoid warning with gcc */\n\twhile (entry != (struct robust_list __user *) &head->list) {\n\t\t/*\n\t\t * Fetch the next entry in the list before calling\n\t\t * handle_futex_death:\n\t\t */\n\t\trc = fetch_robust_entry(&next_uentry, &next_entry,\n\t\t\t(compat_uptr_t __user *)&entry->next, &next_pi);\n\t\t/*\n\t\t * A pending lock might already be on the list, so\n\t\t * dont process it twice:\n\t\t */\n\t\tif (entry != pending) {\n\t\t\tvoid __user *uaddr = futex_uaddr(entry, futex_offset);\n\n\t\t\tif (handle_futex_death(uaddr, curr, pi))\n\t\t\t\treturn;\n\t\t}\n\t\tif (rc)\n\t\t\treturn;\n\t\tuentry = next_uentry;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\t/*\n\t\t * Avoid excessively long or circular lists:\n\t\t */\n\t\tif (!--limit)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\tif (pending) {\n\t\tvoid __user *uaddr = futex_uaddr(pending, futex_offset);\n\n\t\thandle_futex_death(uaddr, curr, pip);\n\t}\n}"
  },
  {
    "function_name": "futex_uaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
    "lines": "36-43",
    "snippet": "static void __user *futex_uaddr(struct robust_list __user *entry,\n\t\t\t\tcompat_long_t futex_offset)\n{\n\tcompat_uptr_t base = ptr_to_compat(entry);\n\tvoid __user *uaddr = compat_ptr(base + futex_offset);\n\n\treturn uaddr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/futex.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "base + futex_offset"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "entry"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic void __user *futex_uaddr(struct robust_list __user *entry,\n\t\t\t\tcompat_long_t futex_offset)\n{\n\tcompat_uptr_t base = ptr_to_compat(entry);\n\tvoid __user *uaddr = compat_ptr(base + futex_offset);\n\n\treturn uaddr;\n}"
  },
  {
    "function_name": "fetch_robust_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
    "lines": "23-34",
    "snippet": "static inline int\nfetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,\n\t\t   compat_uptr_t __user *head, unsigned int *pi)\n{\n\tif (get_user(*uentry, head))\n\t\treturn -EFAULT;\n\n\t*entry = compat_ptr((*uentry) & ~1);\n\t*pi = (unsigned int)(*uentry) & 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/futex.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "(*uentry) & ~1"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "*uentry",
            "head"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic inline int\nfetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,\n\t\t   compat_uptr_t __user *head, unsigned int *pi)\n{\n\tif (get_user(*uentry, head))\n\t\treturn -EFAULT;\n\n\t*entry = compat_ptr((*uentry) & ~1);\n\t*pi = (unsigned int)(*uentry) & 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_robust_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
    "lines": "121-134",
    "snippet": "SYSCALL_DEFINE2(set_robust_list,\n\t\tstruct compat_robust_list_head __user *, head,\n\t\tcompat_size_t, len)\n{\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -EINVAL;\n\n\tcurrent->compat_robust_list = head;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/futex.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE2(set_robust_list,\n\t\tstruct compat_robust_list_head __user *, head,\n\t\tcompat_size_t, len)\n{\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -EINVAL;\n\n\tcurrent->compat_robust_list = head;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_robust_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
    "lines": "136-173",
    "snippet": "SYSCALL_DEFINE3(get_robust_list, int, pid,\n\t\t\tcompat_uptr_t __user *, head_ptr,\n\t\t\tcompat_size_t __user *, len_ptr)\n{\n\tstruct compat_robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -EPERM;\n\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto err_unlock;\n\n\thead = p->compat_robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -EFAULT;\n\treturn put_user(ptr_to_compat(head), head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/futex.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(get_robust_list, int, pid,\n\t\t\tcompat_uptr_t __user *, head_ptr,\n\t\t\tcompat_size_t __user *, len_ptr)\n{\n\tstruct compat_robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -ENOSYS;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -EPERM;\n\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto err_unlock;\n\n\thead = p->compat_robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -EFAULT;\n\treturn put_user(ptr_to_compat(head), head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "futex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/futex_compat.c",
    "lines": "175-202",
    "snippet": "SYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct old_timespec32 __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = NULL;\n\tint val2 = 0;\n\tint cmd = op & FUTEX_CMD_MASK;\n\n\tif (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||\n\t\t      cmd == FUTEX_WAIT_BITSET ||\n\t\t      cmd == FUTEX_WAIT_REQUEUE_PI)) {\n\t\tif (compat_get_timespec(&ts, utime))\n\t\t\treturn -EFAULT;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -EINVAL;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == FUTEX_WAIT)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\tif (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||\n\t    cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)\n\t\tval2 = (int) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/futex.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/futex.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct old_timespec32 __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = NULL;\n\tint val2 = 0;\n\tint cmd = op & FUTEX_CMD_MASK;\n\n\tif (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||\n\t\t      cmd == FUTEX_WAIT_BITSET ||\n\t\t      cmd == FUTEX_WAIT_REQUEUE_PI)) {\n\t\tif (compat_get_timespec(&ts, utime))\n\t\t\treturn -EFAULT;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -EINVAL;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == FUTEX_WAIT)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\tif (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||\n\t    cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)\n\t\tval2 = (int) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}"
  }
]