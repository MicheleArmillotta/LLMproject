[
  {
    "function_name": "qstat_hop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "295-295",
    "snippet": "static inline void qstat_hop(int hopcnt)\t\t\t{ }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void qstat_hop(int hopcnt)\t\t\t{ }"
  },
  {
    "function_name": "qstat_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "294-294",
    "snippet": "static inline void qstat_inc(enum qlock_stats stat, bool cond)\t{ }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void qstat_inc(enum qlock_stats stat, bool cond)\t{ }"
  },
  {
    "function_name": "__pv_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "276-287",
    "snippet": "static inline void __pv_wait(u8 *ptr, u8 val)\n{\n\tu64 *pkick_time = this_cpu_ptr(&pv_kick_time);\n\n\t*pkick_time = 0;\n\tpv_wait(ptr, val);\n\tif (*pkick_time) {\n\t\tthis_cpu_add(qstats[qstat_pv_latency_wake],\n\t\t\t     sched_clock() - *pkick_time);\n\t\tqstat_inc(qstat_pv_kick_wake, true);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qstat_inc",
          "args": [
            "qstat_pv_kick_wake",
            "true"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "qstat_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
          "lines": "294-294",
          "snippet": "static inline void qstat_inc(enum qlock_stats stat, bool cond)\t{ }",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void qstat_inc(enum qlock_stats stat, bool cond)\t{ }"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "qstats[qstat_pv_latency_wake]",
            "sched_clock() - *pkick_time"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_wait",
          "args": [
            "ptr",
            "val"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
          "lines": "276-287",
          "snippet": "static inline void __pv_wait(u8 *ptr, u8 val)\n{\n\tu64 *pkick_time = this_cpu_ptr(&pv_kick_time);\n\n\t*pkick_time = 0;\n\tpv_wait(ptr, val);\n\tif (*pkick_time) {\n\t\tthis_cpu_add(qstats[qstat_pv_latency_wake],\n\t\t\t     sched_clock() - *pkick_time);\n\t\tqstat_inc(qstat_pv_kick_wake, true);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&pv_kick_time"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void __pv_wait(u8 *ptr, u8 val)\n{\n\tu64 *pkick_time = this_cpu_ptr(&pv_kick_time);\n\n\t*pkick_time = 0;\n\tpv_wait(ptr, val);\n\tif (*pkick_time) {\n\t\tthis_cpu_add(qstats[qstat_pv_latency_wake],\n\t\t\t     sched_clock() - *pkick_time);\n\t\tqstat_inc(qstat_pv_kick_wake, true);\n\t}\n}"
  },
  {
    "function_name": "__pv_kick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "264-271",
    "snippet": "static inline void __pv_kick(int cpu)\n{\n\tu64 start = sched_clock();\n\n\tper_cpu(pv_kick_time, cpu) = start;\n\tpv_kick(cpu);\n\tthis_cpu_add(qstats[qstat_pv_latency_kick], sched_clock() - start);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "qstats[qstat_pv_latency_kick]",
            "sched_clock() - start"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_kick",
          "args": [
            "cpu"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_kick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
          "lines": "264-271",
          "snippet": "static inline void __pv_kick(int cpu)\n{\n\tu64 start = sched_clock();\n\n\tper_cpu(pv_kick_time, cpu) = start;\n\tpv_kick(cpu);\n\tthis_cpu_add(qstats[qstat_pv_latency_kick], sched_clock() - start);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "pv_kick_time",
            "cpu"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void __pv_kick(int cpu)\n{\n\tu64 start = sched_clock();\n\n\tper_cpu(pv_kick_time, cpu) = start;\n\tpv_kick(cpu);\n\tthis_cpu_add(qstats[qstat_pv_latency_kick], sched_clock() - start);\n}"
  },
  {
    "function_name": "qstat_hop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "256-259",
    "snippet": "static inline void qstat_hop(int hopcnt)\n{\n\tthis_cpu_add(qstats[qstat_pv_hash_hops], hopcnt);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "qstats[qstat_pv_hash_hops]",
            "hopcnt"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void qstat_hop(int hopcnt)\n{\n\tthis_cpu_add(qstats[qstat_pv_hash_hops], hopcnt);\n}"
  },
  {
    "function_name": "qstat_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "247-251",
    "snippet": "static inline void qstat_inc(enum qlock_stats stat, bool cond)\n{\n\tif (cond)\n\t\tthis_cpu_inc(qstats[stat]);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "qstats[stat]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic inline void qstat_inc(enum qlock_stats stat, bool cond)\n{\n\tif (cond)\n\t\tthis_cpu_inc(qstats[stat]);\n}"
  },
  {
    "function_name": "init_qspinlock_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "211-241",
    "snippet": "static int __init init_qspinlock_stat(void)\n{\n\tstruct dentry *d_qstat = debugfs_create_dir(\"qlockstat\", NULL);\n\tint i;\n\n\tif (!d_qstat)\n\t\tgoto out;\n\n\t/*\n\t * Create the debugfs files\n\t *\n\t * As reading from and writing to the stat files can be slow, only\n\t * root is allowed to do the read/write to limit impact to system\n\t * performance.\n\t */\n\tfor (i = 0; i < qstat_num; i++)\n\t\tif (!debugfs_create_file(qstat_names[i], 0400, d_qstat,\n\t\t\t\t\t (void *)(long)i, &fops_qstat))\n\t\t\tgoto fail_undo;\n\n\tif (!debugfs_create_file(qstat_names[qstat_reset_cnts], 0200, d_qstat,\n\t\t\t\t (void *)(long)qstat_reset_cnts, &fops_qstat))\n\t\tgoto fail_undo;\n\n\treturn 0;\nfail_undo:\n\tdebugfs_remove_recursive(d_qstat);\nout:\n\tpr_warn(\"Could not create 'qlockstat' debugfs entries\\n\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create 'qlockstat' debugfs entries\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "d_qstat"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "qstat_names[qstat_reset_cnts]",
            "0200",
            "d_qstat",
            "(void *)(long)qstat_reset_cnts",
            "&fops_qstat"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "qstat_names[i]",
            "0400",
            "d_qstat",
            "(void *)(long)i",
            "&fops_qstat"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"qlockstat\"",
            "NULL"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic int __init init_qspinlock_stat(void)\n{\n\tstruct dentry *d_qstat = debugfs_create_dir(\"qlockstat\", NULL);\n\tint i;\n\n\tif (!d_qstat)\n\t\tgoto out;\n\n\t/*\n\t * Create the debugfs files\n\t *\n\t * As reading from and writing to the stat files can be slow, only\n\t * root is allowed to do the read/write to limit impact to system\n\t * performance.\n\t */\n\tfor (i = 0; i < qstat_num; i++)\n\t\tif (!debugfs_create_file(qstat_names[i], 0400, d_qstat,\n\t\t\t\t\t (void *)(long)i, &fops_qstat))\n\t\t\tgoto fail_undo;\n\n\tif (!debugfs_create_file(qstat_names[qstat_reset_cnts], 0200, d_qstat,\n\t\t\t\t (void *)(long)qstat_reset_cnts, &fops_qstat))\n\t\tgoto fail_undo;\n\n\treturn 0;\nfail_undo:\n\tdebugfs_remove_recursive(d_qstat);\nout:\n\tpr_warn(\"Could not create 'qlockstat' debugfs entries\\n\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "qstat_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "178-197",
    "snippet": "static ssize_t qstat_write(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tint cpu;\n\n\t/*\n\t * Get the counter ID stored in file->f_inode->i_private\n\t */\n\tif ((long)file_inode(file)->i_private != qstat_reset_cnts)\n\t\treturn count;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint i;\n\t\tunsigned long *ptr = per_cpu_ptr(qstats, cpu);\n\n\t\tfor (i = 0 ; i < qstat_num; i++)\n\t\t\tWRITE_ONCE(ptr[i], 0);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ptr[i]",
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "qstats",
            "cpu"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic ssize_t qstat_write(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tint cpu;\n\n\t/*\n\t * Get the counter ID stored in file->f_inode->i_private\n\t */\n\tif ((long)file_inode(file)->i_private != qstat_reset_cnts)\n\t\treturn count;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint i;\n\t\tunsigned long *ptr = per_cpu_ptr(qstats, cpu);\n\n\t\tfor (i = 0 ; i < qstat_num; i++)\n\t\t\tWRITE_ONCE(ptr[i], 0);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "qstat_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_stat.h",
    "lines": "111-169",
    "snippet": "static ssize_t qstat_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tchar buf[64];\n\tint cpu, counter, len;\n\tu64 stat = 0, kicks = 0;\n\n\t/*\n\t * Get the counter ID stored in file->f_inode->i_private\n\t */\n\tcounter = (long)file_inode(file)->i_private;\n\n\tif (counter >= qstat_num)\n\t\treturn -EBADF;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat += per_cpu(qstats[counter], cpu);\n\t\t/*\n\t\t * Need to sum additional counter for some of them\n\t\t */\n\t\tswitch (counter) {\n\n\t\tcase qstat_pv_latency_kick:\n\t\tcase qstat_pv_hash_hops:\n\t\t\tkicks += per_cpu(qstats[qstat_pv_kick_unlock], cpu);\n\t\t\tbreak;\n\n\t\tcase qstat_pv_latency_wake:\n\t\t\tkicks += per_cpu(qstats[qstat_pv_kick_wake], cpu);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (counter == qstat_pv_hash_hops) {\n\t\tu64 frac = 0;\n\n\t\tif (kicks) {\n\t\t\tfrac = 100ULL * do_div(stat, kicks);\n\t\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, kicks);\n\t\t}\n\n\t\t/*\n\t\t * Return a X.XX decimal number\n\t\t */\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu.%02llu\\n\", stat, frac);\n\t} else {\n\t\t/*\n\t\t * Round to the nearest ns\n\t\t */\n\t\tif ((counter == qstat_pv_latency_kick) ||\n\t\t    (counter == qstat_pv_latency_wake)) {\n\t\t\tif (kicks)\n\t\t\t\tstat = DIV_ROUND_CLOSEST_ULL(stat, kicks);\n\t\t}\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu\\n\", stat);\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "buf",
            "len"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf) - 1",
            "\"%llu\\n\"",
            "stat"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "stat",
            "kicks"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf) - 1",
            "\"%llu.%02llu\\n\"",
            "stat",
            "frac"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "frac",
            "kicks"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stat",
            "kicks"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "qstats[qstat_pv_kick_wake]",
            "cpu"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n\nstatic ssize_t qstat_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tchar buf[64];\n\tint cpu, counter, len;\n\tu64 stat = 0, kicks = 0;\n\n\t/*\n\t * Get the counter ID stored in file->f_inode->i_private\n\t */\n\tcounter = (long)file_inode(file)->i_private;\n\n\tif (counter >= qstat_num)\n\t\treturn -EBADF;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat += per_cpu(qstats[counter], cpu);\n\t\t/*\n\t\t * Need to sum additional counter for some of them\n\t\t */\n\t\tswitch (counter) {\n\n\t\tcase qstat_pv_latency_kick:\n\t\tcase qstat_pv_hash_hops:\n\t\t\tkicks += per_cpu(qstats[qstat_pv_kick_unlock], cpu);\n\t\t\tbreak;\n\n\t\tcase qstat_pv_latency_wake:\n\t\t\tkicks += per_cpu(qstats[qstat_pv_kick_wake], cpu);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (counter == qstat_pv_hash_hops) {\n\t\tu64 frac = 0;\n\n\t\tif (kicks) {\n\t\t\tfrac = 100ULL * do_div(stat, kicks);\n\t\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, kicks);\n\t\t}\n\n\t\t/*\n\t\t * Return a X.XX decimal number\n\t\t */\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu.%02llu\\n\", stat, frac);\n\t} else {\n\t\t/*\n\t\t * Round to the nearest ns\n\t\t */\n\t\tif ((counter == qstat_pv_latency_kick) ||\n\t\t    (counter == qstat_pv_latency_wake)) {\n\t\t\tif (kicks)\n\t\t\t\tstat = DIV_ROUND_CLOSEST_ULL(stat, kicks);\n\t\t}\n\t\tlen = snprintf(buf, sizeof(buf) - 1, \"%llu\\n\", stat);\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}"
  }
]