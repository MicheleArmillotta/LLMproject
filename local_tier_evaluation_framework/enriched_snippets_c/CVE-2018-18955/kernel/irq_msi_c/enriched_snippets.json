[
  {
    "function_name": "msi_get_domain_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "520-523",
    "snippet": "struct msi_domain_info *msi_get_domain_info(struct irq_domain *domain)\n{\n\treturn (struct msi_domain_info *)domain->host_data;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstruct msi_domain_info *msi_get_domain_info(struct irq_domain *domain)\n{\n\treturn (struct msi_domain_info *)domain->host_data;\n}"
  },
  {
    "function_name": "msi_domain_free_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "496-511",
    "snippet": "void msi_domain_free_irqs(struct irq_domain *domain, struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\t/*\n\t\t * We might have failed to allocate an MSI early\n\t\t * enough that there is no IRQ associated to this\n\t\t * entry. If that's the case, don't do anything.\n\t\t */\n\t\tif (desc->irq) {\n\t\t\tirq_domain_free_irqs(desc->irq, desc->nvec_used);\n\t\t\tdesc->irq = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs",
          "args": [
            "desc->irq",
            "desc->nvec_used"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1510-1527",
          "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nvoid msi_domain_free_irqs(struct irq_domain *domain, struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\t/*\n\t\t * We might have failed to allocate an MSI early\n\t\t * enough that there is no IRQ associated to this\n\t\t * entry. If that's the case, don't do anything.\n\t\t */\n\t\tif (desc->irq) {\n\t\t\tirq_domain_free_irqs(desc->irq, desc->nvec_used);\n\t\t\tdesc->irq = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "msi_domain_alloc_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "399-488",
    "snippet": "int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t  int nvec)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tstruct irq_data *irq_data;\n\tstruct msi_desc *desc;\n\tmsi_alloc_info_t arg;\n\tint i, ret, virq;\n\tbool can_reserve;\n\n\tret = msi_domain_prepare_irqs(domain, dev, nvec, &arg);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\tops->set_desc(&arg, desc);\n\n\t\tvirq = __irq_domain_alloc_irqs(domain, -1, desc->nvec_used,\n\t\t\t\t\t       dev_to_node(dev), &arg, false,\n\t\t\t\t\t       desc->affinity);\n\t\tif (virq < 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tif (ops->handle_error)\n\t\t\t\tret = ops->handle_error(domain, desc, ret);\n\t\t\tif (ops->msi_finish)\n\t\t\t\tops->msi_finish(&arg, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < desc->nvec_used; i++) {\n\t\t\tirq_set_msi_desc_off(virq, i, desc);\n\t\t\tirq_debugfs_copy_devname(virq + i, dev);\n\t\t}\n\t}\n\n\tif (ops->msi_finish)\n\t\tops->msi_finish(&arg, 0);\n\n\tcan_reserve = msi_check_reservation_mode(domain, info, dev);\n\n\tfor_each_msi_entry(desc, dev) {\n\t\tvirq = desc->irq;\n\t\tif (desc->nvec_used == 1)\n\t\t\tdev_dbg(dev, \"irq %d for MSI\\n\", virq);\n\t\telse\n\t\t\tdev_dbg(dev, \"irq [%d-%d] for MSI\\n\",\n\t\t\t\tvirq, virq + desc->nvec_used - 1);\n\t\t/*\n\t\t * This flag is set by the PCI layer as we need to activate\n\t\t * the MSI entries before the PCI layer enables MSI in the\n\t\t * card. Otherwise the card latches a random msi message.\n\t\t */\n\t\tif (!(info->flags & MSI_FLAG_ACTIVATE_EARLY))\n\t\t\tcontinue;\n\n\t\tirq_data = irq_domain_get_irq_data(domain, desc->irq);\n\t\tif (!can_reserve)\n\t\t\tirqd_clr_can_reserve(irq_data);\n\t\tret = irq_domain_activate_irq(irq_data, can_reserve);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * If these interrupts use reservation mode, clear the activated bit\n\t * so request_irq() will assign the final vector.\n\t */\n\tif (can_reserve) {\n\t\tfor_each_msi_entry(desc, dev) {\n\t\t\tirq_data = irq_domain_get_irq_data(domain, desc->irq);\n\t\t\tirqd_clr_activated(irq_data);\n\t\t}\n\t}\n\treturn 0;\n\ncleanup:\n\tfor_each_msi_entry(desc, dev) {\n\t\tstruct irq_data *irqd;\n\n\t\tif (desc->irq == virq)\n\t\t\tbreak;\n\n\t\tirqd = irq_domain_get_irq_data(domain, desc->irq);\n\t\tif (irqd_is_activated(irqd))\n\t\t\tirq_domain_deactivate_irq(irqd);\n\t}\n\tmsi_domain_free_irqs(domain, dev);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msi_domain_free_irqs",
          "args": [
            "domain",
            "dev"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "msi_domain_free_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "496-511",
          "snippet": "void msi_domain_free_irqs(struct irq_domain *domain, struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\t/*\n\t\t * We might have failed to allocate an MSI early\n\t\t * enough that there is no IRQ associated to this\n\t\t * entry. If that's the case, don't do anything.\n\t\t */\n\t\tif (desc->irq) {\n\t\t\tirq_domain_free_irqs(desc->irq, desc->nvec_used);\n\t\t\tdesc->irq = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nvoid msi_domain_free_irqs(struct irq_domain *domain, struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\t/*\n\t\t * We might have failed to allocate an MSI early\n\t\t * enough that there is no IRQ associated to this\n\t\t * entry. If that's the case, don't do anything.\n\t\t */\n\t\tif (desc->irq) {\n\t\t\tirq_domain_free_irqs(desc->irq, desc->nvec_used);\n\t\t\tdesc->irq = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_deactivate_irq",
          "args": [
            "irqd"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_deactivate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "448-451",
          "snippet": "static inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "irqd"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "desc->irq"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1662-1668",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_clr_activated",
          "args": [
            "irq_data"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_activate_irq",
          "args": [
            "irq_data",
            "can_reserve"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_activate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "443-447",
          "snippet": "static inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clr_can_reserve",
          "args": [
            "irq_data"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "dev",
            "\"irq [%d-%d] for MSI\\n\"",
            "virq",
            "virq + desc->nvec_used - 1"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "dev",
            "\"irq %d for MSI\\n\"",
            "virq"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msi_check_reservation_mode",
          "args": [
            "domain",
            "info",
            "dev"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "msi_check_reservation_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "367-388",
          "snippet": "static bool msi_check_reservation_mode(struct irq_domain *domain,\n\t\t\t\t       struct msi_domain_info *info,\n\t\t\t\t       struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tif (domain->bus_token != DOMAIN_BUS_PCI_MSI)\n\t\treturn false;\n\n\tif (!(info->flags & MSI_FLAG_MUST_REACTIVATE))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI) && pci_msi_ignore_mask)\n\t\treturn false;\n\n\t/*\n\t * Checking the first MSI descriptor is sufficient. MSIX supports\n\t * masking and MSI does so when the maskbit is set.\n\t */\n\tdesc = first_msi_entry(dev);\n\treturn desc->msi_attrib.is_msix || desc->msi_attrib.maskbit;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic bool msi_check_reservation_mode(struct irq_domain *domain,\n\t\t\t\t       struct msi_domain_info *info,\n\t\t\t\t       struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tif (domain->bus_token != DOMAIN_BUS_PCI_MSI)\n\t\treturn false;\n\n\tif (!(info->flags & MSI_FLAG_MUST_REACTIVATE))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI) && pci_msi_ignore_mask)\n\t\treturn false;\n\n\t/*\n\t * Checking the first MSI descriptor is sufficient. MSIX supports\n\t * masking and MSI does so when the maskbit is set.\n\t */\n\tdesc = first_msi_entry(dev);\n\treturn desc->msi_attrib.is_msix || desc->msi_attrib.maskbit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->msi_finish",
          "args": [
            "&arg",
            "0"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_debugfs_copy_devname",
          "args": [
            "virq + i",
            "dev"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "irq_debugfs_copy_devname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "478-480",
          "snippet": "static inline void irq_debugfs_copy_devname(int irq, struct device *dev)\n{\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "extern int irq_select_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nextern int irq_select_affinity_usr(unsigned int irq);\n\nstatic inline void irq_debugfs_copy_devname(int irq, struct device *dev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_msi_desc_off",
          "args": [
            "virq",
            "i",
            "desc"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_msi_desc_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "111-124",
          "snippet": "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->msi_finish",
          "args": [
            "&arg",
            "ret"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->handle_error",
          "args": [
            "domain",
            "desc",
            "ret"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_alloc_irqs",
          "args": [
            "domain",
            "-1",
            "desc->nvec_used",
            "dev_to_node(dev)",
            "&arg",
            "false",
            "desc->affinity"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_alloc_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1282-1334",
          "snippet": "int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct cpumask *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct cpumask *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_desc",
          "args": [
            "&arg",
            "desc"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msi_domain_prepare_irqs",
          "args": [
            "domain",
            "dev",
            "nvec",
            "&arg"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "msi_domain_prepare_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "301-313",
          "snippet": "int msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tint ret;\n\n\tret = ops->msi_check(domain, info, dev);\n\tif (ret == 0)\n\t\tret = ops->msi_prepare(domain, dev, nvec, arg);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nint msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tint ret;\n\n\tret = ops->msi_check(domain, info, dev);\n\tif (ret == 0)\n\t\tret = ops->msi_prepare(domain, dev, nvec, arg);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nint msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t  int nvec)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tstruct irq_data *irq_data;\n\tstruct msi_desc *desc;\n\tmsi_alloc_info_t arg;\n\tint i, ret, virq;\n\tbool can_reserve;\n\n\tret = msi_domain_prepare_irqs(domain, dev, nvec, &arg);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\tops->set_desc(&arg, desc);\n\n\t\tvirq = __irq_domain_alloc_irqs(domain, -1, desc->nvec_used,\n\t\t\t\t\t       dev_to_node(dev), &arg, false,\n\t\t\t\t\t       desc->affinity);\n\t\tif (virq < 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tif (ops->handle_error)\n\t\t\t\tret = ops->handle_error(domain, desc, ret);\n\t\t\tif (ops->msi_finish)\n\t\t\t\tops->msi_finish(&arg, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < desc->nvec_used; i++) {\n\t\t\tirq_set_msi_desc_off(virq, i, desc);\n\t\t\tirq_debugfs_copy_devname(virq + i, dev);\n\t\t}\n\t}\n\n\tif (ops->msi_finish)\n\t\tops->msi_finish(&arg, 0);\n\n\tcan_reserve = msi_check_reservation_mode(domain, info, dev);\n\n\tfor_each_msi_entry(desc, dev) {\n\t\tvirq = desc->irq;\n\t\tif (desc->nvec_used == 1)\n\t\t\tdev_dbg(dev, \"irq %d for MSI\\n\", virq);\n\t\telse\n\t\t\tdev_dbg(dev, \"irq [%d-%d] for MSI\\n\",\n\t\t\t\tvirq, virq + desc->nvec_used - 1);\n\t\t/*\n\t\t * This flag is set by the PCI layer as we need to activate\n\t\t * the MSI entries before the PCI layer enables MSI in the\n\t\t * card. Otherwise the card latches a random msi message.\n\t\t */\n\t\tif (!(info->flags & MSI_FLAG_ACTIVATE_EARLY))\n\t\t\tcontinue;\n\n\t\tirq_data = irq_domain_get_irq_data(domain, desc->irq);\n\t\tif (!can_reserve)\n\t\t\tirqd_clr_can_reserve(irq_data);\n\t\tret = irq_domain_activate_irq(irq_data, can_reserve);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * If these interrupts use reservation mode, clear the activated bit\n\t * so request_irq() will assign the final vector.\n\t */\n\tif (can_reserve) {\n\t\tfor_each_msi_entry(desc, dev) {\n\t\t\tirq_data = irq_domain_get_irq_data(domain, desc->irq);\n\t\t\tirqd_clr_activated(irq_data);\n\t\t}\n\t}\n\treturn 0;\n\ncleanup:\n\tfor_each_msi_entry(desc, dev) {\n\t\tstruct irq_data *irqd;\n\n\t\tif (desc->irq == virq)\n\t\t\tbreak;\n\n\t\tirqd = irq_domain_get_irq_data(domain, desc->irq);\n\t\tif (irqd_is_activated(irqd))\n\t\t\tirq_domain_deactivate_irq(irqd);\n\t}\n\tmsi_domain_free_irqs(domain, dev);\n\treturn ret;\n}"
  },
  {
    "function_name": "msi_check_reservation_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "367-388",
    "snippet": "static bool msi_check_reservation_mode(struct irq_domain *domain,\n\t\t\t\t       struct msi_domain_info *info,\n\t\t\t\t       struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tif (domain->bus_token != DOMAIN_BUS_PCI_MSI)\n\t\treturn false;\n\n\tif (!(info->flags & MSI_FLAG_MUST_REACTIVATE))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI) && pci_msi_ignore_mask)\n\t\treturn false;\n\n\t/*\n\t * Checking the first MSI descriptor is sufficient. MSIX supports\n\t * masking and MSI does so when the maskbit is set.\n\t */\n\tdesc = first_msi_entry(dev);\n\treturn desc->msi_attrib.is_msix || desc->msi_attrib.maskbit;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_msi_entry",
          "args": [
            "dev"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PCI_MSI"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic bool msi_check_reservation_mode(struct irq_domain *domain,\n\t\t\t\t       struct msi_domain_info *info,\n\t\t\t\t       struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tif (domain->bus_token != DOMAIN_BUS_PCI_MSI)\n\t\treturn false;\n\n\tif (!(info->flags & MSI_FLAG_MUST_REACTIVATE))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI) && pci_msi_ignore_mask)\n\t\treturn false;\n\n\t/*\n\t * Checking the first MSI descriptor is sufficient. MSIX supports\n\t * masking and MSI does so when the maskbit is set.\n\t */\n\tdesc = first_msi_entry(dev);\n\treturn desc->msi_attrib.is_msix || desc->msi_attrib.maskbit;\n}"
  },
  {
    "function_name": "msi_domain_populate_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "315-354",
    "snippet": "int msi_domain_populate_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t     int virq, int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tstruct msi_desc *desc;\n\tint ret = 0;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\t/* Don't even try the multi-MSI brain damage. */\n\t\tif (WARN_ON(!desc->irq || desc->nvec_used != 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(desc->irq >= virq && desc->irq < (virq + nvec)))\n\t\t\tcontinue;\n\n\t\tops->set_desc(arg, desc);\n\t\t/* Assumes the domain mutex is held! */\n\t\tret = irq_domain_alloc_irqs_hierarchy(domain, desc->irq, 1,\n\t\t\t\t\t\t      arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tirq_set_msi_desc_off(desc->irq, 0, desc);\n\t}\n\n\tif (ret) {\n\t\t/* Mop up the damage */\n\t\tfor_each_msi_entry(desc, dev) {\n\t\t\tif (!(desc->irq >= virq && desc->irq < (virq + nvec)))\n\t\t\t\tcontinue;\n\n\t\t\tirq_domain_free_irqs_common(domain, desc->irq, 1);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_common",
          "args": [
            "domain",
            "desc->irq",
            "1"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1212-1224",
          "snippet": "void irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_msi_desc_off",
          "args": [
            "desc->irq",
            "0",
            "desc"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_msi_desc_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "111-124",
          "snippet": "int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain",
            "desc->irq",
            "1",
            "arg"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1253-1258",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->set_desc",
          "args": [
            "arg",
            "desc"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!desc->irq || desc->nvec_used != 1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_msi_entry",
          "args": [
            "desc",
            "dev"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nint msi_domain_populate_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t     int virq, int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tstruct msi_desc *desc;\n\tint ret = 0;\n\n\tfor_each_msi_entry(desc, dev) {\n\t\t/* Don't even try the multi-MSI brain damage. */\n\t\tif (WARN_ON(!desc->irq || desc->nvec_used != 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(desc->irq >= virq && desc->irq < (virq + nvec)))\n\t\t\tcontinue;\n\n\t\tops->set_desc(arg, desc);\n\t\t/* Assumes the domain mutex is held! */\n\t\tret = irq_domain_alloc_irqs_hierarchy(domain, desc->irq, 1,\n\t\t\t\t\t\t      arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tirq_set_msi_desc_off(desc->irq, 0, desc);\n\t}\n\n\tif (ret) {\n\t\t/* Mop up the damage */\n\t\tfor_each_msi_entry(desc, dev) {\n\t\t\tif (!(desc->irq >= virq && desc->irq < (virq + nvec)))\n\t\t\t\tcontinue;\n\n\t\t\tirq_domain_free_irqs_common(domain, desc->irq, 1);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "msi_domain_prepare_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "301-313",
    "snippet": "int msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tint ret;\n\n\tret = ops->msi_check(domain, info, dev);\n\tif (ret == 0)\n\t\tret = ops->msi_prepare(domain, dev, nvec, arg);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->msi_prepare",
          "args": [
            "domain",
            "dev",
            "nvec",
            "arg"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->msi_check",
          "args": [
            "domain",
            "info",
            "dev"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nint msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tint ret;\n\n\tret = ops->msi_check(domain, info, dev);\n\tif (ret == 0)\n\t\tret = ops->msi_prepare(domain, dev, nvec, arg);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "msi_create_irq_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "281-299",
    "snippet": "struct irq_domain *msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t struct msi_domain_info *info,\n\t\t\t\t\t struct irq_domain *parent)\n{\n\tstruct irq_domain *domain;\n\n\tif (info->flags & MSI_FLAG_USE_DEF_DOM_OPS)\n\t\tmsi_domain_update_dom_ops(info);\n\tif (info->flags & MSI_FLAG_USE_DEF_CHIP_OPS)\n\t\tmsi_domain_update_chip_ops(info);\n\n\tdomain = irq_domain_create_hierarchy(parent, IRQ_DOMAIN_FLAG_MSI, 0,\n\t\t\t\t\t     fwnode, &msi_domain_ops, info);\n\n\tif (domain && !domain->name && info->chip)\n\t\tdomain->name = info->chip->name;\n\n\treturn domain;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_create_hierarchy",
          "args": [
            "parent",
            "IRQ_DOMAIN_FLAG_MSI",
            "0",
            "fwnode",
            "&msi_domain_ops",
            "info"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_create_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1010-1029",
          "snippet": "struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_create_linear(fwnode, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_create_tree(fwnode, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_create_linear(fwnode, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_create_tree(fwnode, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msi_domain_update_chip_ops",
          "args": [
            "info"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "msi_domain_update_chip_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "266-273",
          "snippet": "static void msi_domain_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip || !chip->irq_mask || !chip->irq_unmask);\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_domain_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip || !chip->irq_mask || !chip->irq_unmask);\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msi_domain_update_dom_ops",
          "args": [
            "info"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "msi_domain_update_dom_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "245-264",
          "snippet": "static void msi_domain_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (ops == NULL) {\n\t\tinfo->ops = &msi_domain_ops_default;\n\t\treturn;\n\t}\n\n\tif (ops->get_hwirq == NULL)\n\t\tops->get_hwirq = msi_domain_ops_default.get_hwirq;\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = msi_domain_ops_default.msi_init;\n\tif (ops->msi_check == NULL)\n\t\tops->msi_check = msi_domain_ops_default.msi_check;\n\tif (ops->msi_prepare == NULL)\n\t\tops->msi_prepare = msi_domain_ops_default.msi_prepare;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = msi_domain_ops_default.set_desc;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_domain_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (ops == NULL) {\n\t\tinfo->ops = &msi_domain_ops_default;\n\t\treturn;\n\t}\n\n\tif (ops->get_hwirq == NULL)\n\t\tops->get_hwirq = msi_domain_ops_default.get_hwirq;\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = msi_domain_ops_default.msi_init;\n\tif (ops->msi_check == NULL)\n\t\tops->msi_check = msi_domain_ops_default.msi_check;\n\tif (ops->msi_prepare == NULL)\n\t\tops->msi_prepare = msi_domain_ops_default.msi_prepare;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = msi_domain_ops_default.set_desc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstruct irq_domain *msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t struct msi_domain_info *info,\n\t\t\t\t\t struct irq_domain *parent)\n{\n\tstruct irq_domain *domain;\n\n\tif (info->flags & MSI_FLAG_USE_DEF_DOM_OPS)\n\t\tmsi_domain_update_dom_ops(info);\n\tif (info->flags & MSI_FLAG_USE_DEF_CHIP_OPS)\n\t\tmsi_domain_update_chip_ops(info);\n\n\tdomain = irq_domain_create_hierarchy(parent, IRQ_DOMAIN_FLAG_MSI, 0,\n\t\t\t\t\t     fwnode, &msi_domain_ops, info);\n\n\tif (domain && !domain->name && info->chip)\n\t\tdomain->name = info->chip->name;\n\n\treturn domain;\n}"
  },
  {
    "function_name": "msi_domain_update_chip_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "266-273",
    "snippet": "static void msi_domain_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip || !chip->irq_mask || !chip->irq_unmask);\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!chip || !chip->irq_mask || !chip->irq_unmask"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_domain_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip || !chip->irq_mask || !chip->irq_unmask);\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n}"
  },
  {
    "function_name": "msi_domain_update_dom_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "245-264",
    "snippet": "static void msi_domain_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (ops == NULL) {\n\t\tinfo->ops = &msi_domain_ops_default;\n\t\treturn;\n\t}\n\n\tif (ops->get_hwirq == NULL)\n\t\tops->get_hwirq = msi_domain_ops_default.get_hwirq;\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = msi_domain_ops_default.msi_init;\n\tif (ops->msi_check == NULL)\n\t\tops->msi_check = msi_domain_ops_default.msi_check;\n\tif (ops->msi_prepare == NULL)\n\t\tops->msi_prepare = msi_domain_ops_default.msi_prepare;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = msi_domain_ops_default.set_desc;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_domain_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (ops == NULL) {\n\t\tinfo->ops = &msi_domain_ops_default;\n\t\treturn;\n\t}\n\n\tif (ops->get_hwirq == NULL)\n\t\tops->get_hwirq = msi_domain_ops_default.get_hwirq;\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = msi_domain_ops_default.msi_init;\n\tif (ops->msi_check == NULL)\n\t\tops->msi_check = msi_domain_ops_default.msi_check;\n\tif (ops->msi_prepare == NULL)\n\t\tops->msi_prepare = msi_domain_ops_default.msi_prepare;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = msi_domain_ops_default.set_desc;\n}"
  },
  {
    "function_name": "msi_domain_ops_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "230-235",
    "snippet": "static int msi_domain_ops_check(struct irq_domain *domain,\n\t\t\t\tstruct msi_domain_info *info,\n\t\t\t\tstruct device *dev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic int msi_domain_ops_check(struct irq_domain *domain,\n\t\t\t\tstruct msi_domain_info *info,\n\t\t\t\tstruct device *dev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "msi_domain_ops_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "215-228",
    "snippet": "static int msi_domain_ops_init(struct irq_domain *domain,\n\t\t\t       struct msi_domain_info *info,\n\t\t\t       unsigned int virq, irq_hw_number_t hwirq,\n\t\t\t       msi_alloc_info_t *arg)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, info->chip,\n\t\t\t\t      info->chip_data);\n\tif (info->handler && info->handler_name) {\n\t\t__irq_set_handler(virq, info->handler, 0, info->handler_name);\n\t\tif (info->handler_data)\n\t\t\tirq_set_handler_data(virq, info->handler_data);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_handler_data",
          "args": [
            "virq",
            "info->handler_data"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_set_handler",
          "args": [
            "virq",
            "info->handler",
            "0",
            "info->handler_name"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "981-993",
          "snippet": "void\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_hwirq_and_chip",
          "args": [
            "domain",
            "virq",
            "hwirq",
            "info->chip",
            "info->chip_data"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_hwirq_and_chip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1155-1169",
          "snippet": "int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic int msi_domain_ops_init(struct irq_domain *domain,\n\t\t\t       struct msi_domain_info *info,\n\t\t\t       unsigned int virq, irq_hw_number_t hwirq,\n\t\t\t       msi_alloc_info_t *arg)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, info->chip,\n\t\t\t\t      info->chip_data);\n\tif (info->handler && info->handler_name) {\n\t\t__irq_set_handler(virq, info->handler, 0, info->handler_name);\n\t\tif (info->handler_data)\n\t\t\tirq_set_handler_data(virq, info->handler_data);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "msi_domain_ops_set_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "204-208",
    "snippet": "static void msi_domain_ops_set_desc(msi_alloc_info_t *arg,\n\t\t\t\t    struct msi_desc *desc)\n{\n\targ->desc = desc;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define msi_domain_ops_set_desc\t\tNULL"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\n#define msi_domain_ops_set_desc\t\tNULL\n\nstatic void msi_domain_ops_set_desc(msi_alloc_info_t *arg,\n\t\t\t\t    struct msi_desc *desc)\n{\n\targ->desc = desc;\n}"
  },
  {
    "function_name": "msi_domain_ops_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "197-202",
    "snippet": "static int msi_domain_ops_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t\t  int nvec, msi_alloc_info_t *arg)\n{\n\tmemset(arg, 0, sizeof(*arg));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define msi_domain_ops_prepare\t\tNULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "arg",
            "0",
            "sizeof(*arg)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\n#define msi_domain_ops_prepare\t\tNULL\n\nstatic int msi_domain_ops_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t\t  int nvec, msi_alloc_info_t *arg)\n{\n\tmemset(arg, 0, sizeof(*arg));\n\treturn 0;\n}"
  },
  {
    "function_name": "msi_domain_ops_get_hwirq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "191-195",
    "snippet": "static irq_hw_number_t msi_domain_ops_get_hwirq(struct msi_domain_info *info,\n\t\t\t\t\t\tmsi_alloc_info_t *arg)\n{\n\treturn arg->hwirq;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define msi_domain_ops_get_hwirq\tNULL"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\n#define msi_domain_ops_get_hwirq\tNULL\n\nstatic irq_hw_number_t msi_domain_ops_get_hwirq(struct msi_domain_info *info,\n\t\t\t\t\t\tmsi_alloc_info_t *arg)\n{\n\treturn arg->hwirq;\n}"
  },
  {
    "function_name": "msi_domain_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "170-181",
    "snippet": "static void msi_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tint i;\n\n\tif (info->ops->msi_free) {\n\t\tfor (i = 0; i < nr_irqs; i++)\n\t\t\tinfo->ops->msi_free(domain, info, virq + i);\n\t}\n\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_top",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1233-1243",
          "snippet": "void irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "info->ops->msi_free",
          "args": [
            "domain",
            "info",
            "virq + i"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tint i;\n\n\tif (info->ops->msi_free) {\n\t\tfor (i = 0; i < nr_irqs; i++)\n\t\t\tinfo->ops->msi_free(domain, info, virq + i);\n\t}\n\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n}"
  },
  {
    "function_name": "msi_domain_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "138-168",
    "snippet": "static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tirq_hw_number_t hwirq = ops->get_hwirq(info, arg);\n\tint i, ret;\n\n\tif (irq_find_mapping(domain, hwirq) > 0)\n\t\treturn -EEXIST;\n\n\tif (domain->parent) {\n\t\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = ops->msi_init(domain, info, virq + i, hwirq + i, arg);\n\t\tif (ret < 0) {\n\t\t\tif (ops->msi_free) {\n\t\t\t\tfor (i--; i > 0; i--)\n\t\t\t\t\tops->msi_free(domain, info, virq + i);\n\t\t\t}\n\t\t\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_top",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1233-1243",
          "snippet": "void irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->msi_free",
          "args": [
            "domain",
            "info",
            "virq + i"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->msi_init",
          "args": [
            "domain",
            "info",
            "virq + i",
            "hwirq + i",
            "arg"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_parent",
          "args": [
            "domain",
            "virq",
            "nr_irqs",
            "arg"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1538-1547",
          "snippet": "int irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_find_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "irq_find_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "874-899",
          "snippet": "unsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_hwirq",
          "args": [
            "info",
            "arg"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tirq_hw_number_t hwirq = ops->get_hwirq(info, arg);\n\tint i, ret;\n\n\tif (irq_find_mapping(domain, hwirq) > 0)\n\t\treturn -EEXIST;\n\n\tif (domain->parent) {\n\t\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = ops->msi_init(domain, info, virq + i, hwirq + i, arg);\n\t\tif (ret < 0) {\n\t\t\tif (ops->msi_free) {\n\t\t\t\tfor (i--; i > 0; i--)\n\t\t\t\t\tops->msi_free(domain, info, virq + i);\n\t\t\t}\n\t\t\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "msi_domain_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "129-136",
    "snippet": "static void msi_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t  struct irq_data *irq_data)\n{\n\tstruct msi_msg msg[2];\n\n\tmemset(msg, 0, sizeof(msg));\n\tirq_chip_write_msi_msg(irq_data, msg);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_chip_write_msi_msg",
          "args": [
            "irq_data",
            "msg"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_write_msi_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "73-77",
          "snippet": "static inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t  struct irq_data *irq_data)\n{\n\tstruct msi_msg msg[2];\n\n\tmemset(msg, 0, sizeof(msg));\n\tirq_chip_write_msi_msg(irq_data, msg);\n}"
  },
  {
    "function_name": "msi_domain_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "118-127",
    "snippet": "static int msi_domain_activate(struct irq_domain *domain,\n\t\t\t       struct irq_data *irq_data, bool early)\n{\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\n\tBUG_ON(irq_chip_compose_msi_msg(irq_data, msg));\n\tmsi_check_level(irq_data->domain, msg);\n\tirq_chip_write_msi_msg(irq_data, msg);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_chip_write_msi_msg",
          "args": [
            "irq_data",
            "msg"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_write_msi_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "73-77",
          "snippet": "static inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msi_check_level",
          "args": [
            "irq_data->domain",
            "msg"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "msi_check_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "79-90",
          "snippet": "static void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t/*\n\t * If the MSI provider has messed with the second message and\n\t * not advertized that it is level-capable, signal the breakage.\n\t */\n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t/*\n\t * If the MSI provider has messed with the second message and\n\t * not advertized that it is level-capable, signal the breakage.\n\t */\n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq_chip_compose_msi_msg(irq_data, msg)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_chip_compose_msi_msg",
          "args": [
            "irq_data",
            "msg"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_compose_msi_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "1395-1410",
          "snippet": "int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos = NULL;\n\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tfor (; data; data = data->parent_data)\n#endif\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos = NULL;\n\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tfor (; data; data = data->parent_data)\n#endif\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic int msi_domain_activate(struct irq_domain *domain,\n\t\t\t       struct irq_data *irq_data, bool early)\n{\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\n\tBUG_ON(irq_chip_compose_msi_msg(irq_data, msg));\n\tmsi_check_level(irq_data->domain, msg);\n\tirq_chip_write_msi_msg(irq_data, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "msi_domain_set_affinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "101-116",
    "snippet": "int msi_domain_set_affinity(struct irq_data *irq_data,\n\t\t\t    const struct cpumask *mask, bool force)\n{\n\tstruct irq_data *parent = irq_data->parent_data;\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret >= 0 && ret != IRQ_SET_MASK_OK_DONE) {\n\t\tBUG_ON(irq_chip_compose_msi_msg(irq_data, msg));\n\t\tmsi_check_level(irq_data->domain, msg);\n\t\tirq_chip_write_msi_msg(irq_data, msg);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_chip_write_msi_msg",
          "args": [
            "irq_data",
            "msg"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_write_msi_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "73-77",
          "snippet": "static inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msi_check_level",
          "args": [
            "irq_data->domain",
            "msg"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "msi_check_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "79-90",
          "snippet": "static void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t/*\n\t * If the MSI provider has messed with the second message and\n\t * not advertized that it is level-capable, signal the breakage.\n\t */\n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t/*\n\t * If the MSI provider has messed with the second message and\n\t * not advertized that it is level-capable, signal the breakage.\n\t */\n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq_chip_compose_msi_msg(irq_data, msg)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_chip_compose_msi_msg",
          "args": [
            "irq_data",
            "msg"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_compose_msi_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "1395-1410",
          "snippet": "int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos = NULL;\n\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tfor (; data; data = data->parent_data)\n#endif\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos = NULL;\n\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tfor (; data; data = data->parent_data)\n#endif\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent->chip->irq_set_affinity",
          "args": [
            "parent",
            "mask",
            "force"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nint msi_domain_set_affinity(struct irq_data *irq_data,\n\t\t\t    const struct cpumask *mask, bool force)\n{\n\tstruct irq_data *parent = irq_data->parent_data;\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret >= 0 && ret != IRQ_SET_MASK_OK_DONE) {\n\t\tBUG_ON(irq_chip_compose_msi_msg(irq_data, msg));\n\t\tmsi_check_level(irq_data->domain, msg);\n\t\tirq_chip_write_msi_msg(irq_data, msg);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "msi_check_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "79-90",
    "snippet": "static void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t/*\n\t * If the MSI provider has messed with the second message and\n\t * not advertized that it is level-capable, signal the breakage.\n\t */\n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t/*\n\t * If the MSI provider has messed with the second message and\n\t * not advertized that it is level-capable, signal the breakage.\n\t */\n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}"
  },
  {
    "function_name": "irq_chip_write_msi_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "73-77",
    "snippet": "static inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->chip->irq_write_msi_msg",
          "args": [
            "data",
            "msg"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstatic inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}"
  },
  {
    "function_name": "get_cached_msi_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "64-69",
    "snippet": "void get_cached_msi_msg(unsigned int irq, struct msi_msg *msg)\n{\n\tstruct msi_desc *entry = irq_get_msi_desc(irq);\n\n\t__get_cached_msi_msg(entry, msg);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_cached_msi_msg",
          "args": [
            "entry",
            "msg"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cached_msi_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
          "lines": "59-62",
          "snippet": "void __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg)\n{\n\t*msg = entry->msg;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/slab.h>",
            "#include <linux/msi.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irq.h>",
            "#include <linux/device.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nvoid __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg)\n{\n\t*msg = entry->msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_msi_desc",
          "args": [
            "irq"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nvoid get_cached_msi_msg(unsigned int irq, struct msi_msg *msg)\n{\n\tstruct msi_desc *entry = irq_get_msi_desc(irq);\n\n\t__get_cached_msi_msg(entry, msg);\n}"
  },
  {
    "function_name": "__get_cached_msi_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "59-62",
    "snippet": "void __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg)\n{\n\t*msg = entry->msg;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nvoid __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg)\n{\n\t*msg = entry->msg;\n}"
  },
  {
    "function_name": "free_msi_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "53-57",
    "snippet": "void free_msi_entry(struct msi_desc *entry)\n{\n\tkfree(entry->affinity);\n\tkfree(entry);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nvoid free_msi_entry(struct msi_desc *entry)\n{\n\tkfree(entry->affinity);\n\tkfree(entry);\n}"
  },
  {
    "function_name": "alloc_msi_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/msi.c",
    "lines": "29-51",
    "snippet": "struct msi_desc *\nalloc_msi_entry(struct device *dev, int nvec, const struct cpumask *affinity)\n{\n\tstruct msi_desc *desc;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&desc->list);\n\tdesc->dev = dev;\n\tdesc->nvec_used = nvec;\n\tif (affinity) {\n\t\tdesc->affinity = kmemdup(affinity,\n\t\t\tnvec * sizeof(*desc->affinity), GFP_KERNEL);\n\t\tif (!desc->affinity) {\n\t\t\tkfree(desc);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn desc;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/slab.h>",
      "#include <linux/msi.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irq.h>",
      "#include <linux/device.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "desc"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "affinity",
            "nvec * sizeof(*desc->affinity)",
            "GFP_KERNEL"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&desc->list"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*desc)",
            "GFP_KERNEL"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/slab.h>\n#include <linux/msi.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\nstruct msi_desc *\nalloc_msi_entry(struct device *dev, int nvec, const struct cpumask *affinity)\n{\n\tstruct msi_desc *desc;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&desc->list);\n\tdesc->dev = dev;\n\tdesc->nvec_used = nvec;\n\tif (affinity) {\n\t\tdesc->affinity = kmemdup(affinity,\n\t\t\tnvec * sizeof(*desc->affinity), GFP_KERNEL);\n\t\tif (!desc->affinity) {\n\t\t\tkfree(desc);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn desc;\n}"
  }
]